{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"about/","title":"About","text":""},{"location":"algorithm/algorithm-bfs-and-dfs/","title":"Algorithm - BFS and DFS","text":"<p>Breadth-first search (BFS) is an algorithm for traversing or searching tree or graph data structures. It starts at the tree root (or some arbitrary node of a graph), and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.</p> <p>Depth-first search (DFS) is an algorithm for traversing or searching tree or graph data structures. The algorithm starts at the root node (selecting some arbitrary node as the root node in the case of a graph) and explores as far as possible along each branch before backtracking.</p>"},{"location":"algorithm/algorithm-bfs-and-dfs/#tree-problems","title":"Tree Problems","text":"<p>A Tree is typically traversed in two ways:</p> <ul> <li>Breadth First Traversal (Or Level Order Traversal)</li> <li>Depth First Traversals</li> <li>Inorder Traversal (Left-Root-Right)</li> <li>Preorder Traversal (Root-Left-Right)</li> <li>Postorder Traversal (Left-Right-Root)</li> </ul>"},{"location":"algorithm/algorithm-bfs-and-dfs/#binary-tree-level-order-traversal","title":"Binary Tree Level Order Traversal","text":"<p>Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).</p> <p>For example:</p> <pre><code>Given binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its level order traversal as:\n[\n  [3],\n  [9,20],\n  [15,7]\n]\n</code></pre> <p>Implementation:</p> <pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n    if (root == null) {\n        return ans;\n    }\n\n    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n        int size = queue.size();\n        for (int i = 0; i &lt; size; i++) {\n            TreeNode node = queue.poll();\n            list.add(node.val);\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n        }\n        ans.add(list);\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#binary-tree-pre-order-traversal","title":"Binary Tree Pre-Order Traversal","text":"<p>Given a binary tree, return the pre-order traversal of its nodes' values.</p> <p>For example:</p> <pre><code>Given binary tree [3,9,20,null,null,15,7],\n    3\n   / \\\n  9  20\n    /  \\\n   15   7\nreturn its pre-order traversal as:\n[3,9,20,15,7]\n</code></pre> <p>Implementation:</p> <pre><code>public List&lt;Integer&gt; preorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; ans = new ArrayList&lt;&gt;();\n    if (root == null) {\n        return ans;\n    }\n\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n    stack.push(root);\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        ans.add(node.val);\n        if (node.right != null) {\n            stack.push(node.right);\n        }\n        if (node.left != null) {\n            stack.push(node.left);\n        }\n    }\n    return ans;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#graph-problems","title":"Graph Problems","text":""},{"location":"algorithm/algorithm-bfs-and-dfs/#all-paths-from-source-to-target","title":"All Paths From Source to Target","text":"<p>Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order.</p> <p>The graph is given as follows:  the nodes are 0, 1, ..., graph.length - 1.  graph[i] is a list of all nodes j for which the edge (i, j) exists.</p> <pre><code>Example:\nInput: [[1,2], [3], [3], []]\nOutput: [[0,1,3],[0,2,3]]\nExplanation: The graph looks like this:\n0---&gt;1\n|    |\nv    v\n2---&gt;3\nThere are two paths: 0 -&gt; 1 -&gt; 3 and 0 -&gt; 2 -&gt; 3.\n</code></pre> <p>DFS Solution.</p> <pre><code>public List&lt;List&lt;Integer&gt;&gt; allPathsSourceTarget(int[][] graph) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    list.add(0);\n    dfs(graph, 0, list, ans);\n\n    return ans;\n}\n\nprivate void dfs(int[][] graph, int node, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; ans) {\n    if (node == graph.length - 1) {\n        ans.add(new ArrayList&lt;&gt;(list));\n    }\n\n    for (int nei : graph[node]) {\n        list.add(nei);\n        dfs(graph, nei, list, ans);\n        list.remove(list.size() - 1);\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#traverse-in-undirected-graph","title":"Traverse in Undirected Graph","text":"<p>Given an undirected graph with 5 vertices, traverse all vertices in this graph. </p>"},{"location":"algorithm/algorithm-bfs-and-dfs/#dfs-solution","title":"DFS Solution","text":"<p>DFS traverse returns [A, B, C, D, E].</p> <pre><code>// dfs, recursion\npublic void dfs(Node root, List&lt;String&gt; list) {\n    if (root == null) {\n        return;\n    }\n    list.add(root.name);\n    root.visited = true;\n    for (Node neighbor : root.neighbors) {\n        if (neighbor.visited == false) {\n            dfs(neighbor, list);\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#bfs-solution","title":"BFS Solution","text":"<p>BFS traverse returns [A, B, E, C, D].</p> <pre><code>public List&lt;String&gt; bfs(Node root) {\n    List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n    if (root == null) {\n        return ans;\n    }\n    Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();\n    root.visited = true;\n    ans.add(root.name);\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        Node node = queue.poll();\n        for (Node neighbor : node.neighbors) {\n            if (neighbor.visited == false) {\n                neighbor.visited = true;\n                ans.add(neighbor.name);\n                queue.offer(neighbor);\n            }\n        }\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#matrix-problems","title":"Matrix Problems","text":""},{"location":"algorithm/algorithm-bfs-and-dfs/#number-of-islands","title":"Number of Islands","text":"<p>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p> <p>Example 1:</p> <pre><code>Input:\n11110\n11010\n11000\n00000\nOutput: 1\n</code></pre> <p>Example 2:</p> <pre><code>Input:\n11000\n11000\n00100\n00011\nOutput: 3\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#solution-1-dfs","title":"Solution 1: DFS","text":"<p>Recursive. Modifying the original given grid, space: O(1), time: (m*n).</p> <pre><code>// DFS: change values of given grid, space: O(1), time: (m*n)\npublic int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0 || grid[0].length == 0) {\n        return 0;\n    }\n\n    int m = grid.length;\n    int n = grid[0].length;\n    int ans = 0;\n\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (grid[i][j] == '1') {\n                ans++;\n                dfs(grid, i, j);\n            }\n        }\n    }  \n\n    return ans;\n}\n\n// set adjacent cell to 0\nprivate void dfs(char[][] grid, int i, int j) {\n    int m = grid.length;\n    int n = grid[0].length;\n    if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n) {\n        return;\n    }\n\n    if (grid[i][j] == '1') {\n        grid[i][j] = '0';\n        dfs(grid, i - 1, j); // up\n        dfs(grid, i + 1, j); // down\n        dfs(grid, i, j - 1); // left\n        dfs(grid, i, j + 1); // right\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#solution-2-bfs","title":"Solution 2: BFS","text":"<p>Use queue to to store all cells for the next round scan. Use hashset to avoid adding duplicate cells to queue. Space: min(m,n), time: (m*n)</p> <pre><code>// BFS: change values of given grid, space: O(1), time: (m*n)\npublic int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0 || grid[0].length == 0) {\n        return 0;\n    }\n\n    int m = grid.length;\n    int n = grid[0].length;\n    int[] dr = new int[]{0, -1, 0, 1};\n    int[] dc = new int[]{1, 0, -1, 0};\n    int ans = 0;\n\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (grid[i][j] == '1') {\n                ans++;\n                Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();\n                queue.offer(new int[] {i, j});\n                while (!queue.isEmpty()) {\n                    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n                    int size = queue.size();\n                    for (int k = 0; k &lt; size; k++) {\n                        int[] pos = queue.poll();\n                        grid[pos[0]][pos[1]] = '0';\n                        for (int p = 0; p &lt; 4; p++) {\n                            int r = pos[0] + dr[p];\n                            int c = pos[1] + dc[p];\n                            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] == '0') {\n                                continue;\n                            }\n                            if (!set.contains(r * n + c)) {\n                                queue.offer(new int[] {r, c});\n                                set.add(r * n + c);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }  \n\n    return ans;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bfs-and-dfs/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 102 - Binary Tree Level Order Traversal</li> <li>LeetCode 144 - Binary Tree Preorder Traversal</li> <li>LeetCode 200 - Number of Islands</li> <li>LeetCode 542 - 01 Matrix</li> <li>LeetCode 797 - All Paths From Source to Target</li> </ul>"},{"location":"algorithm/algorithm-bfs-and-dfs/#source-files","title":"Source files","text":"<ul> <li>Source files for BFS and DFS on GitHub</li> </ul>"},{"location":"algorithm/algorithm-bfs-and-dfs/#references","title":"References","text":"<ul> <li>Depth-first search</li> <li>Breadth-first search</li> <li>BFS vs DFS for Binary Tree</li> <li>Breadth first search and depth first search</li> </ul>"},{"location":"algorithm/algorithm-binary-search/","title":"Algorithm - Binary Search","text":"<p>Binary search template.</p>"},{"location":"algorithm/algorithm-binary-search/#search-problem","title":"Search Problem","text":"<p>Given a <code>sorted</code> array with n elements, write a function to search a given element x in array. A simple approach is to do linear search. The time complexity of above algorithm is $O(n)$. Another approach to perform the same task is using Binary Search. The time complexity of binary search algorithm is $O(\\log{}n)$.</p>"},{"location":"algorithm/algorithm-binary-search/#binary-search","title":"Binary Search","text":""},{"location":"algorithm/algorithm-binary-search/#how-it-works","title":"How it works?","text":"<p>Search a sorted array by repeatedly dividing the search interval in half. Begin with an interval covering the whole array. If the value of the search key is less than the item in the middle of the interval, narrow the interval to the lower half. Otherwise narrow it to the upper half. Repeatedly check until the value is found or the interval is empty.</p>"},{"location":"algorithm/algorithm-binary-search/#steps","title":"Steps","text":"<ul> <li>1) Compare x with the middle element.</li> <li>2) If x matches with middle element, we return the mid index, stop searching, otherwise, go to step 3.</li> <li>3) If x is greater than the mid element, then x can only lie in right half subarray after the mid element. So we recur for right half.</li> <li>4) Otherwise(x is smaller), recur for the left half.</li> </ul> <p>See the example below.</p> <p></p>"},{"location":"algorithm/algorithm-binary-search/#variants","title":"Variants","text":"<p>Given an sorted integer array - nums, and an integer - target. Find the <code>any/first/last</code> position of target in nums, return -1 if target doesn\u2019t exist.</p>"},{"location":"algorithm/algorithm-binary-search/#implementation","title":"Implementation","text":""},{"location":"algorithm/algorithm-binary-search/#recursive-implementationfind-any","title":"Recursive Implementation(find any)","text":"<pre><code>// recursive implementation\npublic int search(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return -1;\n    }\n\n    return recursiveHelper(nums, 0, nums.length - 1, target);\n}\n\nprivate int recursiveHelper(int[] nums, int start, int end, int target) {\n    if (start &gt; end) {\n        return -1;\n    }\n\n    int mid = start + (end - start) / 2; // avoid overflow of (start + end) / 2\n    if (nums[mid] == target) {\n        // found\n        return mid;\n    } else if (nums[mid] &lt; target) {\n        // search in the right half\n        return recursiveHelper(nums, mid + 1, end, target);\n    } else {\n        // search in the left half\n        return recursiveHelper(nums, start, mid - 1, target);\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-binary-search/#iterative-implementationfind-any","title":"Iterative Implementation(find any)","text":"<pre><code>// iterative implementation\npublic int search(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return -1;\n    }\n    int start = 0;\n    int end = nums.length - 1;\n\n    while (start &lt;= end) {\n        int mid = start + (end - start) / 2; // avoid overflow of (start + end) / 2\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] &lt; target) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n\n    return -1;\n}\n</code></pre> <ul> <li>Infinite loop may easily occur(eg. start is same with end) if we set start or end improperly.</li> </ul>"},{"location":"algorithm/algorithm-binary-search/#binary-search-templatefind-any","title":"Binary Search Template(find any)","text":"<pre><code>// binary search template, can be applied to most of the binary search problems\npublic int search(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return -1;\n    }\n    int start = 0;\n    int end = nums.length - 1;\n\n    while (start + 1 &lt; end) { // avoid infinite loop, need to check nums[start] and nums[end] after the while loop\n        int mid = start + (end - start) / 2; // avoid overflow of (start + end) / 2\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] &lt; target) {\n            start = mid; // no need +1\n        } else {\n            end = mid;   // no need -1\n        }\n    }\n\n    // need to check the start and end\n    if (nums[start] == target) {\n        return start;\n    }\n\n    if (nums[end] == target) {\n        return end;\n    }\n\n    return -1;\n}\n</code></pre> <ul> <li>Notice the inequality <code>start + 1 &lt; end</code>. No matter what value of <code>mid</code> becomes to, either <code>start</code> or <code>end</code> will change accordingly. Thus, the inequality will be evaluated with new values to make sure the while loop will be broken when the difference of <code>start</code> and <code>end</code> are close to one.</li> </ul>"},{"location":"algorithm/algorithm-binary-search/#binary-search-templatefind-first","title":"Binary Search Template(find first)","text":"<p>Based on the template, just need to change the logic when we find the target with <code>mid</code> and make sure check <code>start</code> first after the while loop.</p> <pre><code>// search the first occurrence\npublic int searchFirst(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return -1;\n    }\n    int start = 0;\n    int end = nums.length - 1;\n\n    while (start + 1 &lt; end) {\n        int mid = start + (end - start) / 2;\n        if (nums[mid] == target) {\n            end = mid; // don't return, instead, exclude the right part\n        } else if (nums[mid] &lt; target) {\n            start = mid;\n        } else {\n            end = mid;\n        }\n    }\n\n    // check start first\n    if (nums[start] == target) {\n        return start;\n    }\n\n    if (nums[end] == target) {\n        return end;\n    }\n\n    return -1;\n}\n</code></pre>"},{"location":"algorithm/algorithm-binary-search/#binary-search-templatefind-last","title":"Binary Search Template(find last)","text":"<p>Based on the template, just need to change the logic when we find the target with <code>mid</code> and check <code>end</code> first after the while loop.</p> <pre><code>// search the last occurrence\npublic int searchLast(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return -1;\n    }\n    int start = 0;\n    int end = nums.length - 1;\n\n    while (start + 1 &lt; end) {\n        int mid = start + (end - start) / 2;\n        if (nums[mid] == target) {\n            start = mid; // don't return, instead, exclude the left part\n        } else if (nums[mid] &lt; target) {\n            start = mid;\n        } else {\n            end = mid;\n        }\n    }\n\n    // check end first\n    if (nums[end] == target) {\n        return end;\n    }\n\n    if (nums[start] == target) {\n        return start;\n    }\n\n    return -1;\n}\n</code></pre>"},{"location":"algorithm/algorithm-binary-search/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 704 - Binary Search</li> <li>LintCode 61 - Search for a range</li> <li>LeetCode 35 - Search Insert Position</li> <li>LeetCode 74 - Search a 2D Matrix</li> <li>LeetCode 278 - First Bad Version</li> <li>LeetCode 162 - Find Peak Element</li> <li>LeetCode 33 - Search in Rotated Sorted Array</li> <li>LeetCode 153 - Find Minimum in Rotated Sorted Array</li> <li>LeetCode 4 - Median of Two Sorted Arrays</li> <li>LeetCode 88 - Merge Sorted Array</li> <li>LintCode 39 - Recover Sorted Array</li> <li>LeetCode 796 - Rotate String</li> <li>LeetCode 151 - Reverse Words in a String</li> </ul>"},{"location":"algorithm/algorithm-binary-search/#source-files","title":"Source files","text":"<ul> <li>Source files for Binary Search on GitHub</li> <li>Binary Search Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-binary-search/#references","title":"References","text":"<ul> <li>Binary Search at Geeksforgeeks</li> </ul>"},{"location":"algorithm/algorithm-bit-manipulation/","title":"Algorithm - Bit Manipulation","text":""},{"location":"algorithm/algorithm-bit-manipulation/#operations-for-bit","title":"Operations for Bit","text":"<ul> <li>&amp; (And)</li> <li>| (OR)</li> <li>^ (XOR)</li> <li>~ (Negative)</li> </ul>"},{"location":"algorithm/algorithm-bit-manipulation/#common-facts","title":"Common Facts","text":"XOR AND OR x ^ 0s = x x &amp; 0s = 0 x | 0s = x x ^ 1s = ~x x &amp; 1s = x x | 1s = 1 x ^ x = 0 x &amp; x = x x | x = x"},{"location":"algorithm/algorithm-bit-manipulation/#shifting","title":"Shifting","text":"<ul> <li>Arithmetic Right Shift (take the sign bit to most significant bit)</li> <li>Logical Right Shift (alway shift zero to most significant bit)</li> </ul> <p>See the difference through the below sample.</p> <pre><code>public static void main(String[] args) {\n    // output 0, shift 0, since it is positive, finally becomes to 00000000 00000000 00000000 00000000\n    System.out.println(repeatArithmeticShift(34543,40));\n    // output 0, logical shift always append a zero into the most significant bit repeatedly.\n    System.out.println(repeatLogicShift(34543,40));\n    // output -1, shift 1, since it is negative, finally becomes to 11111111 11111111 11111111 11111111\n    System.out.println(repeatArithmeticShift(-34543,40));\n    // output 0, logical shift always append a zero into the most significant bit repeatedly.\n    System.out.println(repeatLogicShift(-34543,40));\n}\n\npublic static int repeatArithmeticShift(int x, int count) {\n    for (int i = 0; i &lt; count; i++) {\n        x &gt;&gt;= 1; //Arithmetic shift by 1\n    }\n    return x;\n}\n\npublic static int repeatLogicShift(int x, int count) {\n    for (int i = 0; i &lt; count; i++) {\n        x &gt;&gt;&gt;= 1; //Logical shift by 1\n    }\n    return x;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#common-bit-methods","title":"Common Bit Methods","text":""},{"location":"algorithm/algorithm-bit-manipulation/#getting-bit","title":"Getting Bit","text":"<p>Given an integer and a specific position, check whether the bit at this position of the given number is one.</p> <pre><code>boolean getBit(int num, int i) { // i range is {0, 31}, 0 is the rightest\n    return (num &amp; (1 &lt;&lt; i)) != 0; // if i = 4, (1 &lt;&lt; i) =&gt; 00010000\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#setting-bit","title":"Setting Bit","text":"<p>Given an integer and a specific position, set the bit at this position of the given number to one.</p> <pre><code>int setBit(int num, int i) {\n    return num | (1 &lt;&lt; i); // if i = 4, (1 &lt;&lt; i) =&gt; 00010000\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#clearing-bit","title":"Clearing Bit","text":"<p>Given an integer and a specific position, set the bit at this position of the given number to zero.</p> <pre><code>int clearBit(int num, int i) {\n    int mask = ~(1 &lt;&lt; i); // if i = 4, (1 &lt;&lt; i) =&gt; 00010000, mask = 11101111\n    return num &amp; mask;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#clearing-bitleft-part","title":"Clearing Bit(Left Part)","text":"<p>Given an integer and a specific position, clear all bits from the most significant bit through i (inclusive).</p> <pre><code>int clearBitsMSthroughI(int num, int i) {\n    int mask = (1 &lt;&lt; i) - 1; // if i = 4, (1 &lt;&lt; i) =&gt; 00010000, mask = 00001111\n    return num &amp; mask;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#clearing-bitright-part","title":"Clearing Bit(Right Part)","text":"<p>Given an integer and a specific position, clear all bits from i (inclusive) through 0 (inclusive).</p> <pre><code>int clearBitsIthrough0(int num, int i) {\n    int mask = -1 &lt;&lt; (i + 1); // if i = 4, mask = 11100000\n    return num &amp; mask;\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#updating-bit","title":"Updating Bit","text":"<p>Given an integer and a specific position, set the bit at this position of to a given value(0 or 1).</p> <pre><code>int updateBit(int num, int i, boolean bitIsOne) {\n    int value = bitIsOne ? 1 : 0;\n    int mask = ~(1 &lt;&lt; i); // if i = 4, mask = 11101111\n    return (num &amp; mask) | (value &lt;&lt; i); // if i = 4, and value = 1, (value &lt; i) =  00010000\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#pairwise-swap","title":"Pairwise Swap","text":"<p>Given an integer, swap its odd and even bits with as few instructions as possible (e.g., bit 0 and bit 1 are swapped, bit 2 and bit 3 are swapped, and so on).</p> <pre><code>int swapOddEvenBits(int num) { // solution based on 32-bit system\n    // a =&gt; 1010, 5 =&gt; 0101\n    return (((num &amp; 0xaaaaaaaa) &gt;&gt;&gt; 1) | ((num &amp; 0x55555555) &lt;&lt; 1));\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#arithmetic-implementation","title":"Arithmetic Implementation","text":"<pre><code>// It works for both positive as well as negative numbers\npublic int add(int a, int b) {  \n    while (b != 0) {\n        int c = a &amp; b;  // Find the carry bits\n        a = a ^ b;  // Add the bits without considering the carry\n        b = c &lt;&lt; 1;  // Propagate the carry\n    }\n    return a;\n}\n\npublic int sub(int a, int b) {\n    return add(a, -b);\n}\n\npublic int multiply(int a, int b) {\n    todo\n}\npublic int divide(int a, int b) {\n    todo\n}\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#checking-if-an-integer-is-power-of-two","title":"Checking If An Integer is Power of Two","text":"<pre><code>n &amp; (n-1) == 0;\n</code></pre> <p>Example: If n = 8, then 1000 &amp; 111 == 0 If n = 9, then 1001 &amp; 1000 == 1000 != 0 If n = 10, then 1010 &amp; 1001 == 1000 != 0</p>"},{"location":"algorithm/algorithm-bit-manipulation/#getting-the-last-1-for-a-number","title":"Getting the last 1 for a number","text":"<p>Or we can say find the biggest factor with power of two for number x.</p> <pre><code>x &amp;= -x;\n</code></pre> <p>Examples: if x = 5, then x = 0101 &amp; (1011) = 0001 = 1 = 2^0 if x = 6, then x = 0110 &amp; (1010) = 0010 = 2 = 2^1 if x = 28, then x = 00011100 &amp; 11100100 = 00000100 = 4 = 2^2</p>"},{"location":"algorithm/algorithm-bit-manipulation/#implementing-mathematic-addition","title":"Implementing mathematic addition","text":"<pre><code>int add(int a, int b) {  \n    while (b != 0) {\n        int c = a &amp; b;  // Find the carry bits\n        a = a ^ b;  // Add the bits without considering the carry\n        b = c &lt;&lt; 1;  // Propagate the carry\n    }\n    return a;\n}\n</code></pre> <p>The code shown above is actually the way how we calculate sum of two numbers in decimal. For example: a = 138, b = 296 Step 1: Calculate sum of two number without taking the carry, 138 + 296 = 324 Step 2: Calculate sum of two number by only getting the carry, 138 + 296 = 011 Step 3: Shift the carry result to left by 1 then add sum1, 0324 + 0110 = 434.</p>"},{"location":"algorithm/algorithm-bit-manipulation/#decimal-to-binary","title":"Decimal to Binary","text":"<pre><code> 2147483647 = 011111111111111111111111111111111\n          3 = 000000000000000000000000000000011\n          2 = 000000000000000000000000000000010\n          1 = 000000000000000000000000000000001\n          0 = 000000000000000000000000000000000\n         -1 = 111111111111111111111111111111111\n         -2 = 111111111111111111111111111111110\n         -3 = 111111111111111111111111111111101\n-2147483647 = 100000000000000000000000000000001\n-2147483648 = 100000000000000000000000000000000\n</code></pre>"},{"location":"algorithm/algorithm-bit-manipulation/#reference","title":"Reference","text":""},{"location":"algorithm/algorithm-combination-and-permutation/","title":"Algorithm - Combination and Permutation","text":"<p>Solve problems of combination, permutation and subset with DFS.</p>"},{"location":"algorithm/algorithm-combination-and-permutation/#combination-problem","title":"Combination Problem","text":"<p>Given two integers <code>n</code> and <code>k</code>, return all possible combinations of <code>k</code> numbers out of 1 ... n.</p> <p>Example:</p> <pre><code>Input: n = 4, k = 2\nOutput:\n[\n  [2,4],\n  [3,4],\n  [2,3],\n  [1,2],\n  [1,3],\n  [1,4],\n]\n</code></pre>"},{"location":"algorithm/algorithm-combination-and-permutation/#solution-for-combination","title":"Solution for Combination","text":"<pre><code>public List&lt;List&lt;Integer&gt;&gt; combine(int n, int k) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n    if (n &lt;= 0 || k &lt;= 0 || n &lt; k) {\n        return ans;\n    }\n\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    dfs(n, k, 1, list, ans);\n\n    return ans;\n}\n\nprivate void dfs(int n, int k, int pos, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; ans) {\n    if (list.size() == k) {\n        ans.add(new ArrayList&lt;Integer&gt;(list));\n        return;\n    }\n\n    for(int i = pos; i &lt;= n; i++) {\n        list.add(i);\n        dfs(n, k, i + 1, list, ans);\n        list.remove(list.size() - 1);\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-combination-and-permutation/#permutation-problem","title":"Permutation Problem","text":"<p>Given a collection of distinct integers, return all possible permutations.</p> <p>Example:</p> <pre><code>Input: [1,2,3]\nOutput:\n[\n  [1,2,3],\n  [1,3,2],\n  [2,1,3],\n  [2,3,1],\n  [3,1,2],\n  [3,2,1]\n]\n</code></pre>"},{"location":"algorithm/algorithm-combination-and-permutation/#solution-for-permutation","title":"Solution for Permutation","text":"<pre><code>public List&lt;List&lt;Integer&gt;&gt; permute(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n    if (nums == null || nums.length == 0) {\n        return ans;\n    }\n\n    boolean[] visited = new boolean[nums.length];\n    dfs(nums, visited, new ArrayList&lt;&gt;(), ans);\n    return ans;\n}\n\nprivate void dfs(int[] nums, boolean[] visited, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; ans) {\n    if (list.size() == nums.length) {\n        ans.add(new ArrayList&lt;&gt;(list));\n        return;\n    }\n\n    for (int i = 0; i &lt; nums.length; i++) {\n        if (visited[i]) {\n            continue;\n        }\n        visited[i] = true;\n        list.add(nums[i]);\n        dfs(nums, visited, list, ans);\n        list.remove(list.size() - 1);\n        visited[i] = false;\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-combination-and-permutation/#subsets-problem","title":"Subsets Problem","text":"<p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p> <p>Note: The solution set must not contain duplicate subsets.</p> <p>Example:</p> <pre><code>Input: nums = [1,2,3]\nOutput:\n[\n  [3],\n  [1],\n  [2],\n  [1,2,3],\n  [1,3],\n  [2,3],\n  [1,2],\n  []\n]\n</code></pre>"},{"location":"algorithm/algorithm-combination-and-permutation/#solution-for-subsets","title":"Solution for Subsets","text":"<pre><code>public List&lt;List&lt;Integer&gt;&gt; subsets(int[] nums) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;&gt;();\n    if (nums == null || nums.length == 0) {\n        return ans;\n    }\n\n    //Arrays.sort(nums); // not necessary, just for unit test\n    dfs(nums, 0, new ArrayList&lt;&gt;(), ans);\n\n    return ans;\n}\n\nprivate void dfs(int[] nums, int pos, List&lt;Integer&gt; list, List&lt;List&lt;Integer&gt;&gt; ans) {\n    ans.add(new ArrayList&lt;&gt;(list));\n\n    for (int i = pos; i &lt; nums.length; i++) {\n        list.add(nums[i]);\n        dfs(nums, i + 1, list, ans);\n        list.remove(list.size() - 1);\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-combination-and-permutation/#summary","title":"Summary","text":"<ul> <li>Combinations: need to use <code>pos</code>, no for loop in the main function.</li> <li>Permutations: no need to use <code>pos</code>, use <code>visited</code> array to store which numbers are used, no for loop in the main function.</li> <li>Subsets: need to use <code>pos</code>, no for loop in the main function.</li> </ul>"},{"location":"algorithm/algorithm-combination-and-permutation/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 77 - Combinations</li> <li>LeetCode 39 - Combination Sum</li> <li>LeetCode 40 - Combination Sum II</li> <li>LeetCode 216 - Combination Sum III</li> <li>LeetCode 46 - Permutations</li> <li>LeetCode 78. Subsets</li> </ul>"},{"location":"algorithm/algorithm-combination-and-permutation/#references","title":"References","text":"<ul> <li>\u82b1\u82b1\u9171 LeetCode 78. Subsets - \u5237\u9898\u627e\u5de5\u4f5c EP236</li> </ul>"},{"location":"algorithm/algorithm-coordinate/","title":"Algorithm - Coordinate","text":""},{"location":"algorithm/algorithm-coordinate/#coordinate","title":"Coordinate","text":""},{"location":"algorithm/algorithm-coordinate/#robot-bounded-in-circle","title":"Robot Bounded In Circle","text":"<p>On an infinite plane, a robot initially stands at (0, 0) and faces north.  The robot can receive one of three instructions:</p> <ul> <li>\"G\": go straight 1 unit;</li> <li>\"L\": turn 90 degrees to the left;</li> <li>\"R\": turn 90 degress to the right.</li> </ul> <p>The robot performs the instructions given in order, and repeats them forever.</p> <p>Return true if and only if there exists a circle in the plane such that the robot never leaves the circle.</p> <p>Example 1:</p> <pre><code>Input: \"GGLLGG\"\nOutput: true\nExplanation:\nThe robot moves from (0,0) to (0,2), turns 180 degrees, and then returns to (0,0).\nWhen repeating these instructions, the robot remains in the circle of radius 2 centered at the origin.\n</code></pre> <p>Example 2:</p> <pre><code>Input: \"GG\"\nOutput: false\nExplanation:\nThe robot moves north indefinitely.\n</code></pre> <p>Example 3:</p> <pre><code>Input: \"GL\"\nOutput: true\nExplanation:\nThe robot moves from (0, 0) -&gt; (0, 1) -&gt; (-1, 1) -&gt; (-1, 0) -&gt; (0, 0) -&gt; ...\n</code></pre> <p>Note:</p> <pre><code>1 &lt;= instructions.length &lt;= 100\ninstructions[i] is in {'G', 'L', 'R'}\n</code></pre>"},{"location":"algorithm/algorithm-coordinate/#solution","title":"Solution","text":"<pre><code>public boolean isRobotBounded(String instructions) {\n    int x = 0, y = 0, i = 0, d[][] = \\{\\{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    for (int j = 0; j &lt; instructions.length(); ++j)\n        if (instructions.charAt(j) == 'R')\n            i = (i + 1) % 4;\n        else if (instructions.charAt(j) == 'L')\n            i = (i + 3) % 4;\n        else {\n            x += d[i][0];\n            y += d[i][1];\n        }\n    return x == 0 &amp;&amp; y == 0 || i &gt; 0;\n}\n</code></pre>"},{"location":"algorithm/algorithm-coordinate/#references","title":"References","text":"<ul> <li>1041. Robot Bounded In Circle</li> </ul>"},{"location":"algorithm/algorithm-divide-and-conquer/","title":"Algorithm - Divide and Conquer","text":"<p>Divide and Conquer is an algorithmic paradigm. A typical Divide and Conquer algorithm solves a problem using following three steps.</p> <ul> <li><code>Divide</code>: Break the given problem into subproblems of same type.</li> <li><code>Conquer</code>: Recursively solve these subproblems</li> <li><code>Combine</code>: Appropriately combine the answers</li> </ul>"},{"location":"algorithm/algorithm-divide-and-conquer/#typical-algorithms","title":"Typical Algorithms","text":"<ul> <li>Merge Sort</li> <li>Binary Search</li> </ul>"},{"location":"algorithm/algorithm-divide-and-conquer/#merge-sort","title":"Merge Sort","text":"<p>A classic example of Divide and Conquer is Merge Sort demonstrated below. In Merge Sort, we divide array into two halves, sort the two halves recursively, and then merge the sorted halves.  </p> <p>Implementation:</p> <pre><code>public void mergeSort(int[] nums) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n    mergeHelper(nums, 0, nums.length - 1);\n    return;\n}\n\nprivate void mergeHelper(int[] nums, int start, int end) {\n    if (start &gt;= end) {\n        return;\n    }\n\n    int mid = start + (end - start) / 2;\n    mergeHelper(nums, start, mid);\n    mergeHelper(nums, mid + 1, end);\n    merge(nums, start, mid, end);\n}\n\nprivate void merge(int[] nums, int start, int mid, int end) {\n    int[] copy = Arrays.copyOf(nums, nums.length);\n\n    int left = start;\n    int right = mid + 1;\n    for (int k = start; k &lt;= end; k++) {\n        if (left &gt; mid) { // no item at left\n            nums[k] = copy[right];\n            right++;\n        }\n        else if(right &gt; end) { // no item at right\n            nums[k] = copy[left];\n            left++;\n        }\n        else if (copy[left] &lt;= copy[right]) {\n            nums[k] = copy[left];\n            left++;\n        }\n        else{\n            nums[k] = copy[right];\n            right++;\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-divide-and-conquer/#binary-search","title":"Binary Search","text":"<p>Binary Search is a searching algorithm. In each step, the algorithm compares the input element x with the value of the middle element in array. If the values match, return the index of middle. Otherwise, if x is less than the middle element, then the algorithm recurs for left side of middle element, else recurs for right side of middle element.</p> <p>Implementation:</p> <pre><code>public int search(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return -1;\n    }\n\n    int start = 0;\n    int end = nums.length - 1;\n    while (start + 1 &lt; end) {\n        int mid = start + (end - start) / 2;\n        if (nums[mid] == target) {\n            return mid;\n        } else if (nums[mid] &lt; target) {\n            start = mid + 1;\n        } else {\n            end = mid - 1;\n        }\n    }\n\n    if (nums[start] == target) {\n        return start;\n    }\n    if (nums[end] == target) {\n        return end;\n    }\n    return -1;\n}\n</code></pre>"},{"location":"algorithm/algorithm-divide-and-conquer/#sort-linked-list","title":"Sort Linked List","text":""},{"location":"algorithm/algorithm-divide-and-conquer/#description","title":"Description","text":"<p>Sort a linked list in O(nlog(n)) time using constant space complexity.</p> <p>Example 1:</p> <pre><code>Input: 4-&gt;2-&gt;1-&gt;3\nOutput: 1-&gt;2-&gt;3-&gt;4\n</code></pre> <p>Example 2:</p> <pre><code>Input: -1-&gt;5-&gt;3-&gt;4-&gt;0\nOutput: -1-&gt;0-&gt;3-&gt;4-&gt;5\n</code></pre>"},{"location":"algorithm/algorithm-divide-and-conquer/#solution","title":"Solution","text":"<p>Find the middle element, partition the list into two sub lists. Sort them separately, then merge the results.</p> <pre><code>public ListNode sortList(ListNode head) {\n    if (head == null || head.next == null) {\n        return head;\n    }\n\n    ListNode fast = head.next;\n    ListNode slow = head;\n    while (fast != null &amp;&amp; fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n    }\n\n    ListNode right = sortList(slow.next);\n    slow.next = null;\n    ListNode left = sortList(head);\n    return merge(left, right);\n}\n\npublic ListNode merge(ListNode l1, ListNode l2) {\n    if (l1 == null) {\n        return l2;\n    }\n    if (l2 == null) {\n        return l1;\n    }\n\n    ListNode dummy = new ListNode(0);\n    ListNode curr = dummy;\n    while (l1 != null &amp;&amp; l2 != null) {\n        if (l1.val &lt;= l2.val) {\n            curr.next = l1;\n            l1 = l1.next;\n        } else {\n            curr.next = l2;\n            l2 = l2.next;\n        }\n        curr = curr.next;\n    }\n\n    if (l1 != null) {\n        curr.next = l1;\n    }\n    if (l2 != null) {\n        curr.next = l2;\n    }\n\n    return dummy.next;\n}\n</code></pre>"},{"location":"algorithm/algorithm-divide-and-conquer/#using-divide-conquer-for-tree-problems","title":"Using Divide &amp; Conquer for Tree Problems","text":""},{"location":"algorithm/algorithm-divide-and-conquer/#binary-tree-traversal","title":"Binary Tree Traversal","text":"<p>Given a binary tree, return the preorder/inorder/postorder traversal of its nodes' values.</p> <pre><code>Input: [1,null,2,3]\n   1\n    \\\n     2\n    /\n   3\n</code></pre> <p>Preorder: [1,2,3]</p> <pre><code>// Divide and conquer (recursion)\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n    if (root == null) {\n        return ans;\n    }\n\n    List&lt;Integer&gt; left = preorderTraversal(root.left);\n    List&lt;Integer&gt; right = preorderTraversal(root.right);\n\n    ans.add(root.val);\n    ans.addAll(left);\n    ans.addAll(right);\n    return ans;\n}\n</code></pre> <p>Inorder: [1,3,2]</p> <pre><code>// Divide and conquer (recursion)\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n    if (root == null) {\n        return ans;\n    }\n\n    List&lt;Integer&gt; left = inorderTraversal(root.left);\n    List&lt;Integer&gt; right = inorderTraversal(root.right);\n\n    ans.addAll(left);\n    ans.add(root.val);\n    ans.addAll(right);\n    return ans;\n}\n</code></pre> <p>Postorder: [3,2,1]</p> <pre><code>// Divide and conquer (recursion)\npublic List&lt;Integer&gt; postorderTraversal2(TreeNode root) {\n    List&lt;Integer&gt; ans = new ArrayList&lt;Integer&gt;();\n    if(root == null) {\n        return ans;\n    }\n\n    List&lt;Integer&gt; left = postorderTraversal(root.left);\n    List&lt;Integer&gt; right = postorderTraversal(root.right);\n\n    ans.addAll(left);\n    ans.addAll(right);\n    ans.add(root.val);\n    return ans;\n}\n</code></pre>"},{"location":"algorithm/algorithm-divide-and-conquer/#merge-two-binary-trees","title":"Merge Two Binary Trees","text":"<p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p> <p>Example:</p> <pre><code>Input:\n Tree 1                     Tree 2                  \n          1                         2                             \n         / \\                       / \\                            \n        3   2                     1   3                        \n       /                           \\   \\                      \n      5                             4   7                  \nOutput:\nMerged tree:\n      3\n     / \\\n    4   5\n   / \\   \\\n  5   4   7\n</code></pre> <p>Solution:</p> <pre><code>public TreeNode mergeTrees(TreeNode t1, TreeNode t2) {\n    if (t1 == null) {\n        return t2;\n    }\n\n    if (t2 == null) {\n        return t1;\n    }\n\n    TreeNode root = new TreeNode(t1.val + t2.val);\n    root.left = mergeTrees(t1.left, t2.left);\n    root.right = mergeTrees(t1.right, t2.right);\n    return root;\n}\n</code></pre>"},{"location":"algorithm/algorithm-divide-and-conquer/#divide-and-conquer-problems","title":"Divide and Conquer Problems","text":"<ul> <li>LeetCode 4 - Median of Two Sorted Arrays</li> <li>LeetCode 148 - Sort List</li> <li>LeetCode 704 - Binary Search</li> <li>LeetCode 94 - Binary Tree Inorder Traversal</li> <li>LeetCode 144 - Binary Tree Preorder Traversal</li> <li>LeetCode 145 - Binary Tree Postorder Traversal</li> <li>LeetCode 617 - Merge Two Binary Trees</li> </ul>"},{"location":"algorithm/algorithm-divide-and-conquer/#references","title":"References","text":"<ul> <li>Divide and Conquer at GeeksforGeeks</li> <li>Divide and Conquer Algorithm - Introduction</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/","title":"Algorithm - Dynamic Programming","text":"<p>Introduce dynamic programming.</p>"},{"location":"algorithm/algorithm-dynamic-programming/#when-to-use-dp","title":"When to use DP?","text":"<ul> <li>Maximum/Minimum</li> <li>Yes/No</li> <li>Count(*)</li> <li>Can't sort or swap</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/#dp-types","title":"DP Types","text":"<ul> <li>Matrix DP (10%)</li> <li>Sequence DP (40%)</li> <li>Two Sequences DP (40%)</li> <li>Backpack (10%)</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/#implementation-of-dp","title":"Implementation of DP","text":"<ul> <li>Memorization Search(Drawback: extra space)</li> <li>Loop</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/#matrix-dp","title":"Matrix DP","text":""},{"location":"algorithm/algorithm-dynamic-programming/#unique-paths","title":"Unique Paths","text":""},{"location":"algorithm/algorithm-dynamic-programming/#problem-description","title":"Problem Description","text":"<p>A robot is located at the top-left corner of a <code>m x n</code> grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?</p> <p> </p>"},{"location":"algorithm/algorithm-dynamic-programming/#solution-with-matrixtwo-dimensional-array","title":"Solution with Matrix(Two-dimensional array)","text":"<pre><code>// time: O(m*n), space: O(m*n)\npublic int uniquePathMatrix(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[][] dp = new int[m][n];\n    // Initialization\n    for (int i = 0; i &lt; m; i++) {\n        dp[i][0] = 1;\n    }\n    for (int j = 0; j &lt; n; j++) {\n        dp[0][j] = 1;\n    }\n    // Calculate dp[i][j]\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\n// time: O(m*n), space: O(m*n), without separated initialization\npublic int uniquePathMatrix2(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[][] dp = new int[m][n];\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n</code></pre> <ul> <li>Time complexity: $O(m*n)$</li> <li>Space complexity: $O(m*n)$</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/#solution-with-one-dimensional-array","title":"Solution with One-dimensional Array","text":"<p>Use one-dimensional array instead of the matrix. Same time complexity, but space is reduced to $O(n)$.</p> <pre><code>// time: O(m*n), space: O(n)\npublic int uniquePathArray(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[] dp = new int[n];\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (j == 0) {\n                dp[j] = 1;\n            } else {\n                dp[j] = dp[j] + dp[j - 1];\n            }\n        }\n    }\n\n    return dp[n - 1];\n}\n\n// time: O(m*n), space: O(n), without checking the first column\npublic int uniquePath(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[] dp = new int[n];\n    dp[0] = 1;\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (j &gt; 0) {\n                dp[j] = dp[j] + dp[j - 1];\n            }\n        }\n    }\n\n    return dp[n - 1];\n}\n</code></pre> <ul> <li>Time complexity: $O(m*n)$</li> <li>Space complexity: $O(n)$</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/#define-matrix-with-larger-size","title":"Define Matrix with Larger Size","text":"<p>When to define a dp matrix with <code>m+1</code> and <code>n+1</code>? see question LeetCode 221 - Maximal Square.</p>"},{"location":"algorithm/algorithm-dynamic-programming/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 62 - Unique Paths</li> <li>LeetCode 64 - Minimum Path Sum</li> <li>LeetCode 221 - Maximal Square</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/#source-files","title":"Source files","text":"<ul> <li>Source files for Dynamic Programming on GitHub</li> <li>Dynamic Programming Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-dynamic-programming/#references","title":"References","text":"<ul> <li>Introduction to Dynamic Programming 1</li> <li>Dynamic Programming</li> <li>How to solve a Dynamic Programming Problem ?</li> <li>Tabulation vs Memorization</li> <li>\u7528\u4e24\u79cd\u65b9\u6cd5\u6c42\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 LeetCode 300.Longest Increasing Subsequence</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/","title":"Algorithm - Knapsack Problems","text":""},{"location":"algorithm/algorithm-knapsack-problems/#knapsack-problem-1-capacity-only","title":"Knapsack Problem 1 - Capacity only","text":"<p>Given <code>n</code> items with size A[i] for i-th item, and an integer <code>m</code> denotes the capacity of a backpack. How full you can fill this backpack? Maximize the total size that the knapsack can be filled. Each item can be use 0 or 1 time.</p> <pre><code>Example 1:\n    Input:  [3,4,8,5], knapsack capacity=10\n    Output:  9\n\nExample 2:\n    Input:  [2,3,5,7], knapsack capacity=12\n    Output:  12\n</code></pre>"},{"location":"algorithm/algorithm-knapsack-problems/#solution-with-boolean-array","title":"Solution with Boolean Array","text":"<p>Define a two-dimensional boolean array.</p> <pre><code>public int knapsack11(int[] A, int m) {\n    boolean[][] dp = new boolean[A.length + 1][m + 1];\n    dp[0][0] = true;\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            if (j - A[i-1] &gt;= 0 &amp;&amp; dp[i-1][j - A[i-1]]) {\n                dp[i][j] = true;\n            } else {\n                dp[i][j] = dp[i - 1][j];\n            }\n        }\n    }\n\n    for (int i = m; i &gt;= 0; i--) {\n        if (dp[A.length][i]) {\n            return i;\n        }\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(n*m)</li> </ul> <p>Values of the dp array for input A=[3,4,8,5] and m=10. The answer is 9 and the selected items are 4 and 5.</p> Item\\Size 0 1 2 3 4 5 6 7 8 9 10 0 true false false false false false false false false false false 3 true false false true false false false false false false false 4 true false false true true false false true false false false 8 true false false true true false false true true false false 5 true false false true true true false true true true false <p>The above solution can be optimized with two one-dimensional arrays. Space complexity is reduced to O(m).</p> <pre><code>public int knapsack12(int[] A, int m) {\n    boolean[] dp = new boolean[m + 1];\n    boolean[] dp2 = new boolean[m + 1];\n    dp[0] = true;\n    dp2[0] = true;\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            if (j - A[i-1] &gt;= 0 &amp;&amp; dp2[j - A[i-1]]) {\n                dp[j] = true;\n            } else {\n                dp[j] = dp2[j];\n            }\n        }\n        for (int j = 0; j &lt;= m; j++) {\n            dp2[j] = dp[j];\n        }\n    }\n\n    for (int i = m; i &gt;= 0; i--) {\n        if (dp[i]) {\n            return i;\n        }\n    }\n\n    return 0;\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(2m)-&gt;O(m)</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#solution-with-integer-array","title":"Solution with Integer Array","text":"<p>Instead of using boolean array, we can use integer array as well.</p> <pre><code>public int knapsack13(int[] A, int m) {\n    // maximum size can be filled for the every capacity\n    int[][] dp = new int[A.length + 1][m + 1];\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j - A[i - 1] &gt;= 0) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - A[i - 1]] + A[i - 1]);\n            }\n        }\n    }\n\n    return dp[A.length][m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(n*m)</li> </ul> <p>Values of the dp array for input A=[3,4,8,5] and m=10. The answer is 9 and the selected items are 4 and 5.</p> Item\\Size 0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 3 3 3 3 3 3 3 4 0 0 0 3 4 4 4 7 7 7 7 8 0 0 0 3 4 4 4 7 8 8 8 5 0 0 0 3 4 5 5 7 8 9 9 <p>Let's try to optimize the above solution with one-dimensional array.</p> <pre><code>// incorrect\npublic int knapsack14(int[] A, int m) {\n    // maximum size can be filled for the every capacity\n    int[] dp = new int[m + 1];\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            if (j - A[i - 1] &gt;= 0) {\n                dp[j] = Math.max(dp[j], dp[j - A[i - 1]] + A[i - 1]);\n            }\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <p>This solution returns incorrect result 10. The problem is, for each item, it is picked up for not only once.</p> Item\\Size 0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 3 3 3 6 6 6 9 9 4 0 0 0 3 4 4 6 7 8 9 10 8 0 0 0 3 4 4 6 7 8 9 10 5 0 0 0 3 4 5 6 7 8 9 10 <p>To make it work, we have to iterate the knapsack size in reverse order, see below.</p> <pre><code>public int knapsack15(int[] A, int m) {\n    // maximum size can be filled for the every capacity\n    int[] dp = new int[m + 1];\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = m; j &gt;= 0; j--) {\n            if (j - A[i - 1] &gt;= 0) {\n                dp[j] = Math.max(dp[j], dp[j - A[i - 1]] + A[i - 1]);\n            }\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <p>Further more, we can improve the readability by setting <code>i</code> to 0 instead of 1 and moving check \"j - A[i - 1] &gt;= 0\" to the 'for' loop. The final solution as follows. Space complexity is reduced to O(m).</p> <pre><code>// set i = 0 instead of 1\n// move check \"j - A[i - 1] &gt;= 0\" to for loop\npublic int knapsack16(int[] A, int m) {\n    // maximum size can be filled for the every capacity\n    int[] dp = new int[m + 1];\n\n    for (int i = 0; i &lt; A.length; i++) {\n        for (int j = m; j &gt;= A[i]; j--) {\n            dp[j] = Math.max(dp[j], dp[j - A[i]] + A[i]);\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul> <p>Values of the dp array for each iteration(i-th) for input A=[3,4,8,5] and m=10. The answer is 9 and the selected items are 4 and 5.</p> i\\Size 0 1 2 3 4 5 6 7 8 9 10 0(3) 0 0 0 3 3 3 3 3 3 3 3 1(4) 0 0 0 3 4 4 4 7 7 7 7 2(8) 0 0 0 3 4 4 4 7 8 8 8 3(5) 0 0 0 3 4 5 5 7 8 9 9"},{"location":"algorithm/algorithm-knapsack-problems/#knapsack-problem-2-capacity-value","title":"Knapsack Problem 2 - Capacity + Value","text":"<p>There are <code>n</code> items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item and array <code>V</code> representing the value of each item. What's the maximum value can you put into the backpack? Maximize the total value. <code>Each item can be use 0 or 1 time.</code></p> <pre><code>Example 1:\n    Input:  A=[1, 1, 2, 2], V=[1, 3, 4, 5], knapsack capacity=4\n    Output:  9\n    Explanation: Select item 1(1),1(3),2(5) or 2(4),2(5).\nExample 2:\n    Input:  A=[3, 4, 8, 5], V=[1, 3, 7, 5], knapsack capacity=10\n    Output:  8\n    Explanation: Select item 4(3),5(5).\n</code></pre> <p>Solution:</p> <pre><code>public int knapsack21(int[] A, int[] V, int m) {\n    // Max value achieved by using the first i items and total size is exact j.\n    int[][] dp = new int[A.length + 1][m + 1];\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j - A[i - 1] &gt;= 0) {\n                dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - A[i - 1]] + V[i - 1]);\n            }\n        }\n    }\n\n    return dp[A.length][m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> <li>The above solution is almost same with the two-dimensional solution for the Knapsack Problem 1(Capacity Only). The only difference is dp[i][j] stores the value instead of the size.</li> </ul> <p>Values of the dp array for input A=[1,1,2,2], V=[1,3,4,5] and m=4. The answer is 9 and the selected items are 2(4) and 2(5).</p> Item\\size 0 1 2 3 4 0 0 0 0 0 0 1 0 1 1 1 1 1 0 3 4 4 4 2 0 3 4 7 8 2 0 3 5 8 9 <p>Values of the dp array for input A=[3,4,8,5], V=[1,3,7,5] and m=10. The answer is 8 and the selected items are 4(3) and 5(5).</p> Item\\Size 0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 1 1 1 1 1 1 1 1 4 0 0 0 1 3 3 3 4 4 4 4 8 0 0 0 1 3 3 3 4 7 7 7 5 0 0 0 1 3 5 5 5 7 8 8 <p>We can optimize the above solution with one-dimensional array.</p> <pre><code>public int knapsack22(int[] A, int[] V, int m) {\n    // maximum size can be filled for the every capacity\n    int[] dp = new int[m + 1];\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = m; j &gt;= 0; j--) {\n            if (j - A[i - 1] &gt;= 0) {\n                dp[j] = Math.max(dp[j], dp[j - A[i - 1]] + V[i - 1]);\n            }\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul> <p>Further more, we can improve the readability by setting <code>i</code> to 0 instead of 1 and moving check \"j - A[i - 1] &gt;= 0\" to the 'for' loop. The final solution as follows.</p> <pre><code>public int knapsack23(int[] A, int[] V, int m) {\n    // maximum size can be filled for the every capacity\n    int[] dp = new int[m + 1];\n\n    for (int i = 0; i &lt; A.length; i++) {\n        for (int j = m; j &gt;= A[i]; j--) {\n            dp[j] = Math.max(dp[j], dp[j - A[i]] + V[i]);\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#knapsack-problem-3-unlimited-inventory","title":"Knapsack Problem 3 - Unlimited Inventory","text":"<p>There are <code>n</code> items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item and array <code>V</code> representing the value of each item. What's the maximum value can you put into the backpack? Maximize the total value. <code>Each item has unlimited inventory(You can pick up one item for unlimited times).</code></p> <pre><code>Example 1:\n    Input:  A=[1, 1, 2, 2], V=[1, 3, 4, 5], knapsack capacity=4\n    Output:  12\n    Explanation: Select item 1(3) for 4 times.\nExample 2:\n    Input:  A=[3, 4, 8, 5], V=[1, 3, 7, 5], knapsack capacity=10\n    Output:  10\n    Explanation: Select item 5(5) for twice.\n</code></pre> <p>Solution:</p> <pre><code>public int knapsack31(int[] A, int[] V, int m) {\n    // maximum value can be filled for the every capacity\n    int[][] dp = new int[A.length + 1][m + 1];\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 1; j &lt;= m; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j - A[i - 1] &gt;= 0) {\n                dp[i][j] = Math.max(dp[i][j], dp[i][j - A[i - 1]] + V[i - 1]);\n            }\n        }\n    }\n\n    return dp[A.length][m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(n*m)</li> <li>The above solution is almost same with the solution for the Knapsack Problem 2. The only difference is how to calculate dp[i][j].</li> </ul> <pre><code>dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - A[i - 1]] + V[i - 1]); // problem 2\ndp[i][j] = Math.max(dp[i][j], dp[i][j - A[i - 1]] + V[i - 1]);     // problem 3\n</code></pre> <p>Values of the dp array for input A=[1,1,2,2], V=[1,3,4,5] and m=4. The answer is 12 and the selected items are 1(3) for 4 times.</p> Item\\size 0 1 2 3 4 0 0 0 0 0 0 1 0 1 2 3 4 1 0 3 6 9 12 2 0 3 6 9 12 2 0 3 6 9 12 <p>Values of the dp array for input A=[3,4,8,5], V=[1,3,7,5] and m=10. The answer is 10 and the selected items are 5(5) for twice.</p> Item\\Size 0 1 2 3 4 5 6 7 8 9 10 0 0 0 0 0 0 0 0 0 0 0 0 3 0 0 0 1 1 1 2 2 2 3 3 4 0 0 0 1 3 3 3 4 6 6 6 8 0 0 0 1 3 3 3 4 7 7 7 5 0 0 0 1 3 5 5 5 7 8 10 <p>We can optimize the above solution with one-dimensional array.</p> <pre><code>public int knapsack32(int[] A, int[] V, int m) {\n    // maximum value can be filled for the every capacity\n    int[] dp = new int[m + 1];\n\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            if (j - A[i - 1] &gt;= 0) {\n                dp[j] = Math.max(dp[j], dp[j - A[i - 1]] + V[i - 1]);\n            }\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul> <p>Further more, we can improve the readability by setting <code>i</code> to 0 instead of 1 and moving check \"j - A[i - 1] &gt;= 0\" to the 'for' loop. The final solution as follows.</p> <pre><code>public int knapsack33(int[] A, int[] V, int m) {\n    // maximum value can be filled for the every capacity\n    int[] dp = new int[m + 1];\n\n    for (int i = 0; i &lt; A.length; i++) {\n        for (int j = A[i]; j &lt;= m; j++) {\n            dp[j] = Math.max(dp[j], dp[j - A[i]] + V[i]);\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#knapsack-problem-4-number-of-waysunlimited-times","title":"Knapsack Problem 4 - Number of Ways(unlimited times)","text":"<p>There are <code>n</code> unique items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item. Find the <code>number of ways</code> to fill the backpack. Each item may be chosen <code>unlimited</code> number of times.</p> <pre><code>Example 1:\n    Input:  A=[2, 3, 6, 7], m=7\n    Output:  2\n    Explanation: Solution sets are: [7] and [2, 2, 3].\nExample 2:\n    Input:  A=[2, 3, 4, 5], m=7\n    Output:  3\n    Explanation: Solution sets are: [2, 5], [3, 4] and [2, 2, 3].\n</code></pre> <p>Solution:</p> <pre><code>public int knapsack41(int[] A, int m) {\n    int[][] dp = new int[A.length + 1][m + 1];\n\n    dp[0][0] = 1;\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            int k = 0;\n            while (j - A[i-1]*k &gt;= 0) {\n                dp[i][j] += dp[i-1][j - A[i-1]*k];\n                k+=1;\n            }\n        }\n    }\n    return dp[A.length][m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m^2)</li> <li>Space Complexity: O(n*m)</li> </ul> <p>Values of the dp array for input A=[2,3,6,7] and m=7. The answer is 2.</p> Item\\Size 0 1 2 3 4 5 6 7 0 1 0 0 0 0 0 0 0 2 1 0 1 0 1 0 1 0 3 1 0 1 1 1 1 2 1 6 1 0 1 1 1 1 3 1 7 1 0 1 1 1 1 3 2 <p>We can optimize the above solution with one-dimensional array.</p> <pre><code>public int knapsack42(int[] A, int m) {\n    // number of ways to full fill every capacity\n    int[] dp = new int[m + 1];\n\n    dp[0] = 1;\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            if (j - A[i - 1] &gt;= 0) {\n                dp[j] += dp[j - A[i - 1]];\n            }\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul> <p>Further more, we can improve the readability by setting <code>i</code> to 0 instead of 1 and moving check \"j - A[i - 1] &gt;= 0\" to the 'for' loop. The final solution as follows.</p> <pre><code>public int knapsack43(int[] A, int m) {\n    // number of ways to full fill every capacity\n    int[] dp = new int[m + 1];\n    dp[0] = 1;\n    for (int i = 0; i &lt; A.length; i++) {\n        for (int j = A[i]; j &lt;= m; j++) {\n            dp[j] += dp[j - A[i]];\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#knapsack-problem-5-number-of-ways-only-once","title":"Knapsack Problem 5 - Number of Ways (only once)","text":"<p>There are <code>n</code> unique items and a backpack with size <code>m</code>. Given array <code>A</code> representing the size of each item. Find the <code>number of ways</code> to fill the backpack. Each item can only be chosen <code>once</code>.</p> <pre><code>Example 1:\n    Input:  A=[2, 3, 6, 7], m=7\n    Output:  1\n    Explanation: Solution set is: [7].\nExample 2:\n    Input:  A=[1, 2, 3, 3, 7], m=7\n    Output:  2\n    Explanation: Solution sets are: [1, 3, 3], [7].\n</code></pre> <p>Solution:</p> <pre><code>public int knapsack51(int[] A, int m) {\n    // number of ways to full fill every capacity\n    int[][] dp = new int[A.length + 1][m + 1];\n\n    dp[0][0] = 1;\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = 0; j &lt;= m; j++) {\n            dp[i][j] = dp[i - 1][j];\n            if (j - A[i - 1] &gt;= 0) {\n                dp[i][j] += dp[i - 1][j - A[i - 1]];\n            }\n        }\n    }\n    return dp[A.length][m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(n*m)</li> </ul> <p>Values of the dp array for input A=[2,3,6,7] and m=7. The answer is 1.</p> Item\\Size 0 1 2 3 4 5 6 7 0 1 0 0 0 0 0 0 0 2 1 0 1 0 0 0 0 0 3 1 0 1 1 0 1 0 0 6 1 0 1 1 0 1 1 0 7 1 0 1 1 0 1 1 1 <p>Values of the dp array for input A=[1,2,3,3,7] and m=7. The answer is 2.</p> Item\\Size 0 1 2 3 4 5 6 7 0 1 0 0 0 0 0 0 0 1 1 1 0 0 0 0 0 0 2 1 1 1 1 0 0 0 0 3 1 1 1 2 1 1 1 0 3 1 1 1 3 2 2 3 1 7 1 1 1 3 2 2 3 2 <p>We can optimize the above solution with one-dimensional array.</p> <pre><code>public int knapsack52(int[] A, int m) {\n    // number of ways to full fill every capacity\n    int[] dp = new int[m + 1];\n    dp[0] = 1;\n    for (int i = 1; i &lt;= A.length; i++) {\n        for (int j = m; j &gt;= 0; j--) {\n            if (j - A[i - 1] &gt;= 0) {\n                dp[j] += dp[j - A[i - 1]];\n            }\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul> <p>Further more, we can improve the readability by setting <code>i</code> to 0 instead of 1 and moving check \"j - A[i - 1] &gt;= 0\" to the 'for' loop. The final solution as follows.</p> <pre><code>public int knapsack53(int[] A, int m) {\n    // number of ways to full fill every capacity\n    int[] dp = new int[m + 1];\n    dp[0] = 1;\n    for (int i = 0; i &lt; A.length; i++) {\n        for (int j = m; j &gt;= A[i]; j--) {\n            dp[j] += dp[j - A[i]];\n        }\n    }\n\n    return dp[m];\n}\n</code></pre> <ul> <li>Time Complexity: O(n*m)</li> <li>Space Complexity: O(m)</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#summary-of-knapsack-problems","title":"Summary of Knapsack Problems","text":"<ul> <li>Generally, we need to create a two dimensional array. The first dimension represents the elements and the second represents the size of knapsack.</li> <li>For each dimension of the DP array, we need one more larger size(<code>n+1</code> and <code>m+1</code>), because we need to handle the special cases that no items fills the knapsack and items fills zero-size knapsack.</li> <li>The result is in the last row and last column(Need to search from end).</li> <li>Space complexity can be optimized to O(m).</li> <li>When using one-dimensional array, if item can be selected for unlimited times, iterate from beginning.</li> <li>When using one-dimensional array, if item can only be selected for once, iterate from end.</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#related-problems","title":"Related Problems","text":""},{"location":"algorithm/algorithm-knapsack-problems/#coin-change","title":"Coin Change","text":"<p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p> <pre><code>Example 1:\n\nInput: coins = [1, 2, 5], amount = 11\nOutput: 3\nExplanation: 11 = 5 + 5 + 1\nExample 2:\n\nInput: coins = [2], amount = 3\nOutput: -1\n</code></pre> <pre><code>public int coinChange(int[] coins, int amount) {\n    if (coins == null || coins.length == 0) {\n        return -1;\n    }\n\n    int[] dp = new int[amount + 1];\n    Arrays.fill(dp, Integer.MAX_VALUE);\n    dp[0] = 0;\n    for (int i = 0; i &lt; coins.length; i++) {\n        for (int j = coins[i]; j &lt;= amount; j++) {\n            if (dp[j - coins[i]] != Integer.MAX_VALUE) {\n                dp[j] = Math.min(dp[j], dp[j - coins[i]] + 1);\n            }\n        }\n    }\n\n    return dp[amount] == Integer.MAX_VALUE ? -1: dp[amount];\n}\n</code></pre>"},{"location":"algorithm/algorithm-knapsack-problems/#classic-problems","title":"Classic Problems","text":"<ul> <li>LintCode 92 - Backpack</li> <li>LintCode 91 - Minimum Adjustment Cost</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#source-files","title":"Source files","text":"<ul> <li>Source files for Knapsack Problems on GitHub</li> <li>Dynamic Programming Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-knapsack-problems/#references","title":"References","text":"<ul> <li>0-1 Knapsack Problem 0-1\u80cc\u5305\u95ee\u9898</li> <li>\u82b1\u82b1\u9171 0-1 Knapsack Problem 01\u80cc\u5305\u95ee\u9898 - \u5237\u9898\u627e\u5de5\u4f5c SP10</li> <li>Backpack solution</li> <li>Backpack II solution</li> <li>FLAG Offer\u4e4b\u8def\u4e13\u9898-\u80cc\u5305\u95ee\u9898 01</li> </ul>"},{"location":"algorithm/algorithm-map-reduce/","title":"Algorithm - Map Reduce","text":"<p>Implement Map Reduce</p>"},{"location":"algorithm/algorithm-map-reduce/#what-is-mapreduce","title":"What is MapReduce?","text":"<p><code>MapReduce</code> is a processing technique and a program model for distributed computing based on java. The major advantage of MapReduce is that it is easy to scale data processing over multiple computing nodes. The MapReduce algorithm contains two important tasks, namely <code>Map</code> and <code>Reduce</code>.</p> <ul> <li>Map takes a set of data and converts it into another set of data, where individual elements are broken down into tuples (key/value pairs).</li> <li>Secondly, reduce task, which takes the output from a map as an input and combines those data tuples into a smaller set of tuples. As the sequence of the name MapReduce implies, the reduce task is always performed after the map job.</li> </ul> <p>Below diagram shows the process of using MapReduce to count the number of words from multiple sources. </p>"},{"location":"algorithm/algorithm-map-reduce/#implementation-of-mapreduce","title":"Implementation of MapReduce","text":"<pre><code>public class TopKFrequentWords {\n    //HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;();\n    public static class Map {\n        public void map(String aa, Document value,\n                        OutputCollector&lt;String, Integer&gt; output) {\n            // Write your code here\n            // Output the results into output buffer.\n            // Ps. output.collect(String key, int value);\n            String content = value.content.trim();\n            String[] words = content.split(\" \");\n            for (int i = 0; i &lt; words.length; i++) {\n                if (!words[i].isEmpty()) {\n                    output.collect(words[i], 1);\n                }\n            }\n        }\n    }\n\n    public static class Reduce {\n        LinkedHashMap&lt;String, Integer&gt; countMap = new LinkedHashMap&lt;String, Integer&gt;();\n        int top = 0;\n\n        public void setup(int k) {\n            // initialize your data structure here\n            top = k;\n        }   \n\n        public void reduce(String key, Iterator&lt;Integer&gt; values) {\n            // Write your code here\n            int sum = 0;\n            while (values.hasNext()) {\n                sum += values.next();\n            }\n            countMap.put(key, sum);\n        }\n\n        public void cleanup(OutputCollector&lt;String, Integer&gt; output) {\n            HashMap&lt;String, Integer&gt; sortedMap = sortByComparator(countMap);\n            int i = 0;\n            for (String key : sortedMap.keySet()) {\n                if (i &gt;= top) {\n                    break;\n                }\n                output.collect(key, sortedMap.get(key));\n                i++;\n            }\n            /*int cnt = 0;\n            top = Math.min(top, countMap.size());\n            Integer[] counts = countMap.values().toArray(new Integer[0]);\n            Arrays.sort(counts);\n\n            for (int i = counts.length - 1; i &gt;= 0; i--) {                \n                for (String key : countMap.keySet()) {\n                    if (countMap.get(key) == counts[i]) {\n                        output.collect(key, counts[i]);\n                        cnt++;\n                        if (cnt &gt;= top) {\n                            return;\n                        }\n                    }\n                }\n            }*/\n        }\n\n        private HashMap&lt;String, Integer&gt; sortByComparator(HashMap&lt;String, Integer&gt; unsortMap)\n        {\n\n            List&lt;Entry&lt;String, Integer&gt;&gt; list = new LinkedList&lt;Entry&lt;String, Integer&gt;&gt;(unsortMap.entrySet());\n\n            // Sorting the list based on values\n            Collections.sort(list, new Comparator&lt;Entry&lt;String, Integer&gt;&gt;()\n            {\n                public int compare(Entry&lt;String, Integer&gt; o1,\n                        Entry&lt;String, Integer&gt; o2)\n                {\n                    int val1 = o1.getValue();\n                    int val2 = o2.getValue();\n                    String key1 = o1.getKey();\n                    String key2 = o2.getKey();\n                    if (val1 == val2) {\n                        return key1.compareTo(key2);\n                    } else {\n                        return val2 - val1;\n                    }\n                }\n            });\n\n            // Maintaining insertion order with the help of LinkedList\n            HashMap&lt;String, Integer&gt; sortedMap = new LinkedHashMap&lt;String, Integer&gt;();\n            for (Entry&lt;String, Integer&gt; entry : list)\n            {\n                sortedMap.put(entry.getKey(), entry.getValue());\n            }\n\n            return sortedMap;\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-map-reduce/#source-files","title":"Source files","text":"<ul> <li>Source files for Map Reduce on GitHub</li> </ul>"},{"location":"algorithm/algorithm-map-reduce/#references","title":"References","text":"<ul> <li>Hadoop - MapReduce</li> </ul>"},{"location":"algorithm/algorithm-math/","title":"Algorithm - Math","text":"<p>Common approaches for solving string and array problems</p>"},{"location":"algorithm/algorithm-math/#two-city-scheduling","title":"Two City Scheduling","text":""},{"location":"algorithm/algorithm-math/#question","title":"Question","text":"<p>A company is planning to interview 2n people. Given the array costs where costs[i] = [aCosti, bCosti], the cost of flying the ith person to city a is aCosti, and the cost of flying the ith person to city b is bCosti.</p> <p>Return the minimum cost to fly every person to a city such that exactly n people arrive in each city.</p> <p>Example 1:</p> <pre><code>Input: costs = [[10,20],[30,200],[400,50],[30,20]]\nOutput: 110\nExplanation:\nThe first person goes to city A for a cost of 10.\nThe second person goes to city A for a cost of 30.\nThe third person goes to city B for a cost of 50.\nThe fourth person goes to city B for a cost of 20.\n\nThe total minimum cost is 10 + 30 + 50 + 20 = 110 to have half the people interviewing in each city.\n</code></pre> <p>Example 2:</p> <pre><code>Input: costs = [[259,770],[448,54],[926,667],[184,139],[840,118],[577,469]]\nOutput: 1859\n</code></pre> <p>Example 3:</p> <pre><code>Input: costs = [[515,563],[451,713],[537,709],[343,819],[855,779],[457,60],[650,359],[631,42]]\nOutput: 3086\n</code></pre> <p>Constraints:</p> <ul> <li>2n == costs.length</li> <li>2 &lt;= costs.length &lt;= 100</li> <li>costs.length is even.</li> <li>1 &lt;= aCosti, bCosti &lt;= 1000</li> </ul>"},{"location":"algorithm/algorithm-math/#solution-1","title":"Solution 1","text":"<pre><code>public int twoCitySchedCost(int[][] costs) {\n    int n = costs.length;\n    List&lt;int[]&gt; list1 = new ArrayList&lt;&gt;();\n    List&lt;int[]&gt; list2 = new ArrayList&lt;&gt;();\n    for (int[] cost : costs) {\n        if (cost[0] &lt; cost[1]) {\n            list1.add(cost);\n        } else {\n            list2.add(cost);\n        }\n    }\n\n    int sum = 0;\n    if (list1.size() &lt; list2.size()) {\n        Collections.sort(list2, (a, b) -&gt; (a[0] - a[1]) - (b[0] - b[1]));\n\n        for (int[] cost : list1) {\n            sum += cost[0];\n        }\n        int i = 0;\n        for (int[] cost : list2) {\n            if (i &lt; n / 2 - list1.size()) {\n                sum += cost[0];\n            } else {\n                sum += cost[1];\n            }\n            i++;\n        }\n    } else if (list1.size() &gt; list2.size()) {\n        Collections.sort(list1, (a, b) -&gt; (a[1] - a[0]) - (b[1] - b[0]));\n\n        for (int[] cost : list2) {\n            sum += cost[1];\n        }\n        int i = 0;\n        for (int[] cost : list1) {\n            if (i &lt; n / 2 - list2.size()) {\n                sum += cost[1];\n            } else {\n                sum += cost[0];\n            }\n            i++;\n        }\n    } else {\n        for (int[] cost : list1) {\n            sum += cost[0];\n        }\n        for (int[] cost : list2) {\n            sum += cost[1];\n        }\n    }\n\n    return sum;\n}\n</code></pre>"},{"location":"algorithm/algorithm-math/#solution-2","title":"Solution 2","text":"<p>Suppose we have two city costs [a, b] and [c, d], if we select <code>a</code> to make the cost minimal, then a + d &lt; b + c =&gt; a - b &lt; c - d. So we can sort the cost list by its difference, then pick up the first one for left half of the array and pick up the second one for the right half of the array.</p> <pre><code>public int twoCitySchedCost(int[][] costs) {\n    Arrays.sort(costs, (a, b) -&gt; {\n       return (a[0]-a[1]) - (b[0]-b[1]);\n    });\n\n    int cost = 0;\n    for (int i = 0; i &lt; costs.length; i++) {\n        if (i &lt; costs.length / 2) {\n            cost += costs[i][0];\n        } else {\n            cost += costs[i][1];\n        }\n    }\n\n    return cost;\n}\n</code></pre>"},{"location":"algorithm/algorithm-math/#references","title":"References","text":"<ul> <li>1029. Two City Scheduling</li> <li>1895. Arrange interview city</li> </ul>"},{"location":"algorithm/algorithm-matrix-dp/","title":"Algorithm - Matrix DP","text":"<p>Minimum Path Sum</p> <ul> <li>Follow up: print the path?</li> </ul>"},{"location":"algorithm/algorithm-matrix-dp/#unique-paths","title":"Unique Paths","text":""},{"location":"algorithm/algorithm-matrix-dp/#problem-description","title":"Problem Description","text":"<p>A robot is located at the top-left corner of a <code>m x n</code> grid (marked 'Start' in the diagram below). The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below). How many possible unique paths are there?  </p>"},{"location":"algorithm/algorithm-matrix-dp/#solution-with-matrixtwo-dimensional-array","title":"Solution with Matrix(Two-dimensional array)","text":"<pre><code>// time: O(m*n), space: O(m*n)\npublic int uniquePathMatrix(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[][] dp = new int[m][n];\n    // Initialization\n    for (int i = 0; i &lt; m; i++) {\n        dp[i][0] = 1;\n    }\n    for (int j = 0; j &lt; n; j++) {\n        dp[0][j] = 1;\n    }\n    // Calculate dp[i][j]\n    for (int i = 1; i &lt; m; i++) {\n        for (int j = 1; j &lt; n; j++) {\n            dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n\n// time: O(m*n), space: O(m*n), without separated initialization\npublic int uniquePathMatrix2(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[][] dp = new int[m][n];\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (i == 0 || j == 0) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = dp[i][j - 1] + dp[i - 1][j];\n            }\n        }\n    }\n\n    return dp[m - 1][n - 1];\n}\n</code></pre> <ul> <li>Time complexity: $O(m*n)$</li> <li>Space complexity: $O(m*n)$</li> </ul>"},{"location":"algorithm/algorithm-matrix-dp/#solution-with-one-dimensional-array","title":"Solution with One-dimensional Array","text":"<p>Use one-dimensional array instead of the matrix. Same time complexity, but space is reduced to $O(n)$.</p> <pre><code>// time: O(m*n), space: O(n)\npublic int uniquePathArray(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[] dp = new int[n];\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (j == 0) {\n                dp[j] = 1;\n            } else {\n                dp[j] = dp[j] + dp[j - 1];\n            }\n        }\n    }\n\n    return dp[n - 1];\n}\n\n// time: O(m*n), space: O(n), without checking the first column\npublic int uniquePath(int m, int n) {\n    if (m &lt;= 0 || n &lt;= 0) {\n        return 0;\n    }\n\n    int[] dp = new int[n];\n    dp[0] = 1;\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (j &gt; 0) {\n                dp[j] = dp[j] + dp[j - 1];\n            }\n        }\n    }\n\n    return dp[n - 1];\n}\n</code></pre> <ul> <li>Time complexity: $O(m*n)$</li> <li>Space complexity: $O(n)$</li> </ul>"},{"location":"algorithm/algorithm-matrix-dp/#define-matrix-with-larger-size","title":"Define Matrix with Larger Size","text":"<p>When to define a dp matrix with <code>m+1</code> and <code>n+1</code>? see question LeetCode 221 - Maximal Square.</p>"},{"location":"algorithm/algorithm-matrix-dp/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 62 - Unique Paths</li> <li>LeetCode 64 - Minimum Path Sum</li> <li>LeetCode 221 - Maximal Square</li> </ul>"},{"location":"algorithm/algorithm-matrix-dp/#source-files","title":"Source files","text":"<ul> <li>Source files for Dynamic Programming on GitHub</li> <li>Dynamic Programming Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-matrix-dp/#references","title":"References","text":"<ul> <li>Introduction to Dynamic Programming 1</li> <li>Dynamic Programming</li> <li>How to solve a Dynamic Programming Problem ?</li> <li>Tabulation vs Memorization</li> <li>\u7528\u4e24\u79cd\u65b9\u6cd5\u6c42\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 LeetCode 300.Longest Increasing Subsequence</li> </ul>"},{"location":"algorithm/algorithm-minimax-algorithm/","title":"Algorithm - Minimax Algorithm","text":"<p>Implement Minimax algorithm.</p>"},{"location":"algorithm/algorithm-minimax-algorithm/#problem-predict-the-winner","title":"Problem - Predict the Winner","text":""},{"location":"algorithm/algorithm-minimax-algorithm/#problem-description","title":"Problem Description","text":"<p>Given an array of scores that are non-negative integers. Player 1 picks one of the numbers from either end of the array followed by the player 2 and then player 1 and so on. Each time a player picks a number, that number will not be available for the next player. This continues until all the scores have been chosen. The player with the maximum score wins.</p> <p>Given an array of scores, predict whether player 1 is the winner. You can assume each player plays to maximize his score.</p> <pre><code>Example 1:\nInput: [1, 5, 2]\nOutput: False\nExplanation: Initially, player 1 can choose between 1 and 2. If he chooses 2 (or 1), then player 2 can choose\nfrom 1 (or 2) and 5. If player 2 chooses 5, then player 1 will be left with 1 (or 2). So, final score of\nplayer 1 is 1 + 2 = 3, and player 2 is 5. Hence, player 1 will never be the winner and you need to return False.\n\nExample 2:\nInput: [1, 5, 233, 7]\nOutput: True\nExplanation: Player 1 first chooses 1. Then player 2 have to choose between 5 and 7. No matter which number\nplayer 2 choose, player 1 can choose 233. Finally, player 1 has more score (234) than player 2 (12), so\nyou need to return True representing player1 can win.\n</code></pre>"},{"location":"algorithm/algorithm-minimax-algorithm/#diagram","title":"Diagram","text":"<p>List all possible results</p>"},{"location":"algorithm/algorithm-minimax-algorithm/#recursion-solution","title":"Recursion Solution","text":"<pre><code>// recursion, O(2^n)\npublic boolean PredictTheWinner(int[] nums) {\n    if (nums.length == 1) {\n        return true;\n    }\n\n    return helper(nums, 0, nums.length - 1) &gt;= 0;\n}\n\n// maximum diff score(my_score - op_score) can be obtained\nprivate int helper(int[] nums, int left, int right) {\n    if (l == r) {\n        return nums[l];\n    }\n\n    return Math.max(\n            nums[left] - helper(nums, left + 1, right),\n            nums[right] - helper(nums, left, right - 1));\n}\n</code></pre>"},{"location":"algorithm/algorithm-minimax-algorithm/#references","title":"References","text":"<ul> <li>Leetcode - 843. Guess the Word</li> <li>What is the Minimax Algorithm? at Youtube</li> </ul>"},{"location":"algorithm/algorithm-pre-sum/","title":"Algorithm - Pre Sum","text":"<p>Use Presum for multiple queries.</p>"},{"location":"algorithm/algorithm-pre-sum/#range-sum-query-immutable","title":"Range Sum Query - Immutable","text":"<pre><code>int[] preSum;\npublic NumArray(int[] nums) {\n    if (nums == null || nums.length == 0) {\n        return;\n    }\n    preSum = new int[nums.length];\n    preSum[0] = nums[0];\n    for (int i = 1; i &lt; nums.length; i++) {\n        preSum[i] = preSum[i - 1] + nums[i];\n    }\n}\n\npublic int sumRange(int i, int j) {\n    if (i == 0) {\n        return preSum[j];\n    } else {\n        return preSum[j] - preSum[i - 1];\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-pre-sum/#source-files","title":"Source files","text":""},{"location":"algorithm/algorithm-pre-sum/#references","title":"References","text":""},{"location":"algorithm/algorithm-random/","title":"Random","text":"<p>Implement solutions for Random questions</p>"},{"location":"algorithm/algorithm-random/#random-point-in-non-overlapping-rectangles","title":"Random Point in Non-overlapping Rectangles","text":"<p>Each point should be picked randomly.</p> <p>Implementation: https://leetcode.com/problems/random-point-in-non-overlapping-rectangles/discuss/805333/CDF-of-Number-of-Integer-Point-in-Rectangles-using-TreeMap</p>"},{"location":"algorithm/algorithm-random/#references","title":"References","text":"<ul> <li>Random Point in Non-overlapping Rectangles</li> </ul>"},{"location":"algorithm/algorithm-sequence-dp/","title":"Algorithm - Sequence DP","text":"<p>Maximum Subarray</p>"},{"location":"algorithm/algorithm-sequence-dp/#fibonacci-numbers","title":"Fibonacci Numbers","text":""},{"location":"algorithm/algorithm-sequence-dp/#problem-description","title":"Problem Description","text":"<p>Fibonacci Numbers are 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, ... Now, given an integer N(N &gt;= 0), return the Nth Fibonacci number.</p>"},{"location":"algorithm/algorithm-sequence-dp/#recursive-solution","title":"Recursive Solution","text":"<pre><code>// recursive implementation\npublic int fibonacci(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n\n    return fibonacci(n - 1) + fibonacci(n - 2);\n}\n</code></pre> <ul> <li>Time complexity: $O(2^n)$</li> <li>Space complexity: $O(1)$</li> </ul>"},{"location":"algorithm/algorithm-sequence-dp/#dp-solution","title":"DP Solution","text":"<pre><code>// DP\npublic int fibonacci(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n\n    int[] dp = new int[n + 1];\n    dp[0] = 0;\n    dp[1] = 1;\n    for (int i = 2; i &lt;= n; i++)  {\n        dp[i] = dp[i - 1] + dp[i - 2];\n    }\n\n    return dp[n];\n}\n</code></pre> <ul> <li>Time complexity: $O(n)$</li> <li>Space complexity: $O(n)$</li> </ul>"},{"location":"algorithm/algorithm-sequence-dp/#solution-with-constant-space","title":"Solution with Constant Space","text":"<pre><code>// constant space\npublic int fibonacci(int n) {\n    if (n == 0) {\n        return 0;\n    }\n    if (n == 1) {\n        return 1;\n    }\n\n    int first = 0;\n    int second = 1;\n    int third = 0;\n\n    for (int i = 2; i &lt;= n; i++) {\n        third = first + second;\n        first = second;\n        second = third;\n    }\n\n    return third;\n}\n</code></pre> <ul> <li>Time complexity: $O(n)$</li> <li>Space complexity: $O(1)$</li> </ul>"},{"location":"algorithm/algorithm-sequence-dp/#longest-increasing-subsequence","title":"Longest Increasing Subsequence","text":""},{"location":"algorithm/algorithm-sequence-dp/#problem-description_1","title":"Problem Description","text":"<p>Given a sequence of integers, find the longest increasing subsequence (LIS). Your code should return the <code>length</code> of the LIS.</p> <pre><code>Example 1:\n    Input:  [5,4,1,2,3]\n    Output:  3\n    Explanation: LIS is [1,2,3].\nExample 2:\n    Input: [4,2,4,5,3,7]\n    Output:  4\n    Explanation: LIS is [2,4,5,7]\n</code></pre>"},{"location":"algorithm/algorithm-sequence-dp/#dp-solutionn2","title":"DP Solution(n^2)","text":"<pre><code>// O(n^2)\npublic int longestIncreasingSubsequence(int[] nums) {\n    if (nums == null || nums.length == 0) {\n        return 0;\n    }\n\n    // dp[i], the longest length of LIS which ends at index i.\n    int[] dp = new int[nums.length];\n    int max = 0;\n    for (int i = 0; i &lt; nums.length; i++) {\n        dp[i] = 1;\n        for (int j = 0; j &lt; i; j++) { // check 0~i\n            if (nums[j] &lt; nums[i]) {\n                dp[i] = Math.max(dp[i], dp[j] + 1);\n            }\n        }\n        max = Math.max(max, dp[i]);\n    }\n\n    return max;\n}\n</code></pre> <ul> <li>Time Complexity: $O(n^2)$</li> <li>Space Complexity: $O(n)$</li> </ul> <p>Values of the dp array for input A=[4,2,4,5,3,7]. The answer is 4 and the longest increasing subsequence is [2,4,5,7].</p> A[i]\\dp[i] 0 1 2 3 4 5 4 1 0 0 0 0 0 2 1 <code>1</code> 0 0 0 0 4 1 1 <code>2</code> 0 0 0 5 1 1 2 <code>3</code> 0 0 3 1 1 2 3 2 0 7 1 1 2 3 2 <code>4</code>"},{"location":"algorithm/algorithm-sequence-dp/#binary-search-solutionnlogn","title":"Binary Search Solution(nlog(n))","text":"<p>Maintain a monotonic increasing array.</p> <pre><code>// O(nlog(n))\n// https://www.youtube.com/watch?v=5rfZ4WnNKBk\npublic int longestIncreasingSubsequence3(int[] nums) {\n    if (nums == null || nums.length == 0) {\n        return 0;\n    }\n\n    int[] arr = new int[nums.length]; // increasing array\n    // 10,9,2,5,3,7,101,18 -&gt; 2,3,7,18\n    int len = 0;\n    for (int i = 0; i &lt; nums.length; i++) {\n        int index = Arrays.binarySearch(arr, 0, len, nums[i]);\n        if (index &lt; 0) {\n            index = -(index + 1);\n        }\n\n        arr[index] = nums[i];\n        if (index == len) {\n            len++;\n        }\n    }\n\n    return len;\n}\n</code></pre> <ul> <li>Time Complexity: $O(nlog(n))$</li> <li>Space Complexity: $O(n)$</li> </ul> <p>Values of the dp array for input A=[10,9,2,5,3,7,101,18]. The answer is 4 and the longest increasing subsequence are [2,5,7,101], [2,5,7,18], [2,3,7,101] or [2,3,7,18].</p> A[i]\\arr[i] 0 1 2 3 4 5 6 7 10 10 0 0 0 0 0 0 0 9 9 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 5 2 5 0 0 0 0 0 0 3 2 3 0 0 0 0 0 0 7 2 3 7 0 0 0 0 0 101 2 3 7 101 0 0 0 0 18 2 3 7 18 0 0 0 0 <p>Here, the final array contains the correct LIS . But it is not guaranteed this is always the case. Take another input as example, A=[10,9,2,5,7,3,101,18]. The only difference with the previous input is that 7 and 3 are swapped. The answer is still 4. But the longest increasing subsequence are [2,5,7,101] and [2,5,7,18] only. [2,3,7,101] and [2,3,7,18] are not valid LIS any more, but we have the same final array [2,3,7,18,0,0,0,0] as the previous exmaple.</p> A[i]\\arr[i] 0 1 2 3 4 5 6 7 10 10 0 0 0 0 0 0 0 9 9 0 0 0 0 0 0 0 2 2 0 0 0 0 0 0 0 5 2 5 0 0 0 0 0 0 7 2 5 7 0 0 0 0 0 3 2 3 7 0 0 0 0 0 101 2 3 7 101 0 0 0 0 18 2 3 7 18 0 0 0 0"},{"location":"algorithm/algorithm-sequence-dp/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 70 - Climbing Stairs</li> <li>LeetCode 55 - Jump Game</li> <li>LeetCode 45 - Jump Game II</li> <li>LeetCode 132 - Palindrome Partitioning II</li> <li>LeetCode 139 - Word Break</li> <li>LeetCode 140 - Word Break II</li> <li>LeetCode 674 - Longest Continuous Increasing Subsequence</li> <li>LeetCode 300 - Longest Increasing Subsequence</li> <li>LeetCode 198 - House Robber</li> <li>LeetCode 213 - House Robber II</li> </ul>"},{"location":"algorithm/algorithm-sequence-dp/#game-min-max","title":"Game, Min-Max","text":"<ul> <li>LeetCode 486 - Predict the Winner</li> <li>LeetCode 877 - Stone Game</li> </ul>"},{"location":"algorithm/algorithm-sequence-dp/#source-files","title":"Source files","text":"<ul> <li>Source files for Dynamic Programming on GitHub</li> <li>Dynamic Programming Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-sequence-dp/#references","title":"References","text":"<ul> <li>Introduction to Dynamic Programming 1</li> <li>Dynamic Programming</li> <li>How to solve a Dynamic Programming Problem ?</li> <li>Tabulation vs Memorization</li> <li>\u7528\u4e24\u79cd\u65b9\u6cd5\u6c42\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 LeetCode 300.Longest Increasing Subsequence</li> </ul>"},{"location":"algorithm/algorithm-sorting/","title":"Algorithm - Sorting","text":"<p>Classic sorting algorithms.</p>"},{"location":"algorithm/algorithm-sorting/#common-sorting-algorithms","title":"Common Sorting Algorithms","text":"Name Average Best Case Worst Case Space Complexity Stable Bubble Sort $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ Yes Insertion Sort $O(n^2)$ $O(n)$ $O(n^2)$ $O(1)$ Yes Shell Sort Depends $O(n\\log{}n)$ Depends $O(1)$ No Selection Sort $O(n^2)$ $O(n^2)$ $O(n^2)$ $O(1)$ No Heap Sort $O(n\\log{}n)$ $O(n\\log{}n)$ $O(n\\log{}n)$ $O(1)$ No Merge Sort $O(n\\log{}n)$ $O(n\\log{}n)$ $O(n\\log{}n)$ $O(n)$ Yes Quick Sort $O(n\\log{}n)$ $O(n\\log{}n)$ $O(n^2)$ $O(\\log{}n)$ No Bucket Sort -- $O(n+r)$ $O(n+r)$ $O(n+r)$ Yes Counting Sort -- $O(n+r)$ $O(n+r)$ $O(n+r)$ Yes Radix Sort -- $O(nk/d)$ $O(nk/d)$ $O(n+2^d)$ Yes"},{"location":"algorithm/algorithm-sorting/#bubble-sort","title":"Bubble Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-bubble-sort-works","title":"How Bubble Sort Works?","text":"<p>Each time, start taking the last element and compare it with the previous one, swap them if the latter is smaller than the former. By doing this repetitively, bubble up the smallest element and append it to the sorted head list.</p> <p></p>"},{"location":"algorithm/algorithm-sorting/#implementation-of-bubble-sort","title":"Implementation of Bubble Sort","text":"<pre><code>public void bubbleSort(int[] nums) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n\n    for(int i = 0; i &lt; nums.length; i++) {\n        for (int j = nums.length - 1; j &gt; i; j--) {\n            if (nums[j] &lt; nums[j - 1]) {\n                int temp = nums[j];\n                nums[j] = nums[j - 1];\n                nums[j - 1] = temp;\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-bubble-sort","title":"Complexity of Bubble Sort","text":"<ul> <li>Space: $O(1)$</li> <li>Time: Average $O(n^2)$, Worst Case $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-sorting/#insertion-sort","title":"Insertion Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-insertion-sort-works","title":"How Insertion Sort Works?","text":"<p>Start from the second element, compare it with the previous one. Swap them if the latter is larger than the former, otherwise, stop comparing, move to the next element. By doing this repetitively, we always take the first element for the unsorted tail list and insert it to the proper position of sorted head list.</p> <p> </p>"},{"location":"algorithm/algorithm-sorting/#implementation-of-insertion-sort","title":"Implementation of Insertion Sort","text":"<pre><code>public void insertionSort(int[] nums) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n\n    for (int i = 1; i &lt; nums.length; i++) {\n        int key = nums[i];\n        int j = i;\n        while (j &gt; 0 &amp;&amp; nums[j - 1] &gt; key) {\n            nums[j] = nums[j - 1];\n            j--;\n        }\n        nums[j] = key;\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-insertion-sort","title":"Complexity of Insertion Sort","text":"<ul> <li>Space: $O(1)$</li> <li>Time: Average $O(n^2)$, Worst Case $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-sorting/#shell-sort","title":"Shell Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-shell-sort-works","title":"How Shell Sort Works?","text":"<p>Swap two items who has the distance of the gap. Gap is reduced by half in every iteration, until it becomes to one.  </p>"},{"location":"algorithm/algorithm-sorting/#implementation-of-shell-sort","title":"Implementation of Shell Sort","text":"<pre><code>public void shellSort(int[] nums) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n\n    for (int gap = nums.length / 2; gap &gt; 0; gap = gap / 2) {\n        for (int i = gap; i &lt; nums.length; i++) {\n            int temp = nums[i];\n            int j;\n            for (j = i; j &gt;= gap &amp;&amp; nums[j - gap] &gt; temp; j = j - gap) {\n                nums[j] = nums[j - gap];\n            }\n            nums[j] = temp;\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-shell-sort","title":"Complexity of Shell Sort","text":"<ul> <li>Space: $O(1)$</li> <li>Time: The above implementation has average $O(n^2)$, worst Case $O(n^2)$. There are other ways to reduce gap which lead to better time complexity.</li> </ul>"},{"location":"algorithm/algorithm-sorting/#selection-sort","title":"Selection Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-selection-sort-works","title":"How Selection Sort Works?","text":"<p>Start from the first element, each time, find the smallest element after this element. Swap it with current element if it is smaller. By doing this repetitively, we always select the smallest element in the unsorted tail list and append it to the end of the sorted head list.  </p>"},{"location":"algorithm/algorithm-sorting/#implementation-of-selection-sort","title":"Implementation of Selection Sort","text":"<pre><code>public void selectionSort(int[] nums) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n\n    for (int i = 0; i &lt; nums.length; i++) {\n        int min = i;\n        for (int j = i + 1; j &lt; nums.length; j++) {\n            if (nums[j] &lt; nums[min]) {\n                min = j;\n            }\n        }\n\n        if (min &gt; i) {\n            int temp = nums[i];\n            nums[i] = nums[min];\n            nums[min] = temp;\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-selection-sort","title":"Complexity of Selection Sort","text":"<ul> <li>Space: $O(1)$</li> <li>Time: Average $O(n^2)$, Worst Case $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-sorting/#heap-sort","title":"Heap Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-heap-sort-works","title":"How Heap Sort Works?","text":"<p>1) Build a max heap with the given array.  2) The root contains the largest item. Swap root with last node, remove the last node(the largest item), then heapify the new root. The following diagrams shows how to use heap to find the largest and the second largest items.  3) Repeat above steps while size of heap is greater than 1. Below is the entire sorting process. </p>"},{"location":"algorithm/algorithm-sorting/#implementation","title":"Implementation","text":"<pre><code>public void heapSort(int nums[]) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n\n    // Build heap (rearrange array)\n    for (int i = nums.length / 2 - 1; i &gt;= 0; i--) {\n        heapify(nums, nums.length, i);\n    }\n    // One by one extract an element from heap\n    for (int i = nums.length - 1; i &gt;= 0; i--) {\n        int temp = nums[0];\n        nums[0] = nums[i];\n        nums[i] = temp;\n\n        heapify(nums, i, 0);\n   }\n}\n\n/*\n* n is the size of heap, i is the index of node in array\n*/\nprivate void heapify(int nums[], int n, int i) {\n    int largest = i;     // Initialize largest as root\n    int left = 2*i + 1;  // left child\n    int right = 2*i + 2; // right child\n\n    // If left child is larger than root\n    if (left &lt; n &amp;&amp; nums[left] &gt; nums[largest]) {\n        largest = left;\n    }\n\n    // If right child is larger than largest so far\n    if (right &lt; n &amp;&amp; nums[right] &gt; nums[largest]) {\n        largest = right;\n    }\n\n    // If largest is not root\n    if (largest != i) {\n        int swap = nums[i];\n        nums[i] = nums[largest];\n        nums[largest] = swap;\n\n        // Recursively heapify the affected sub-tree\n        heapify(nums, n, largest);\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-heap-sort","title":"Complexity of Heap Sort","text":"<ul> <li>Space: $O(n\\log{}n)$</li> <li>Time: Average $O(n\\log{}n)$, Worst Case $O(n\\log{}n)$</li> </ul>"},{"location":"algorithm/algorithm-sorting/#merge-sort","title":"Merge Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-merge-sort-works","title":"How Merge Sort Works?","text":"<p>Binary split the original arrays to smaller groups until each group contains only one element. Then, binary merge these groups to larger groups until we have the final one group with all sorted elements.  </p>"},{"location":"algorithm/algorithm-sorting/#implementation-of-merge-sort","title":"Implementation of Merge Sort","text":"<pre><code>public void mergeSort(int[] nums) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n    mergeHelper(nums, 0, nums.length - 1);\n    return;\n}\n\nprivate void mergeHelper(int[] nums, int start, int end) {\n    if (start &gt;= end) {\n        return;\n    }\n\n    int mid = start + (end - start) / 2;\n    mergeHelper(nums, start, mid);\n    mergeHelper(nums, mid + 1, end);\n    merge(nums, start, mid, end);\n}\n\nprivate void merge(int[] nums, int start, int mid, int end) {\n    int[] copy = Arrays.copyOf(nums, nums.length);\n\n    int left = start;\n    int right = mid + 1;\n    for (int k = start; k &lt;= end; k++) {\n        if (left &gt; mid) { // no item at left\n            nums[k] = copy[right];\n            right++;\n        }\n        else if(right &gt; end) { // no item at right\n            nums[k] = copy[left];\n            left++;\n        }\n        else if (copy[left] &lt;= copy[right]) {\n            nums[k] = copy[left];\n            left++;\n        }\n        else{\n            nums[k] = copy[right];\n            right++;\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-merge-sort","title":"Complexity of Merge Sort","text":"<ul> <li>Space: $O(n)$</li> <li>Time: Average $O(n\\log{}n)$, Worst Case $O(n\\log{}n)$</li> </ul>"},{"location":"algorithm/algorithm-sorting/#quick-sort","title":"Quick Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-quick-sort-works","title":"How Quick Sort Works?","text":"<p>1) Take the first element as pivot, split the elements to two groups. All elements in first group are smaller than pivot and all elements in second group are larger than pivot. 2) The new position of the pivot is fixed(sorted). 3) Repeat above steps until group contains only one element. Below is the entire sorting process. </p>"},{"location":"algorithm/algorithm-sorting/#implementation-of-quick-sort","title":"Implementation of Quick Sort","text":"<pre><code>public void quickSort(int[] nums) {\n    if (nums == null || nums.length &lt; 2) {\n        return;\n    }\n    quickHelper(nums, 0, nums.length - 1);\n    return;\n}\n\nprivate void quickHelper(int[] nums, int start, int end) {\n    if (start &gt;= end) {\n        return;\n    }\n\n    int pivot = partition(nums, start, end);\n    quickHelper(nums, start, pivot - 1);\n    quickHelper(nums, pivot + 1, end);\n}   \n\n// one way\nprivate int partition(int[] nums, int start, int end) {\n    int pivot = start; // select the first as the pivot\n\n    for (int i = start + 1; i &lt;= end; i++) {\n        if (nums[i] &lt; nums[start]) {\n            pivot++;\n            int temp = nums[pivot];\n            nums[pivot] = nums[i];\n            nums[i] = temp;\n        }\n    }\n\n    int temp = nums[pivot];\n    nums[pivot] = nums[start];\n    nums[start] = temp;\n    return pivot;\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-quick-sort","title":"Complexity of Quick Sort","text":"<ul> <li>Space: $O(n\\log{}n)$</li> <li>Time: Average $O(n\\log{}n)$, Worst Case $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-sorting/#bucket-sort","title":"Bucket Sort","text":""},{"location":"algorithm/algorithm-sorting/#how-bucket-sort-works","title":"How Bucket Sort Works?","text":"<p>1) Get the maximum value of the given array. 2) Create and initialize buckets. 3) Go through the original array, update corresponding bucket if that value exists. 4) Go through the buckets from the smallest index, build the sorted array. </p>"},{"location":"algorithm/algorithm-sorting/#implementation-of-bucket-sort","title":"Implementation of Bucket Sort","text":"<pre><code>public void bucketSort(int[] nums) {\n    if (nums == null || nums.length == 0) {\n        return;\n    }\n\n    // get the max value\n    int max = Integer.MIN_VALUE;\n    for (int i = 0; i &lt; nums.length; i++) {\n        if (nums[i] &gt; max) {\n            max = nums[i];\n        }\n    }\n\n    // create buckets\n    int [] bucket = new int[max + 1];\n\n    // initialize buckets\n    for (int i = 0; i &lt; bucket.length; i++) {\n        bucket[i] = 0;\n    }\n\n    // increment bucket value by one if corresponding element is found\n    for (int i = 0; i &lt; nums.length; i++) {\n        bucket[nums[i]]++;\n    }\n\n    // rebuild array from buckets\n    int index = 0;\n    for (int i = 0; i &lt; bucket.length; i++) {\n        for (int j = 0; j &lt; bucket[i]; j++) {\n            nums[index++] = i;\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-sorting/#complexity-of-bucket-sort","title":"Complexity of Bucket Sort","text":"<ul> <li>Space: Depends</li> <li>Time: Average $O(n+r)$, Worst Case $O(n+r)$</li> </ul>"},{"location":"algorithm/algorithm-sorting/#merge-sort-vs-quick-sort","title":"Merge Sort vs Quick Sort","text":"<p>Both Merge Sort and Quick Sort use the divide conquer methodology.</p> Feature Merge Sort Quick Sort Divide Conquer Yes Yes Order Individual sorted first, then overall sorted Overall sorted first, then individual sorted Time complexity Divide = O(1), Conquer = O(n), total = nLog(n) Divide = O(n), Conquer = O(1), total = nlog(n) Space Require extra space In-place Stable Yes No <p>How to explain the time complexity of merge sort?</p> <ul> <li>It divides array to smaller ones, length from n to n/2, then to n/4, until each group has only 1 item. The total level is log(n).</li> <li>At each level, it use O(1) time to split the array and O(n) time to merge.</li> <li>We have log(n) levels and we spend O(n) time at each level, so, the total time is  O(n) * log(n) = nlog(n).</li> </ul> <p>How to explain the time complexity of quick sort?</p> <ul> <li>It divides array to smaller ones by the pivot, the length is not fixed, depends on the value of pivot.</li> <li>It takes O(n) time to divide the array with pivot, uses O(1) to recursively conquer the sub arrays.</li> <li>In average case, like the merge sort, total level is log(n). At each level, it use O(n) time, so, the total time is  O(n) * log(n) = nlog(n).</li> <li>In worst case(partition the array only one element each time), it needs O(n^2) times to divide the array.</li> </ul>"},{"location":"algorithm/algorithm-sorting/#source-files","title":"Source files","text":"<ul> <li>Source files for Sorting on GitHub</li> <li>Sorting Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-sorting/#reference","title":"Reference","text":"<ul> <li>Big-O Cheat Sheet</li> <li>Sorting Algorithms on Wiki</li> <li>Data Structure - Sorting Techniques</li> <li>Bubble Sort</li> <li>Insertion Sort</li> <li>Selection Sort</li> <li>Shell Sort</li> <li>Heap Sort</li> <li>Bucket Sort</li> </ul>"},{"location":"algorithm/algorithm-sqrt-decomposition/","title":"Algorithm - Sqrt Decomposition","text":"<p>Implement Sqrt Decomposition for range search problems.</p>"},{"location":"algorithm/algorithm-sqrt-decomposition/#range-query","title":"Range Query","text":""},{"location":"algorithm/algorithm-sqrt-decomposition/#problem-description","title":"Problem Description","text":"<p>Given an integer array with <code>n</code> elements, find the sum of some elements in range from <code>i</code> to <code>j</code>. This array is mutable, meaning, any element in the array can be modified. So, we have two following operations <code>query</code> and <code>update</code>. The query method should always work even if the array is updated.</p> <ul> <li>query(i, j) - Find the sum of the elements between indices <code>i</code> and <code>j</code> (i \u2264 j), inclusive.</li> <li>update(i, val) - Modify the array by updating the element at index <code>i</code> to <code>val</code>.</li> </ul>"},{"location":"algorithm/algorithm-sqrt-decomposition/#solutions","title":"Solutions","text":"<p>There are two solutions for such range query problem. The first solution for this problem is segment tree. The second solution is Sqrt Decomposition.</p>"},{"location":"algorithm/algorithm-sqrt-decomposition/#sqrt-decomposition","title":"Sqrt Decomposition","text":"<p>Square root(Sqrt) decomposition allows us to answer queries in $O(\\sqrt{k})$ time and the implementation is usually simpler than a segment tree.</p>"},{"location":"algorithm/algorithm-sqrt-decomposition/#building-blocks","title":"Building Blocks","text":"<p>Decompose the array into small blocks. Suppose the array has 9 elements, it can be split into $\\sqrt{9}$ = 3 blocks, and we can easily calculate the sum of each block. </p> <ul> <li>If the length of the array <code>n</code> is not a perfect square, then we will have one more block.</li> </ul>"},{"location":"algorithm/algorithm-sqrt-decomposition/#query","title":"Query","text":"<p>There are two cases for the query.</p> <p>If range is on block boundaries, we can get the sum from blocks directly. For example, if the range is from 3 to 8, then block[1] and block[2] perfectly cover this range.  If range crosses blocks partially, we cannot get the sum from blocks directly. For example, if the range is from 2 to 7, we can get the sum for array[3,4,5] from block[1], however, we have to get other sums from the array. </p>"},{"location":"algorithm/algorithm-sqrt-decomposition/#update","title":"Update","text":"<p>If we update the array, we need to update the block accordingly. For example, update(2,7) will modify the array[2] from 1 to 7, and update block[0] from 9 to 15.  </p>"},{"location":"algorithm/algorithm-sqrt-decomposition/#implementation","title":"Implementation","text":"<p>Implement Sqrt Decomposition with three methods.</p> <ul> <li>build</li> <li>query</li> <li>update</li> </ul> <pre><code>public class RangeSearchSum {\n    private int[] nums;\n    private long[] sumBlocks;\n    private int sqrt;\n\n    public RangeSearchSum(int[] arr) {\n        if (arr != null &amp;&amp; arr.length &gt; 0) {\n            build(arr);\n        }\n    }\n\n    private void build(int[] arr) {\n        this.sqrt = (int) Math.ceil(Math.sqrt(arr.length));\n        this.nums = new int[sqrt * sqrt];\n        System.arraycopy(arr, 0, nums, 0, arr.length); // the tail items in nums may be zero\n        this.sumBlocks = new long[sqrt];\n        for (int i = 0; i &lt; sumBlocks.length; i++) {\n            int startIndex = i * sqrt;\n            for (int j = 0; j &lt; sqrt; j++) {\n                sumBlocks[i] += nums[startIndex + j];\n            }\n        }\n    }\n\n    // update value by index\n    public void update(int index, int value) {\n        int blockIndex = index / sqrt;\n        sumBlocks[blockIndex] = sumBlocks[blockIndex] - nums[index] + value;\n        nums[index] = value;\n    }\n\n    // query with left and right indexes\n    public long query(int left, int right) {\n        int startBlockIndex = left / sqrt;\n        int endBlockIndex = right / sqrt;\n        long sum = 0;\n\n        if (startBlockIndex == endBlockIndex) { // in the same block\n            for (int i = left; i &lt;= right; i++) {\n                sum += nums[i];\n            }\n        } else { // in the different blocks\n            // overlap\n            for (int i = startBlockIndex + 1; i &lt; endBlockIndex; i++) {\n                sum += sumBlocks[i];\n            }\n            // left non-overlap\n            int startIndex = left % sqrt;\n            for (int i = startIndex; i &lt; sqrt; i++) {\n                sum += nums[startBlockIndex * sqrt + i];\n            }\n            // right non-overlap\n            int endIndex = right % sqrt;\n            for (int i = 0; i &lt;= endIndex; i++) {\n                sum += nums[endBlockIndex * sqrt + i];\n            }\n        }\n\n        return sum;\n    }\n}\n</code></pre> <p>Usage.</p> <pre><code>RangeSearchSum sd = new RangeSearchSum(new int[] {3,5,1,5,6,10,4,2,8});\nsd.query(0, 1); // 8\nsd.query(0, 2); // 9\nsd.query(3, 5); // 21\nsd.query(6, 8); // 14\nsd.query(3, 7); // 27\nsd.query(2, 7); // 28\nsd.query(0, 8); // 44\nsd.update(2, 7); // {3,5,7,5,6,10,4,2,8}\nsd.query(0, 2); // 15\nsd.query(2, 7); // 34\nsd.query(6, 7); // 6\nsd.query(7, 8); // 10\n</code></pre>"},{"location":"algorithm/algorithm-sqrt-decomposition/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 307 - Range Sum Query - Mutable</li> </ul>"},{"location":"algorithm/algorithm-sqrt-decomposition/#source-files","title":"Source files","text":"<ul> <li>Source files for Sqrt Decomposition on GitHub</li> <li>Sqrt Decomposition Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-sqrt-decomposition/#references","title":"References","text":"<ul> <li>Sqrt Decomposition Technique - Set 1 Introduction</li> </ul>"},{"location":"algorithm/algorithm-sweep-line/","title":"Algorithm - Sweep Line","text":"<p>A sweep line is an imaginary vertical line which is swept across the plane rightwards. Use sweep line approach for solving interval problems.</p>"},{"location":"algorithm/algorithm-sweep-line/#problem-maximum-population","title":"Problem - Maximum Population","text":""},{"location":"algorithm/algorithm-sweep-line/#problem-description","title":"Problem Description","text":"<p>Given some people's birth and death year, find out the maximum population. (One similar problem is how many planes are in the air, suppose you are given with an array containing the take-off time and landing time.)</p> <p>For example, we have 5 persons with their birth and death year.</p> <ul> <li>A: 1938 ~ 1965</li> <li>B: 1953 ~ 2008</li> <li>C: 1984 ~ 2016</li> <li>D: 1930 ~ 1978</li> <li>E: 1945 ~ 2018</li> </ul> <p>The maximum population happens between 1953 and 1965, which is 4.  </p>"},{"location":"algorithm/algorithm-sweep-line/#brute-force-solution","title":"Brute Force Solution","text":"<p>First, find the first year(birth) and the last year(death) of the given persons, create an array with the same length of the year range. Then, calculate the population for each year. Finally, find the maximum population.  Below is the implementation.</p> <pre><code>// brute force,\n// time: O(n*y), n is the number of persons, y is the year range.\n// space: O(y)\npublic int getMostPopulationBruteForce(int[][] persons) {\n    if (persons == null || persons.length == 0) {\n        return 0;\n    }\n\n    // find the first year(birth) and the last year(death) of the given persons\n    int yearStart = Integer.MAX_VALUE, yearEnd = Integer.MIN_VALUE;\n    for (int[] person : persons) {\n        yearStart = Math.min(yearStart, person[0]);\n        yearEnd = Math.max(yearEnd, person[1]);\n    }\n\n    // calculate the population for each year\n    int max = 0;\n    int[] years = new int[yearEnd - yearStart + 1];\n    for (int i = 0; i &lt; years.length; i++) {\n        for (int j = 0; j &lt; persons.length; j++) {\n            if ((persons[j][0] &lt;= i + yearStart) &amp;&amp;\n                (persons[j][1] &gt; i + yearStart)) {\n                years[i]++;\n            }\n        }\n        max = Math.max(max, years[i]);\n    }\n\n    return max;\n}\n</code></pre> <ul> <li>Time complexity: $O(n*y)$, n is the number of persons, y is the year range.</li> <li>Space complexity: $O(y)$, y is the year range.</li> </ul>"},{"location":"algorithm/algorithm-sweep-line/#sweep-line-solution","title":"Sweep Line Solution","text":"<p>Create a same array as discussed in the previous solution. Sweep the time line from left to right, when we meet a birth, increment the count for that year by one; when we meet a death, decrement the count for that year by one. At last, go through the array, summarize the count for all years from left to right. Meanwhile, note down the maximum count.  Notice that, when decreasing the count, we don't care who was actually dead in that year. For example, if we exchange the death year for person A and person B, our algorithm produces same array.  Below is the implementation. Notice that no sorting is required.</p> <pre><code>// timeline, add 1 if born, minus 1 if dead, count the maximum of the timeline.\n// time: O(n+y), n is the number of persons, y is the year range.\n// space: O(y)\npublic int getMostPopulation(int[][] persons) {\n    if (persons == null || persons.length == 0) {\n        return 0;\n    }\n\n    // find the first year(birth) and the last year(death) of the given persons\n    int yearStart = Integer.MAX_VALUE, yearEnd = Integer.MIN_VALUE;\n    for (int[] person : persons) {\n        yearStart = Math.min(yearStart, person[0]);\n        yearEnd = Math.max(yearEnd, person[1]);\n    }\n\n    // increment if born, decrement if dead\n    int[] years = new int[yearEnd - yearStart + 1];\n    for (int i = 0; i &lt; persons.length; i++) {\n        years[persons[i][0] - yearStart]++;\n        years[persons[i][1] - yearStart]--;\n    }\n\n    // go through and find the maximum\n    int max = 0;\n    int count = 0;\n    for (int i = 0; i &lt; years.length; i++) {\n        count += years[i];\n        max = Math.max(max, count);\n    }\n\n    return max; // return 4\n}\n</code></pre> <ul> <li>Time complexity: $O(n+y)$, n is the number of persons, y is the year range.</li> <li>Space complexity: $O(y)$, y is the year range.</li> </ul>"},{"location":"algorithm/algorithm-sweep-line/#problem-car-pooling","title":"Problem - Car Pooling","text":""},{"location":"algorithm/algorithm-sweep-line/#problem-description2","title":"Problem Description2","text":"<p>You are driving a vehicle that has <code>capacity</code> empty seats initially available for passengers.  The vehicle only drives east (ie. it cannot turn around and drive west.)</p> <p>Given a list of trips, <code>trip[i] = [num_passengers, start_location, end_location]</code> contains information about the i-th trip: the number of passengers that must be picked up, and the locations to pick them up and drop them off.  The locations are given as the number of kilometers due east from your vehicle's initial location.</p> <p>Return true if and only if it is possible to pick up and drop off all passengers for all the given trips.</p> <p>Example 1:</p> <pre><code>Input: trips = [[2,1,5],[3,3,7]], capacity = 4\nOutput: false\n</code></pre> <p>Example 2:</p> <pre><code>Input: trips = [[2,1,5],[3,3,7]], capacity = 5\nOutput: true\n</code></pre> <p>Example 3:</p> <pre><code>Input: trips = [[2,1,5],[3,5,7]], capacity = 3\nOutput: true\n</code></pre> <p>Example 4:</p> <pre><code>Input: trips = [[3,2,7],[3,7,9],[8,3,9]], capacity = 11\nOutput: true\n</code></pre> <p>Constraints:</p> <ul> <li>trips.length &lt;= 1000</li> <li>trips[i].length == 3</li> <li>1 &lt;= trips[i][0] &lt;= 100</li> <li>0 &lt;= trips[i][1] &lt; trips[i][2] &lt;= 1000</li> <li>1 &lt;= capacity &lt;= 100000</li> </ul>"},{"location":"algorithm/algorithm-sweep-line/#sweep-line-solution2","title":"Sweep Line Solution2","text":"<p>Similar solution as the previous problem. Create an array to store the number of passengers for all locations.</p> <p>Below is the implementation. Notice that no sorting is required.</p> <pre><code>public boolean carPooling(int[][] trips, int capacity) {\n    if (trips == null || trips.length == 0) {\n        return true;\n    }\n\n    // find the minimum and maximum locations\n    int start = Integer.MIN_VALUE, end = Integer.MAX_VALUE;\n    for (int[] trip : trips) {\n        start = Math.min(start, trip[1]);\n        end = Math.max(end, trip[2]);\n    }\n\n    // create an array with the length of available locations\n    int[] locations = new int[end - start + 1];\n\n    // increment if pick up, decrement if drop off\n    for (int i = 0; i &lt; trips.length; i++) {\n        locations[trips[i][1] - start] += trips[i][0];\n        locations[trips[i][2] - start] -= trips[i][0];\n    }\n\n    // go through and count the passengers on board\n    int count = 0;\n    for (int i = 0; i &lt; locations.length; i++) {\n        count += locations[i];\n        if (count &gt; capacity) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre> <ul> <li>Time complexity: $O(n+y)$, n is the number of persons, y is the year range.</li> <li>Space complexity: $O(y)$, y is the year range.</li> </ul> <p>Since the value of location is restricted within 0~1000, so we can optimize the solution by directly defining the location array with length 1001.</p> <pre><code>public boolean carPooling(int[][] trips, int capacity) {\n    if (trips == null || trips.length == 0) {\n        return true;\n    }\n\n    int[] locations = new int[1001];\n\n    // increment if pick up, decrement if drop off\n    for (int i = 0; i &lt; trips.length; i++) {\n        locations[trips[i][1]] += trips[i][0];\n        locations[trips[i][2]] -= trips[i][0];\n    }\n\n    // go through and count the passengers on board\n    int count = 0;\n    for (int i = 0; i &lt; locations.length; i++) {\n        count += locations[i];\n        if (count &gt; capacity) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"algorithm/algorithm-sweep-line/#classic-problems","title":"Classic Problems","text":"<ul> <li>LintCode 391 - Number of Airplanes in the Sky</li> <li>LeetCode 1094 - Car Pooling</li> <li>LeetCode 218 - The Skyline Problem</li> </ul>"},{"location":"algorithm/algorithm-sweep-line/#source-files","title":"Source files","text":"<ul> <li>Source files for Sweep Line on GitHub</li> <li>Sweep Line Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-sweep-line/#references","title":"References","text":"<ul> <li>Line Sweep Technique</li> <li>Line Segment Intersection</li> <li>The Skyline Problem at LeetCode</li> <li>The skyline problem</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/","title":"Algorithm - Two Pointers","text":"<p>Two pointers technique is easy to understand which is generally used to solve problem within linear time complexity.</p>"},{"location":"algorithm/algorithm-two-pointers/#types-of-two-pointers","title":"Types of Two Pointers","text":"<ul> <li>Collision - One array, move from two sides to middle.</li> <li>Forward - One array, both move forward.</li> <li>Parallel - Two arrays, each array has been assigned with a pointer.</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/#problem","title":"Problem","text":"<p>Given a sorted (in ascending order) integer array nums of n elements and a target value, find if there exists any pair of elements (nums[i], nums[j], i!=j) such that their sum is equal to target.</p>"},{"location":"algorithm/algorithm-two-pointers/#naive-solution","title":"Naive Solution","text":"<p>Use two loops to traverse the array to find the matched elements.</p> <pre><code>// naive solution, O(n^2)\npublic boolean isPairSumNaive(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return false;\n    }\n\n    for (int i = 0; i &lt; nums.length; i++) {\n        for (int j = i + 1; j &lt;  nums.length; j++) {\n            if (nums[i] + nums[j] == target) {\n                return true; // pair exists\n            }\n\n            if (nums[i] + nums[j] &gt; target)\n                break; // break inner loop as the array is sorted\n        }\n    }\n\n    // not found\n    return false;\n}\n</code></pre> <ul> <li>Time Complexity: $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/#two-pointers-solution","title":"Two Pointers Solution","text":"<p>As the array is sorted, we can use two pointers to solve this problem. One pointer is initially at header, another pointer is initially at tail. Get the sum of the values represented by these two pointers. If sum is equal to target value, then return. If it is smaller than the target, move the left pointer to right; otherwise, move the right pointer to left. Thus, narrow down the scope of the candidates.  See the following implementation.</p> <pre><code>// Two pointers, O(n)\npublic boolean isPairSum(int[] nums, int target) {\n    if (nums == null || nums.length == 0) {\n        return false;\n    }\n    int start = 0;\n    int end = nums.length - 1;\n\n    while (start &lt; end) {\n        int sum = nums[start] + nums[end];\n        if (sum == target) {\n            return true; // pair exists\n        } else if (sum &lt; target) {\n            start++; // move start forward to get larger value\n        } else {\n            end--; // move end backward to get smaller value\n        }\n    }\n\n    // not found\n    return false;\n}\n</code></pre> <ul> <li>Time Complexity: $O(n)$</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/#classic-problems","title":"Classic Problems","text":""},{"location":"algorithm/algorithm-two-pointers/#collision","title":"Collision","text":"<p>Sub type: Two Sum</p> <ul> <li>LeetCode 167 - Two Sum II - Input array is sorted</li> <li>LeetCode 15 - 3Sum (Sort + Loop + Two Pointers)</li> <li>LeetCode 16 - 3Sum Closest (Sort + Loop + Two Pointers + diff)</li> <li>LeetCode 18 - 4Sum (Sort + Double Loop + Two Pointers + HashSet)</li> <li>LeetCode 611 - Valid Triangle Number</li> <li>LeetCode 42 - Trapping Rain Water</li> <li>LeetCode 11 - Container With Most Water</li> </ul> <p>Sub type: Partition</p> <ul> <li>LintCode 31 - Partition Array(Quick sort)</li> <li>LeetCode 125 - Valid Palindrome</li> <li>LeetCode 75 - Sort Colors</li> <li>LintCode 373 - Partition Array by Odd and Even</li> <li>LintCode 49 - Sort Letters by Case</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/#forward","title":"Forward","text":"<p>Sub type: Window</p> <ul> <li>LeetCode 209 - Minimum Size Subarray Sum</li> <li>LeetCode 3 - Longest Substring Without Repeating Characters (HashMap + Two Pointers)</li> <li>LeetCode 76 - Minimum Window Substring (HashMap + Two Pointers)</li> <li>LeetCode 159 - Longest Substring with At Most Two Distinct Characters (HashMap + Two Pointers)</li> <li>LeetCode 340 - Longest Substring with At Most K Distinct Characters</li> <li>LeetCode 19 - Remove Nth Node From End of List (One pass, moving window, linked list)</li> </ul> <p>Sub type: fast and slow</p> <ul> <li>LeetCode 876 - Middle of the Linked List(second middle node)</li> <li>LeetCode 141 - Linked List Cycle</li> <li>LeetCode 142 - Linked List Cycle II</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/#parallel","title":"Parallel","text":"<p>Two arrays, one pointer each.</p> <ul> <li>LintCode 387 - The Smallest Difference</li> <li>LeetCode 21 - Merge Two Sorted Lists</li> </ul> <p>Others- Todo</p> <ul> <li>LeetCode 26 - Remove Duplicates from Sorted Array</li> <li>LeetCode 186 - Reverse Words in a String II</li> <li>LeetCode 189 - Rotate Array</li> <li>LeetCode 238 - Product of Array Except Self</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/#source-files","title":"Source files","text":"<ul> <li>Source files for Two Pointers on GitHub</li> <li>Two Pointers Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-two-pointers/#references","title":"References","text":"<ul> <li>Two Pointers Technique</li> <li>Two-pointer technique</li> <li>The Two Pointer Algorithm</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/","title":"Algorithm - Two Sequences DP","text":""},{"location":"algorithm/algorithm-two-sequences-dp/#longest-common-subsequence","title":"Longest Common Subsequence","text":""},{"location":"algorithm/algorithm-two-sequences-dp/#problem-description","title":"Problem Description","text":"<p>Given two strings, find the longest common subsequence (LCS). Your code should return the <code>length</code> of LCS.</p> <pre><code>Example 1:\n    Input:  \"ABCD\" and \"EDCA\"\n    Output:  1\n    Explanation: LCS is 'A' or  'D' or 'C'.\nExample 2:\n    Input: \"ABCD\" and \"EACB\"\n    Output:  2\n    Explanation: LCS is \"AC\"\n</code></pre>"},{"location":"algorithm/algorithm-two-sequences-dp/#dp-solutionn2","title":"DP Solution(n^2)","text":"<pre><code>// O(n^2)\npublic int longestCommonSubsequence(String A, String B) {\n    if (A == null || A.length() == 0 || B == null || B.length() == 0) {\n        return 0;\n    }\n\n    int m = A.length();\n    int n = B.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (A.charAt(i - 1) == B.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n</code></pre> <ul> <li>Time Complexity: $O(n^2)$</li> <li>Space Complexity: $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#uncrossed-lines","title":"Uncrossed Lines","text":""},{"location":"algorithm/algorithm-two-sequences-dp/#problem-description_1","title":"Problem Description","text":"<p>We write the integers of <code>A</code> and <code>B</code> (in the order they are given) on two separate horizontal lines. Now, we may draw connecting lines: a straight line connecting two numbers <code>A[i]</code> and <code>B[j]</code> such that:</p> <ul> <li>A[i] == B[j];</li> <li>The line we draw does not intersect any other connecting (non-horizontal) line.</li> <li>Each number can only belong to one connecting line.</li> </ul> <p>Return the <code>maximum number</code> of connecting lines we can draw in this way.</p> <pre><code>Example 1:\n    Input: A = [1,4,2], B = [1,2,4]\n    Output:  2\n    Explanation: We can draw line from A[0]=1 to B[0]=1 and line from A[1]=4 to B[2]=4. We cannot draw line\n    from A[1]=4 to B[2]=4 and line from A[2]=2 to B[1]=2 at the same time because they intersect each other.\nExample 2:\n    Input: A = [2,5,1,2,5], B = [10,5,2,1,5,2]\n    Output: 3\n    Explanation: One solution is A[0]=2 -&gt; B[2]=2, A[1]=5 to B[4]=5 and A[3]=2 to B[5]=2\nExample 3:\n    Input: A = [1,3,7,1,7,5], B = [1,9,2,5,1]\n    Output: 2\n    Explanation: One solution is A[0]=1 -&gt; B[0]=1 and A[3]=1 to B[4]=1\n</code></pre>"},{"location":"algorithm/algorithm-two-sequences-dp/#dp-solutionn2_1","title":"DP Solution(n^2)","text":"<p>This question is exactly same with Longest Common Sequence.</p> <pre><code>// same as longest common subsequence, O(n^2)\npublic int maxUncrossedLines(int[] A, int[] B) {\n    int m = A.length;\n    int n = B.length;\n\n    int[][] dp = new int[m + 1][n + 1];\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (A[i-1] == B[j-1]) {\n                dp[i][j] = dp[i-1][j-1] + 1;\n            } else {\n                dp[i][j] = Math.max(dp[i-1][j], dp[i][j-1]);\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n</code></pre> <ul> <li>Time Complexity: $O(n^2)$</li> <li>Space Complexity: $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#minimum-edit-distance","title":"Minimum Edit Distance","text":""},{"location":"algorithm/algorithm-two-sequences-dp/#problem-description_2","title":"Problem Description","text":"<p>Given two strings A and B, find the minimum number of steps required to convert A to B. (each operation is counted as 1 step.) You have the following 3 operations permitted on a word:</p> <ul> <li>Insert a character</li> <li>Delete a character</li> <li>Replace a character</li> </ul> <pre><code>Example 1:\n    Input: A=\"horse\", B=\"ros\"\n    Output:  3\n    Explanation:\n      horse -&gt; rorse (replace 'h' with 'r')\n      rorse -&gt; rose (remove 'r')\n      rose -&gt; ros (remove 'e')\nExample 2:\n    Input: A=\"intention\", B=\"execution\"\n    Output:  5\n    Explanation:\n      intention -&gt; inention (remove 't')\n      inention -&gt; enention (replace 'i' with 'e')\n      enention -&gt; exention (replace 'n' with 'x')\n      exention -&gt; exection (replace 'n' with 'c')\n      exection -&gt; execution (insert 'u')\n</code></pre>"},{"location":"algorithm/algorithm-two-sequences-dp/#dp-solutionn2_2","title":"DP Solution(n^2)","text":"<pre><code>// O(n^2)\npublic int minDistance(String A, String B) {\n    int m = A.length();\n    int n = B.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 1; i &lt;= m; i++) {\n        dp[i][0] = i;\n    }\n    for (int j = 1; j &lt;= n; j++) {\n        dp[0][j] = j;\n    }\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (A.charAt(i - 1) == B.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1];\n            } else {\n                // 1) dp[i][j - 1], insert character at end of A\n                // 2) dp[i - 1][j], delete A's last character\n                // 3) dp[i - 1][j - 1], replace A's last character\n                dp[i][j] = Math.min(Math.min(dp[i][j - 1], dp[i - 1][j]), dp[i - 1][j - 1]) + 1;\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n</code></pre> <ul> <li>Time Complexity: $O(n^2)$</li> <li>Space Complexity: $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#distinct-subsequences","title":"Distinct Subsequences","text":""},{"location":"algorithm/algorithm-two-sequences-dp/#problem-description_3","title":"Problem Description","text":"<p>Given two strings S and T. Count the number of distinct subsequences of S which equals T.</p> <p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, \"ACE\" is a subsequence of \"ABCDE\" while \"AEC\" is not)</p> <pre><code>Example 1:\n    Input: S = \"rabbbit\", T = \"rabbit\"\n    Output: 3\n    Explanation: You could remove any 'b' in S, so there are 3 ways to get T.\n\nExample 2:\n    Input: S = \"abcd\", T = \"\"\n    Output: 1\n    Explanation: There is only 1 way to get T - remove all chars in S.\n</code></pre>"},{"location":"algorithm/algorithm-two-sequences-dp/#dp-solutionn2_3","title":"DP Solution(n^2)","text":"<pre><code>// O(n^2)\npublic int numDistinct(String S, String T) {\n    int m = S.length();\n    int n = T.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int i = 0; i &lt;= m; i++) {\n        dp[i][0] = 1;\n    }\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (S.charAt(i - 1) == T.charAt(j - 1)) {\n                dp[i][j] = dp[i - 1][j - 1]; // case 1: last character in T is same with that in S\n            }\n            dp[i][j] += dp[i-1][j]; // case 2: last character in T is not same with that in S\n        }\n    }\n\n    return dp[m][n];\n}\n</code></pre> <ul> <li>Time Complexity: $O(n^2)$</li> <li>Space Complexity: $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#interleaving-string","title":"Interleaving String","text":""},{"location":"algorithm/algorithm-two-sequences-dp/#problem-description_4","title":"Problem Description","text":"<p>Given three strings: s1, s2, s3, determine whether s3 is formed by the interleaving of s1 and s2.</p> <pre><code>Example 1:\n    Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbcbcac\"\n    Output: true\n\nExample 2:\n    Input: s1 = \"\", s2 = \"\", s3 = \"1\"\n    Output: false\n\nExample 3:\n    Input: s1 = \"aabcc\", s2 = \"dbbca\", s3 = \"aadbbbaccc\"\n    Output: false\n</code></pre>"},{"location":"algorithm/algorithm-two-sequences-dp/#dp-solutionn2_4","title":"DP Solution(n^2)","text":"<pre><code>// O(n^2)\npublic boolean isInterleave(String s1, String s2, String s3) {\n    int m = s1.length();\n    int n = s2.length();\n\n    if (m + n != s3.length()) {\n        return false;\n    }\n\n    boolean[][] dp = new boolean[m+1][n+1];\n    dp[0][0] = true;\n    for (int i = 1; i &lt;= m; i++) {\n        if (s1.charAt(i-1) == s3.charAt(i-1)) {\n            dp[i][0] = true;\n        } else {\n            break;\n        }\n    }\n    for (int j = 1; j &lt;= n; j++) {\n        if (s2.charAt(j-1) == s3.charAt(j-1)) {\n            dp[0][j] = true;\n        } else {\n            break;\n        }\n    }\n\n    for (int i = 1; i &lt;= m; i++) {\n        for (int j = 1; j &lt;= n; j++) {\n            if (s1.charAt(i - 1) == s3.charAt(i+j-1)) {\n                dp[i][j] = dp[i][j] || dp[i-1][j];\n            }\n            if (s2.charAt(j - 1) == s3.charAt(i+j-1)) {\n                dp[i][j] = dp[i][j] || dp[i][j-1];\n            }\n        }\n    }\n\n    return dp[m][n];\n}\n</code></pre> <ul> <li>Time Complexity: $O(n^2)$</li> <li>Space Complexity: $O(n^2)$</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 1143 - Longest Common Subsequence</li> <li>LeetCode 1035 - Uncrossed Lines</li> <li>LintCode 79 - Longest Common Substring</li> <li>LeetCode 72 - Edit Distance</li> <li>LeetCode 115 - Distinct Subsequences</li> <li>LeetCode 97 - Interleaving String</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#game-min-max","title":"Game, Min-Max","text":"<ul> <li>LeetCode 486 - Predict the Winner</li> <li>LeetCode 877 - Stone Game</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#source-files","title":"Source files","text":"<ul> <li>Source files for Dynamic Programming on GitHub</li> <li>Dynamic Programming Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-two-sequences-dp/#references","title":"References","text":"<ul> <li>Introduction to Dynamic Programming 1</li> <li>Dynamic Programming</li> <li>How to solve a Dynamic Programming Problem ?</li> <li>Tabulation vs Memorization</li> <li>\u7528\u4e24\u79cd\u65b9\u6cd5\u6c42\u6700\u957f\u4e0a\u5347\u5b50\u5e8f\u5217 LeetCode 300.Longest Increasing Subsequence</li> </ul>"},{"location":"algorithm/algorithm-union-find/","title":"Algorithm - Union Find","text":"<p>Use Union-Find approach for solve disjoint set problems.</p>"},{"location":"algorithm/algorithm-union-find/#disjoint-set","title":"Disjoint Set","text":""},{"location":"algorithm/algorithm-union-find/#disjoint-set-in-math","title":"Disjoint Set in Math","text":"<p>In mathematics, two sets are said to be <code>disjoint sets</code> if they have no element in common. Equivalently, disjoint sets are sets whose intersection is the empty set. For example, {1, 2, 3} and {4, 5, 6} are disjoint sets, while {1, 2, 3} and {3, 4, 5} are not.</p>"},{"location":"algorithm/algorithm-union-find/#disjoint-set-data-structure","title":"Disjoint-set Data Structure","text":"<p>A disjoint-set data structure is a data structure that tracks a set of elements partitioned into a number of disjoint (non-overlapping) subsets. Generally, it is implemented with an array and <code>find</code>, <code>union</code> methods.</p>"},{"location":"algorithm/algorithm-union-find/#set-problem","title":"Set Problem","text":"<p>Consider a situation with a number of persons and following tasks to be performed on them.</p> <ul> <li>Add a new friendship relation, i.e., a person <code>i</code> becomes friend of another person <code>j</code>.</li> <li>Find whether individual <code>i</code> is a friend of individual <code>j</code> (direct or indirect friend).</li> </ul>"},{"location":"algorithm/algorithm-union-find/#union-find","title":"Union Find","text":"<p>A <code>union-find</code> algorithm is an algorithm that performs two useful operations on such a Disjoint-set data structure:</p> <ul> <li><code>Find</code>: Determine which subset a particular element is in. This can be used for determining if two elements are in the same subset.</li> <li><code>Union</code>: Join two subsets into a single subset.</li> </ul> <p>Below is the sample code which implements union-find algorithm.</p> <pre><code>public class DSU { // Disjoint Set Union\n    public int[] parents;\n\n    public DSU(int size) {\n        parents = new int[size];\n        for (int i = 0; i &lt; parents.length; i++) {\n            // Initially, all elements are in their own set.\n            parents[i] = i;\n        }\n    }\n\n    // find\n    public int find(int i) {\n        if (parents[i] != i) {\n            return find(parents[i]);\n        }\n        return parents[i];\n    }\n\n    // union\n    public void union(int i, int j) {\n        int p1 = find(i);\n        int p2 = find(j);\n        parents[p1] = p2;\n    }\n}\n</code></pre> <ul> <li>Array <code>parents</code> stores the information that who is the parent of the current node.</li> </ul> <p>Let's take a look how it works. </p> <ul> <li>a) Initially, we have 5 elements and each of them in their own subset.</li> <li>b) Call 'union(0,2)' to set parent node 2 for node 0. Notice, the value at position 0 of the array is changed to 2.</li> <li>c) Call 'union(4,2)' to set parent node 2 for node 4. Notice, the value at position 4 of the array is changed to 2.</li> <li>d) Call 'union(3,1)' to set parent node 1 for node 3. Notice, the value at position 3 of the array is changed to 1.</li> <li>Finally, we have two subsets, one is {0,2,4}, another is {1,3}.</li> </ul> <p>Now, if we want to find out whether <code>0</code> and <code>4</code> are in the same subset, we just need to call <code>find(0)</code> and <code>find(4)</code>, then compare the results. If both return the same parent, then they are in the same subset.</p> <p>The following code show how to use union and find methods to reproduce the above process.</p> <pre><code>DSU dju = new DSU(5); // parents = [0,1,2,3,4]\n// set 2 as parent of 0\ndju.union(0, 2); // parents = [2,1,2,3,4]\n// set 2 as parent of 4\ndju.union(4, 2); // parents = [2,1,2,3,2]\n// set 1 as parent of 3\ndju.union(3, 1); // parents = [2,1,2,1,2]\n\n// Group1 = {0,2,4}\n// Group2 = {1,3}\n// Check if 0 and 4 are in the same group.\nif(dju.find(0) == dju.find(4)) {\n    System.out.println(\"Yes\");\n}\n// Check if 0 and 1 are in the same group.\nif(dju.find(0) != dju.find(1)) {\n    System.out.println(\"No\");\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#optimization","title":"Optimization","text":"<p>Both the find() and union() methods can be optimized.</p> <ul> <li>find() - Path Compression</li> <li>union() - Union by Rank</li> </ul>"},{"location":"algorithm/algorithm-union-find/#path-compression","title":"Path Compression","text":"<p>The idea of <code>Path Compression</code> is to flatten the tree when find() is called. The naive <code>find()</code> method is read-only. When find() is called for an element <code>i</code>, root of the tree is returned. The find() operation traverses up from <code>i</code> to find root. The idea of path compression is to make the found root as parent of <code>i</code> so that we don\u2019t have to traverse all intermediate nodes again. If <code>i</code> is root of a subtree, then path (to root) from all nodes under <code>i</code> also compresses. </p> <ul> <li>If we call naive find(3), the tree(array) remains unchanged. The next time you call find(3), it again traverses up from node 4 to node 5.</li> <li>With the optimized find() method, the parent of node 3 is updated after calling find(3). When you call find(3) for the second time, it returns parent node 5 directly. Actually, the path for node 3 and its children(node 1 and node 2) are all compressed.</li> </ul> <p>Below is the optimized find() method with Path Compression.</p> <pre><code>// Path Compression\npublic int find(int i) {\n    if (parents[i] != i) {\n        parents[i] = find(parents[i]);\n    }\n    return parents[i];\n}\n</code></pre> <p>We can also implement <code>find</code> without recursion.</p> <pre><code>// Path Compression\npublic int find(int i) {\n    while (parents[i] != i) {\n        parents[i] = parents[parents[i]];\n        i = parents[i];\n    }\n    return parents[i];\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#union-by-rank","title":"Union by Rank","text":"<p>Problem with naive union method. Following is an example of worst case scenario. Union the nodes in sequence, the tree becomes like a linked list. </p> <ul> <li>If we call find(0) after the last step d), it will traverse up from node 0 to node 1, node 2, ..., inefficient.</li> </ul> <p>The solution is to always attach smaller depth tree under the root of the deeper tree. </p> <ul> <li>a) Initially, we have 5 elements and each of them in their own subset. In addition, we have same size rank array, the default value is zero.</li> <li>b) When calling 'union(0,1)', node 0 and node 1 have the same rank 0. We can choose either of them as the root. In this case, we choose node 1 as root, so set parents[0] = 1. Since node 1 is now as root, so set rank[1] = 1.</li> <li>c) When calling 'union(1,2)', node 1 has larger rank than node 2, so take node 1 as root, set parents[2] = 1.</li> <li>d) When calling 'union(2,3)', node 2's root is node 1 and node 1 has larger rank than node 3, so take node 1 as root, set parents[3] = 1.</li> <li>Finally, we have two trees, one is {0,1,2,3}, another is {4}. Notice, tree {0,1,2,3} is flattened.</li> </ul> <p>Below is the optimized union() method with Union by Rank.</p> <pre><code>// Union by rank\npublic void union(int i, int j) {\n    int p1 = find(i);\n    int p2 = find(j);\n    if (p1 == p2) {\n        return;\n    }\n\n    // If root1\u2019s rank is less than root2\u2019s rank\n    if (rank[p1] &lt; rank[p2]) {\n        // Then move root1 under root2\n        parents[p1] = p2;\n    // If root1\u2019s rank is larger than root2\u2019s rank\n    } else if (rank[p1] &gt; rank[p2]) {\n        // Then move root2 under root1\n        parents[p2] = p1;\n    // if ranks are the same\n    } else {\n        // Then move root1 under root2 (doesn't matter which one goes where)\n        parents[p1] = p2;\n        rank[p2]++;\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#union-find-template","title":"Union Find Template","text":"<p>Based on the above discussion, here is the template for Union and Find.</p>"},{"location":"algorithm/algorithm-union-find/#without-path-compression-and-rank","title":"Without Path Compression and Rank","text":"<pre><code>public class DSU {\n    public int[] parents;\n\n    public DSU(int size) {\n        parents = new int[size];\n        for (int i = 0; i &lt; parents.length; i++) {\n            // Initially, all elements are in their own set.\n            parents[i] = i;\n        }\n    }\n\n    public int find(int i) {\n        while (parents[i] != i) {\n            i = parents[i];\n        }\n        return parents[i];\n    }\n\n    public void union(int i, int j) {\n        int p1 = find(i);\n        int p2 = find(j);\n        parents[p1] = p2;\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#with-path-compression-and-rank","title":"With Path Compression and Rank","text":"<pre><code>public class DSU { // Disjoint Set Union with Rank\n    public int[] parents;\n    public int[] rank;\n\n    public DSU(int size) {\n        parents = new int[size];\n        for (int i = 0; i &lt; parents.length; i++) {\n            // Initially, all elements are in their own set.\n            parents[i] = i;\n        }\n        rank = new int[size];\n    }\n\n    // Path Compression\n    public int find(int i) {\n        while (parents[i] != i) {\n            parents[i] = parents[parents[i]];\n            i = parents[i];\n        }\n        return parents[i];\n    }\n\n    // Union by rank\n    public void union(int i, int j) {\n        int p1 = find(i);\n        int p2 = find(j);\n        if (p1 == p2) {\n            return;\n        }\n\n        // If root1\u2019s rank is less than root2\u2019s rank\n        if (rank[p1] &lt; rank[p2]) {\n            // Then move root1 under root2\n            parents[p1] = p2;\n        // If root1\u2019s rank is larger than root2\u2019s rank\n        } else if (rank[p1] &gt; rank[p2]) {\n            // Then move root2 under root1\n            parents[p2] = p1;\n        // if ranks are the same\n        } else {\n            // Then move root1 under root2 (doesn't matter which one goes where)\n            parents[p1] = p2;\n            rank[p2]++;\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#friend-circles","title":"Friend Circles","text":""},{"location":"algorithm/algorithm-union-find/#description","title":"Description","text":"<p>There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.</p> <p>Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p> <p>Example 1:</p> <pre><code>Input:\n[[1,1,0],\n [1,1,0],\n [0,0,1]]\nOutput: 2\nExplanation:The 0th and 1st students are direct friends, so they are in a friend circle.\nThe 2nd student himself is in a friend circle. So return 2.\n</code></pre> <p>Example 2:</p> <pre><code>Input:\n[[1,1,0],\n [1,1,1],\n [0,1,1]]\nOutput: 1\nExplanation:The 0th and 1st students are direct friends, the 1st and 2nd students are direct friends,\nso the 0th and 2nd students are indirect friends. All of them are in the same friend circle, so return 1.\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#solution-with-dfs","title":"Solution with DFS","text":"<p>Search and add friend to group, then count how many groups.</p> <pre><code>// dfs\npublic int findCircleNum(int[][] M) {\n    int[] visited = new int[M.length];\n    int count = 0;\n    for (int i = 0; i &lt; M.length; i++) {\n        if (visited[i] == 0) {\n            dfs(M, visited, i);\n            count++;\n        }\n    }\n    return count;\n}  \npublic void dfs(int[][] M, int[] visited, int i) {\n    for (int j = 0; j &lt; M.length; j++) {\n        if (M[i][j] == 1 &amp;&amp; visited[j] == 0) {\n            visited[j] = 1;\n            dfs(M, visited, j);\n        }\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#solution-with-union-find-template","title":"Solution With Union Find Template","text":"<pre><code>public int findCircleNum(int[][] M) {\n    DSU dsu = new DSU(M.length);\n    for (int i = 0; i &lt; M.length - 1; i++) {\n        for (int j = i + 1; j &lt; M.length; j++) {\n            if (M[i][j] == 1) {\n                dsu.union(i, j);\n            }\n        }\n    }\n\n    return dsu.count;\n}\n\nclass DSU { // Disjoint Set Union with Rank\n    public int[] parents;\n    public int[] rank;\n    public int count; // number of groups\n\n    public DSU(int size) {\n        parents = new int[size];\n        for (int i = 0; i &lt; parents.length; i++) {\n            // Initially, all elements are in their own set.\n            parents[i] = i;\n        }\n        rank = new int[size];\n        count = size;\n    }\n\n    // Path Compression\n    public int find(int i) {\n        while (parents[i] != i) {\n            parents[i] = parents[parents[i]];\n            i = parents[i];\n        }\n        return parents[i];\n    }\n\n    // Union by rank\n    public void union(int i, int j) {\n        int p1 = find(i);\n        int p2 = find(j);\n        if (p1 == p2) {\n            return;\n        }\n\n        // If root1\u2019s rank is less than root2\u2019s rank\n        if (rank[p1] &lt; rank[p2]) {\n            // Then move root1 under root2\n            parents[p1] = p2;\n            // If root1\u2019s rank is larger than root2\u2019s rank\n        } else if (rank[p1] &gt; rank[p2]) {\n            // Then move root2 under root1\n            parents[p2] = p1;\n            // if ranks are the same\n        } else {\n            // Then move root1 under root2 (doesn't matter which one goes where)\n            parents[p1] = p2;\n            rank[p2]++;\n        }\n        count--;\n    }\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#linked-list-components","title":"Linked List Components","text":""},{"location":"algorithm/algorithm-union-find/#description_1","title":"Description","text":"<p>We are given <code>head</code>, the head node of a linked list containing <code>unique integer values</code>. We are also given the list <code>G</code>, a subset of the values in the linked list.</p> <p>Return the number of connected components in G, where two values are connected if they appear consecutively in the linked list.</p> <p>Example 1:</p> <pre><code>Input:\nhead: 0-&gt;1-&gt;2-&gt;3\nG = [0, 1, 3]\nOutput: 2\nExplanation:\n0 and 1 are connected, so [0, 1] and [3] are the two connected components.\n</code></pre> <p>Example 2:</p> <pre><code>Input:\nhead: 0-&gt;1-&gt;2-&gt;3-&gt;4\nG = [0, 3, 1, 4]\nOutput: 2\nExplanation:\n0 and 1 are connected, 3 and 4 are connected, so [0, 1] and [3, 4] are the two connected components.\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#solution-with-hashset","title":"Solution with HashSet","text":"<pre><code>public int numComponents(ListNode head, int[] G) {\n    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n    for (int g : G) {\n        set.add(g);\n    }\n\n    int ans = 0;\n    while (head != null) {\n        if (set.contains(head.val) &amp;&amp; (head.next == null || !set.contains(head.next.val))) {\n            ans++;\n        }\n        head = head.next;\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#solution-with-union-find","title":"Solution With Union Find","text":"<pre><code>public int numComponents(ListNode head, int[] G) {\n        DSU dsu = new DSU(G);\n        while (head != null &amp;&amp; head.next != null) {\n            dsu.union(head.val, head.next.val);\n            head = head.next;\n        }\n\n        return dsu.count;\n    }\n\n    public class DSU {\n        Map&lt;Integer, Integer&gt; map; // &lt;child, parent&gt;, use map instead of array\n        int count; // the number of component groups\n\n        public DSU(int[] nodes) {\n            map = new HashMap&lt;&gt;();\n            for (int node : nodes) {\n                map.put(node, node);\n            }\n            count = nodes.length;\n        }\n\n        public int find(int i) {\n            while (map.get(i) != i) {\n                map.put(i, map.get(map.get(i)));\n                i = map.get(i);\n            }\n            return map.get(i);\n        }\n\n        public void union(int i, int j) {\n            if (map.containsKey(i) &amp;&amp; map.containsKey(j)) {\n                int p1 = find(i);\n                int p2 = find(j);\n                map.put(p1, p2);\n                count--;\n            }\n        }\n    }\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#redundant-connection","title":"Redundant Connection","text":""},{"location":"algorithm/algorithm-union-find/#description_2","title":"Description","text":"<p>In this problem, a tree is an undirected graph that is connected and has no cycles.</p> <p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p> <p>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v.</p> <p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v.</p> <pre><code>Example 1:\nInput: [[1,2], [1,3], [2,3]]\nOutput: [2,3]\nExplanation: The given undirected graph will be like this:\n  1\n / \\\n2 - 3\n\nExample 2:\nInput: [[1,2], [2,3], [3,4], [1,4], [1,5]]\nOutput: [1,4]\nExplanation: The given undirected graph will be like this:\n5 - 1 - 2\n    |   |\n    4 - 3\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#solution-with-graph-dfs","title":"Solution with Graph + DFS","text":"<p>Construct graph with the given edges. During the construction, use DFS to search the target edge.</p> <pre><code>public int[] findRedundantConnection(int[][] edges) {\n    Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();\n    for (int[] edge : edges) {\n        if (!map.containsKey(edge[0])) {\n            map.put(edge[0], new ArrayList&lt;Integer&gt;());\n        }\n        if (!map.containsKey(edge[1])) {\n            map.put(edge[1], new ArrayList&lt;Integer&gt;());\n        }\n        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();\n        if (dfs(map, edge[0], edge[1], visited)) {\n            return edge;\n        }\n        map.get(edge[0]).add(edge[1]);\n        map.get(edge[1]).add(edge[0]);\n    }\n\n    return new int[]{0,0};\n}\n\nprivate boolean dfs(Map&lt;Integer, List&lt;Integer&gt;&gt; map, int start, int target, Set&lt;Integer&gt; visited) {\n\n    if (start == target) {\n        return true;\n    }\n    visited.add(start);\n    if (!map.containsKey(start) || !map.containsKey(target)) {\n        return false;\n    }\n    for (int nei : map.get(start)) {\n        if (visited.contains(nei)) {\n            continue;\n        }\n        if (dfs(map, nei, target, visited)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#solution-with-union-find_1","title":"Solution with Union Find","text":"<p>Create parents array, go through each edge, find and union them until find the target edge.</p> <pre><code>public int[] findRedundantConnection(int[][] edges) {\n    int[] parents = new int[edges.length + 1];\n    for (int i = 0; i &lt; parents.length; i++) {\n        parents[i] = i;\n    }\n\n    for (int[] edge : edges) {\n        int u = edge[0];\n        int v = edge[1];\n        int pu = find(u, parents);\n        int pv = find(v, parents);\n        if (pu == pv) {\n            return edge;\n        }\n        parents[pv] = pu;\n    }\n\n    return new int[] {0,0};\n}\n\nprivate int find(int curr, int[] parents) {\n    while (parents[curr] != curr) {\n        parents[curr] = parents[parents[curr]];\n        curr = parents[curr];\n    }\n\n    return curr;\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#solution-with-union-find-template_1","title":"Solution With Union Find Template","text":"<pre><code>class DSU {\n    int[] rank;\n    int[] parent;\n    public DSU(int size) {\n        parent = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            parent[i] = i;\n        }\n        rank = new int[size];\n    }\n\n    public int find(int i) {\n        while (parent[i] != i) {\n            parent[i] = parent[parent[i]];\n            i = parent[i];\n        }\n        return parent[i];\n    }\n\n    public boolean union(int i, int j) {\n        int p1 = find(i);\n        int p2 = find(j);\n        if (p1 == p2) { // found\n            return false;\n        } else if (rank[p1] &lt; rank[p2]) {\n            parent[p1] = p2;\n        } else if (rank[p1] &gt; rank[p1]) {\n            parent[p2] = p1;\n        } else {\n            parent[p2] = p1;\n            rank[p1]++;\n        }\n        return true;\n    }\n}\n\npublic int[] findRedundantConnection(int[][] edges) {\n    DSU dsu = new DSU(edges.length + 1);\n    for (int[] edge: edges) {\n        if (!dsu.union(edge[0], edge[1])) {\n            return edge;\n        }\n    }\n    return new int[] {0,0};\n}\n</code></pre>"},{"location":"algorithm/algorithm-union-find/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 547 - Friend Circles</li> <li>LeetCode 817 - Linked List Components</li> <li>LeetCode 684 - Redundant Connection</li> <li>LeetCode 200 - Number of Islands</li> <li>LeetCode 305 - Number of Islands II</li> <li>LeetCode 323 - Number of Connected Components in an Undirected Graph</li> </ul>"},{"location":"algorithm/algorithm-union-find/#source-files","title":"Source files","text":"<ul> <li>Source files for Union Find on GitHub</li> <li>Union Find Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"algorithm/algorithm-union-find/#references","title":"References","text":"<ul> <li>Union-Find Algorithms</li> <li>Disjoint Set Data Structures</li> <li>Disjoint Set (Or Union-Find)</li> <li>Union-Find Algorithm</li> <li>Union By Rank and Path Compression</li> </ul>"},{"location":"angular/getting-started-with-angular-cli/","title":"Getting Started with Angular CLI","text":""},{"location":"cloud/aws-billing-alarm/","title":"AWS Billing Alarm","text":""},{"location":"cloud/aws-overview/","title":"Aws Overview","text":""},{"location":"cloud/cloud-service/","title":"Cloud Service","text":""},{"location":"data-structure/data-structure-b-plus-tree/","title":"Data Structure - B+ Tree","text":"<p>Introduce B+ Tree and its properties</p>"},{"location":"data-structure/data-structure-b-plus-tree/#what-is-b-tree","title":"What is B+ Tree?","text":"<p>B+ Tree is an extension of B Tree which allows efficient insertion, deletion and search operations.</p> <p>In B Tree, Keys and records both can be stored in the internal as well as leaf nodes. Whereas, in B+ tree, records (data) can only be stored on the leaf nodes while internal nodes can only store the key values.</p> <p>The leaf nodes of a B+ tree are linked together in the form of a singly linked lists to make the search queries more efficient.</p> <p>B+ Tree are used to store the large amount of data which can not be stored in the main memory. Due to the fact that, size of main memory is always limited, the internal nodes (keys to access records) of the B+ tree are stored in the main memory whereas, leaf nodes are stored in the secondary memory.</p> <p>The internal nodes of B+ tree are often called <code>index nodes</code>. A B+ tree of order 3 is shown in the following figure.</p> <p></p>"},{"location":"data-structure/data-structure-b-plus-tree/#advantages-of-b-tree","title":"Advantages of B+ Tree","text":"<ul> <li>Records can be fetched in equal number of disk accesses.</li> <li>Height of the tree remains balanced and less as compare to B tree.</li> <li>We can access the data stored in a B+ tree sequentially as well as directly.</li> <li>Keys are used for indexing.</li> <li>Faster search queries as the data is stored only on the leaf nodes.</li> </ul>"},{"location":"data-structure/data-structure-b-plus-tree/#b-tree-vs-b-tree","title":"B Tree VS B+ Tree","text":"No. B Tree B+ Tree 1 Search keys can not be repeatedly stored. Redundant search keys can be present. 2 Data can be stored in leaf nodes as well as internal nodes Data can only be stored on the leaf nodes. 3 Searching for some data is a slower process since data can be found on internal nodes as well as on the leaf nodes. Searching is comparatively faster as data can only be found on the leaf nodes. 4 Deletion of internal nodes are so complicated and time consuming. Deletion will never be a complexed process since element will always be deleted from the leaf nodes. 5 Leaf nodes can not be linked together. Leaf nodes are linked together to make the search operations more efficient."},{"location":"data-structure/data-structure-b-plus-tree/#b-tree-operations","title":"B Tree Operations","text":""},{"location":"data-structure/data-structure-b-plus-tree/#searching","title":"Searching","text":"<p>Searching in B Trees is similar to that in Binary search tree. For example, if we search for an item 49 in the following B Tree. The process will something like following :</p> <ul> <li>Compare item 49 with root node 78. since 49 &lt; 78 hence, move to its left sub-tree.</li> <li>Since, 40&lt;49&lt;56, traverse right sub-tree of 40.</li> <li>49&gt;45, move to right. Compare 49.</li> <li>match found, return.</li> </ul> <p>Searching in a B tree depends upon the height of the tree. The search algorithm takes O(log n) time to search any element in a B tree. </p>"},{"location":"data-structure/data-structure-b-plus-tree/#insertion-in-b-tree","title":"Insertion in B+ Tree","text":"<p>Three steps:</p> <ul> <li>Insert the new node as a leaf node</li> <li>If the leaf doesn't have required space, split the node and copy the middle node to the next index node.</li> <li>If the index node doesn't have required space, split the node and copy the middle element to the next index page.</li> </ul> <p>Example : Insert the value 195 into the B+ tree of order 5 shown in the following figure.  195 will be inserted in the right sub-tree of 120 after 190. Insert it at the desired position.  The node contains greater than the maximum number of elements i.e. 4, therefore split it and place the median node up to the parent.  Now, the index node contains 6 children and 5 keys which violates the B+ tree properties, therefore we need to split it, shown as follows. </p>"},{"location":"data-structure/data-structure-b-plus-tree/#deletion-in-b-tree","title":"Deletion in B+ Tree","text":"<p>Three steps:</p> <ul> <li>Delete the key and data from the leaves.</li> <li>if the leaf node contains less than minimum number of elements, merge down the node with its sibling and delete the key in between them.</li> <li>if the index node contains less than minimum number of elements, merge the node with the sibling and move down the key in between them.</li> </ul> <p>Example:</p> <p>Delete the key 200 from the B+ Tree shown in the following figure.  200 is present in the right sub-tree of 190, after 195. delete it.  Merge the two nodes by using 195, 190, 154 and 129.  Now, element 120 is the single element present in the node which is violating the B+ Tree properties. Therefore, we need to merge it by using 60, 78, 108 and 120.</p> <p>Now, the height of B+ tree will be decreased by 1. </p>"},{"location":"data-structure/data-structure-b-plus-tree/#implementation","title":"Implementation","text":"<pre><code>// https://github.com/linli2016/BPlusTree\npublic class BPTree&lt;TKey extends Comparable&lt;TKey&gt;, TValue&gt; {\n    private BTreeNode&lt;TKey&gt; root;\n\n    public BPTree() {\n        this.root = new BTreeLeafNode&lt;TKey, TValue&gt;();\n    }\n\n    /**\n     * Insert a new key and its associated value into the B+ tree.\n     */\n    public void insert(TKey key, TValue value) {\n        BTreeLeafNode&lt;TKey, TValue&gt; leaf = this.findLeafNodeShouldContainKey(key);\n        leaf.insertKey(key, value);\n\n        if (leaf.isOverflow()) {\n            BTreeNode&lt;TKey&gt; n = leaf.dealOverflow();\n            if (n != null)\n                this.root = n;\n        }\n    }\n\n    /**\n     * Search a key value on the tree and return its associated value.\n     */\n    public TValue search(TKey key) {\n        BTreeLeafNode&lt;TKey, TValue&gt; leaf = this.findLeafNodeShouldContainKey(key);\n\n        int index = leaf.search(key);\n        return (index == -1) ? null : leaf.getValue(index);\n    }\n\n    /**\n     * Delete a key and its associated value from the tree.\n     */\n    public void delete(TKey key) {\n        BTreeLeafNode&lt;TKey, TValue&gt; leaf = this.findLeafNodeShouldContainKey(key);\n\n        if (leaf.delete(key) &amp;&amp; leaf.isUnderflow()) {\n            BTreeNode&lt;TKey&gt; n = leaf.dealUnderflow();\n            if (n != null)\n                this.root = n;\n        }\n    }\n\n    /**\n     * Search the leaf node which should contain the specified key\n     */\n    @SuppressWarnings(\"unchecked\")\n    private BTreeLeafNode&lt;TKey, TValue&gt; findLeafNodeShouldContainKey(TKey key) {\n        BTreeNode&lt;TKey&gt; node = this.root;\n        while (node.getNodeType() == TreeNodeType.InnerNode) {\n            node = ((BTreeInnerNode&lt;TKey&gt;)node).getChild( node.search(key) );\n        }\n\n        return (BTreeLeafNode&lt;TKey, TValue&gt;)node;\n    }\n\n    /**\n     * Unit tests the {@code BTree} data type.\n     *\n     * @param args the command-line arguments\n     */\n    public static void main(String[] args) {\n        BPTree&lt;String, String&gt; st = new BPTree&lt;String, String&gt;();\n\n        st.insert(\"www.cs.princeton.edu\", \"128.112.136.12\");\n        st.insert(\"www.cs.princeton.edu\", \"128.112.136.11\");\n        st.insert(\"www.princeton.edu\",    \"128.112.128.15\");\n        st.insert(\"www.yale.edu\",         \"130.132.143.21\");\n        st.insert(\"www.simpsons.com\",     \"209.052.165.60\");\n        st.insert(\"www.apple.com\",        \"17.112.152.32\");\n        st.insert(\"www.amazon.com\",       \"207.171.182.16\");\n        st.insert(\"www.ebay.com\",         \"66.135.192.87\");\n        st.insert(\"www.cnn.com\",          \"64.236.16.20\");\n        st.insert(\"www.google.com\",       \"216.239.41.99\");\n        st.insert(\"www.nytimes.com\",      \"199.239.136.200\");\n        st.insert(\"www.microsoft.com\",    \"207.126.99.140\");\n        st.insert(\"www.dell.com\",         \"143.166.224.230\");\n        st.insert(\"www.slashdot.org\",     \"66.35.250.151\");\n        st.insert(\"www.espn.com\",         \"199.181.135.201\");\n        st.insert(\"www.weather.com\",      \"63.111.66.11\");\n        st.insert(\"www.yahoo.com\",        \"216.109.118.65\");\n\n\n        System.out.println(\"cs.princeton.edu:  \" + st.search(\"www.cs.princeton.edu\"));\n        System.out.println(\"hardvardsucks.com: \" + st.search(\"www.harvardsucks.com\"));\n        System.out.println(\"simpsons.com:      \" + st.search(\"www.simpsons.com\"));\n        System.out.println(\"apple.com:         \" + st.search(\"www.apple.com\"));\n        System.out.println(\"ebay.com:          \" + st.search(\"www.ebay.com\"));\n        System.out.println(\"dell.com:          \" + st.search(\"www.dell.com\"));\n        System.out.println();\n\n        //System.out.println(\"size:    \" + st.size());\n        //System.out.println(\"height:  \" + st.height());\n        System.out.println(st);\n        System.out.println();\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-b-plus-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for B+ Tree on GitHub</li> <li>B+ Tree Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-b-plus-tree/#reference","title":"Reference","text":"<ul> <li>B+ Tree</li> <li>B+ Tree implementation in Java</li> <li>Introduction of B+ Tree</li> </ul>"},{"location":"data-structure/data-structure-b-tree/","title":"Data Structure - B Tree","text":"<p>Introduce B Tree and its properties.</p>"},{"location":"data-structure/data-structure-b-tree/#what-is-b-tree","title":"What is B Tree?","text":"<p><code>B Tree</code> is a specialized m-way tree that can be widely used for disk access. A B-Tree of order m can have at most m-1 keys and m children. One of the main reason of using B tree is its capability to store large number of keys in a single node and large key values by keeping the height of the tree relatively small.</p> <p>A B tree of order m contains all the properties of an M way tree. In addition, it contains the following properties.</p> <ul> <li>Every node in a B-Tree contains at most m children.</li> <li>Every node in a B-Tree except the root node and the leaf node contain at least m/2 children.</li> <li>The root nodes must have at least 2 nodes.</li> <li>All leaf nodes must be at the same level.</li> </ul> <p>It is not necessary that, all the nodes contain the same number of children but, each node must have m/2 number of nodes.</p> <p></p> <p>While performing some operations on B Tree, any property of B Tree may violate such as number of minimum children a node can have. To maintain the properties of B Tree, the tree may split or join.</p>"},{"location":"data-structure/data-structure-b-tree/#application-of-b-tree","title":"Application of B tree","text":"<p>B tree is used to index the data and provides fast access to the actual data stored on the disks since, the access to value stored in a large database that is stored on a disk is a very time consuming process.</p> <p>Searching an un-indexed and unsorted database containing n key values needs O(n) running time in worst case. However, if we use B Tree to index this database, it will be searched in O(log n) time in worst case.</p>"},{"location":"data-structure/data-structure-b-tree/#b-tree-operations","title":"B Tree Operations","text":""},{"location":"data-structure/data-structure-b-tree/#searching","title":"Searching","text":"<p>Searching in B Trees is similar to that in Binary search tree. For example, if we search for an item 49 in the following B Tree. The process will something like following :</p> <ul> <li>Compare item 49 with root node 78. since 49 &lt; 78 hence, move to its left sub-tree.</li> <li>Since, 40&lt;49&lt;56, traverse right sub-tree of 40.</li> <li>49&gt;45, move to right. Compare 49.</li> <li>match found, return.</li> </ul> <p>Searching in a B tree depends upon the height of the tree. The search algorithm takes O(log n) time to search any element in a B tree. </p>"},{"location":"data-structure/data-structure-b-tree/#inserting","title":"Inserting","text":"<p>Insertions are done at the leaf node level. The following algorithm needs to be followed in order to insert an item into B Tree.</p> <ul> <li>Traverse the B Tree in order to find the appropriate leaf node at which the node can be inserted.</li> <li>If the leaf node contain less than m-1 keys then insert the element in the increasing order.</li> <li>Else, if the leaf node contains m-1 keys, then follow the following steps.</li> <li>Insert the new element in the increasing order of elements.</li> <li>Split the node into the two nodes at the median.</li> <li>Push the median element upto its parent node.</li> <li>If the parent node also contain m-1 number of keys, then split it too by following the same steps.</li> </ul> <p>Example:</p> <p>Insert the node 8 into the B Tree of order 5 shown in the following image.  8 will be inserted to the right of 5, therefore insert 8.  The node, now contain 5 keys which is greater than (5 -1 = 4 ) keys. Therefore split the node from the median i.e. 8 and push it up to its parent node shown as follows. </p>"},{"location":"data-structure/data-structure-b-tree/#deletion","title":"Deletion","text":"<p>Deletion is also performed at the leaf nodes. The node which is to be deleted can either be a leaf node or an internal node. Following algorithm needs to be followed in order to delete a node from a B tree.</p> <ul> <li>Locate the leaf node.</li> <li>If there are more than m/2 keys in the leaf node then delete the desired key from the node.</li> <li>If the leaf node doesn't contain m/2 keys then complete the keys by taking the element from eight or left sibling.</li> <li>If the left sibling contains more than m/2 elements then push its largest element up to its parent and move the intervening element down to the node where the key is deleted.</li> <li>If the right sibling contains more than m/2 elements then push its smallest element up to the parent and move intervening element down to the node where the key is deleted.</li> <li>If neither of the sibling contain more than m/2 elements then create a new leaf node by joining two leaf nodes and the intervening element of the parent node.</li> <li>If parent is left with less than m/2 nodes then, apply the above process on the parent too.</li> </ul> <p>If the the node which is to be deleted is an internal node, then replace the node with its in-order successor or predecessor. Since, successor or predecessor will always be on the leaf node hence, the process will be similar as the node is being deleted from the leaf node.</p> <p>Example:</p> <p>Delete the node 53 from the B Tree of order 5 shown in the following figure.</p> <p></p> <p>53 is present in the right child of element 49. Delete it.</p> <p></p> <p>Now, 57 is the only element which is left in the node, the minimum number of elements that must be present in a B tree of order 5, is 2. it is less than that, the elements in its left and right sub-tree are also not sufficient therefore, merge it with the left sibling and intervening element of parent i.e. 49.</p> <p>The final B tree is shown as follows.</p> <p></p>"},{"location":"data-structure/data-structure-b-tree/#implementation","title":"Implementation","text":"<pre><code>public class BTree&lt;Key extends Comparable&lt;Key&gt;, Value&gt;  {\n    // max children per B-tree node = M-1\n    // (must be even and greater than 2)\n    private static final int M = 4;\n\n    private Node root;       // root of the B-tree\n    private int height;      // height of the B-tree\n    private int n;           // number of key-value pairs in the B-tree\n\n    // helper B-tree node data type\n    private static final class Node {\n        private int m;                             // number of children\n        private Entry[] children = new Entry[M];   // the array of children\n\n        // create a node with k children\n        private Node(int k) {\n            m = k;\n        }\n    }\n\n    // internal nodes: only use key and next\n    // external nodes: only use key and value\n    private static class Entry {\n        private Comparable key;\n        private final Object val;\n        private Node next;     // helper field to iterate over array entries\n        public Entry(Comparable key, Object val, Node next) {\n            this.key  = key;\n            this.val  = val;\n            this.next = next;\n        }\n    }\n\n    /**\n     * Initializes an empty B-tree.\n     */\n    public BTree() {\n        root = new Node(0);\n    }\n\n    /**\n     * Returns true if this symbol table is empty.\n     * @return {@code true} if this symbol table is empty; {@code false} otherwise\n     */\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    /**\n     * Returns the number of key-value pairs in this symbol table.\n     * @return the number of key-value pairs in this symbol table\n     */\n    public int size() {\n        return n;\n    }\n\n    /**\n     * Returns the height of this B-tree (for debugging).\n     *\n     * @return the height of this B-tree\n     */\n    public int height() {\n        return height;\n    }\n\n\n    /**\n     * Returns the value associated with the given key.\n     *\n     * @param  key the key\n     * @return the value associated with the given key if the key is in the symbol table\n     *         and {@code null} if the key is not in the symbol table\n     * @throws IllegalArgumentException if {@code key} is {@code null}\n     */\n    public Value get(Key key) {\n        if (key == null) throw new IllegalArgumentException(\"argument to get() is null\");\n        return search(root, key, height);\n    }\n\n    private Value search(Node x, Key key, int ht) {\n        Entry[] children = x.children;\n\n        // external node\n        if (ht == 0) {\n            for (int j = 0; j &lt; x.m; j++) {\n                if (eq(key, children[j].key)) return (Value) children[j].val;\n            }\n        }\n\n        // internal node\n        else {\n            for (int j = 0; j &lt; x.m; j++) {\n                if (j+1 == x.m || less(key, children[j+1].key))\n                    return search(children[j].next, key, ht-1);\n            }\n        }\n        return null;\n    }\n\n\n    /**\n     * Inserts the key-value pair into the symbol table, overwriting the old value\n     * with the new value if the key is already in the symbol table.\n     * If the value is {@code null}, this effectively deletes the key from the symbol table.\n     *\n     * @param  key the key\n     * @param  val the value\n     * @throws IllegalArgumentException if {@code key} is {@code null}\n     */\n    public void put(Key key, Value val) {\n        if (key == null) throw new IllegalArgumentException(\"argument key to put() is null\");\n        Node u = insert(root, key, val, height);\n        n++;\n        if (u == null) return;\n\n        // need to split root\n        Node t = new Node(2);\n        t.children[0] = new Entry(root.children[0].key, null, root);\n        t.children[1] = new Entry(u.children[0].key, null, u);\n        root = t;\n        height++;\n    }\n\n    private Node insert(Node h, Key key, Value val, int ht) {\n        int j;\n        Entry t = new Entry(key, val, null);\n\n        // external node\n        if (ht == 0) {\n            for (j = 0; j &lt; h.m; j++) {\n                if (less(key, h.children[j].key)) break;\n            }\n        }\n\n        // internal node\n        else {\n            for (j = 0; j &lt; h.m; j++) {\n                if ((j+1 == h.m) || less(key, h.children[j+1].key)) {\n                    Node u = insert(h.children[j++].next, key, val, ht-1);\n                    if (u == null) return null;\n                    t.key = u.children[0].key;\n                    t.next = u;\n                    break;\n                }\n            }\n        }\n\n        for (int i = h.m; i &gt; j; i--)\n            h.children[i] = h.children[i-1];\n        h.children[j] = t;\n        h.m++;\n        if (h.m &lt; M) return null;\n        else         return split(h);\n    }\n\n    // split node in half\n    private Node split(Node h) {\n        Node t = new Node(M/2);\n        h.m = M/2;\n        for (int j = 0; j &lt; M/2; j++)\n            t.children[j] = h.children[M/2+j];\n        return t;\n    }\n\n    /**\n     * Returns a string representation of this B-tree (for debugging).\n     *\n     * @return a string representation of this B-tree.\n     */\n    public String toString() {\n        return toString(root, height, \"\") + \"\\n\";\n    }\n\n    private String toString(Node h, int ht, String indent) {\n        StringBuilder s = new StringBuilder();\n        Entry[] children = h.children;\n\n        if (ht == 0) {\n            for (int j = 0; j &lt; h.m; j++) {\n                s.append(indent + children[j].key + \" \" + children[j].val + \"\\n\");\n            }\n        }\n        else {\n            for (int j = 0; j &lt; h.m; j++) {\n                if (j &gt; 0) s.append(indent + \"(\" + children[j].key + \")\\n\");\n                s.append(toString(children[j].next, ht-1, indent + \"     \"));\n            }\n        }\n        return s.toString();\n    }\n\n\n    // comparison functions - make Comparable instead of Key to avoid casts\n    private boolean less(Comparable k1, Comparable k2) {\n        return k1.compareTo(k2) &lt; 0;\n    }\n\n    private boolean eq(Comparable k1, Comparable k2) {\n        return k1.compareTo(k2) == 0;\n    }\n\n\n    /**\n     * Unit tests the {@code BTree} data type.\n     *\n     * @param args the command-line arguments\n     */\n    public static void main(String[] args) {\n        BTree&lt;String, String&gt; st = new BTree&lt;String, String&gt;();\n\n        st.put(\"www.cs.princeton.edu\", \"128.112.136.12\");\n        st.put(\"www.cs.princeton.edu\", \"128.112.136.11\");\n        st.put(\"www.princeton.edu\",    \"128.112.128.15\");\n        st.put(\"www.yale.edu\",         \"130.132.143.21\");\n        st.put(\"www.simpsons.com\",     \"209.052.165.60\");\n        st.put(\"www.apple.com\",        \"17.112.152.32\");\n        st.put(\"www.amazon.com\",       \"207.171.182.16\");\n        st.put(\"www.ebay.com\",         \"66.135.192.87\");\n        st.put(\"www.cnn.com\",          \"64.236.16.20\");\n        st.put(\"www.google.com\",       \"216.239.41.99\");\n        st.put(\"www.nytimes.com\",      \"199.239.136.200\");\n        st.put(\"www.microsoft.com\",    \"207.126.99.140\");\n        st.put(\"www.dell.com\",         \"143.166.224.230\");\n        st.put(\"www.slashdot.org\",     \"66.35.250.151\");\n        st.put(\"www.espn.com\",         \"199.181.135.201\");\n        st.put(\"www.weather.com\",      \"63.111.66.11\");\n        st.put(\"www.yahoo.com\",        \"216.109.118.65\");\n\n\n        System.out.println(\"cs.princeton.edu:  \" + st.get(\"www.cs.princeton.edu\"));\n        System.out.println(\"hardvardsucks.com: \" + st.get(\"www.harvardsucks.com\"));\n        System.out.println(\"simpsons.com:      \" + st.get(\"www.simpsons.com\"));\n        System.out.println(\"apple.com:         \" + st.get(\"www.apple.com\"));\n        System.out.println(\"ebay.com:          \" + st.get(\"www.ebay.com\"));\n        System.out.println(\"dell.com:          \" + st.get(\"www.dell.com\"));\n        System.out.println();\n\n        System.out.println(\"size:    \" + st.size());\n        System.out.println(\"height:  \" + st.height());\n        System.out.println(st);\n        System.out.println();\n    }\n\n}\n</code></pre>"},{"location":"data-structure/data-structure-b-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for B Tree on GitHub</li> <li>B Tree Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-b-tree/#reference","title":"Reference","text":"<ul> <li>B Tree</li> <li>BTree.java at Princeton</li> <li>Introduction of B-Tree</li> </ul>"},{"location":"data-structure/data-structure-binary-search-tree/","title":"Data Structure - Binary Search Tree","text":"<p>Implement and traverse binary search tree.</p>"},{"location":"data-structure/data-structure-binary-search-tree/#definition-of-bst","title":"Definition of BST","text":"<p>Binary Search Tree(BST) is a node-based binary tree data structure which has the following properties:</p> <ul> <li>The left subtree of a node contains only nodes with values lesser than the node\u2019s value.</li> <li>The right subtree of a node contains only nodes with values greater than the node\u2019s values.</li> <li>The left and right subtree each must also be a binary search tree.</li> <li>There must be no duplicate nodes.</li> </ul> <p> </p>"},{"location":"data-structure/data-structure-binary-search-tree/#common-operations-on-bst","title":"Common Operations on BST","text":"<ul> <li>Search - $O(\\log{}n)$</li> <li>Insertion - $O(\\log{}n)$</li> <li>Deletion - $O(\\log{}n)$</li> </ul>"},{"location":"data-structure/data-structure-binary-search-tree/#search","title":"Search","text":"<p>Given a binary search tree as follows, search node with value 7.</p> <p></p> <p>Binary Search Tree is constructed with nodes recursively. The following example shows how the node is defined.</p> <pre><code>public class BSTNode {\n    public int val;\n    public BSTNode left, right;\n\n    public BSTNode(int value) {\n        this.val = value;\n    }\n}\n</code></pre> <p>To search a given value in Binary Search Tree, we first compare it with root, if the key is present at root, we return root. If the value is greater than root\u2019s value, we search further in the right subtree. Otherwise we search further in the left subtree.</p> <pre><code>public boolean search(int val) {\n    BSTNode current = root;\n    while ( current != null) {\n        if (current.val == val) {\n            return true;\n        } else if (current.val &gt; val) {\n            current = current.left;\n        } else {\n            current = current.right;\n        }\n    }\n    return false;\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-search-tree/#insertion","title":"Insertion","text":"<p>Given a binary search tree as follows, insert new value 5 into this tree.</p> <p></p> <p>A new value is always inserted at leaf. Similar with the search operation, we start searching the given value from root till we hit a leaf node. Once a leaf node is found, the new node is added as a child of the leaf node. At each step, we compare the given value with the node value to determine whether to go left or right.</p> <pre><code>public void insert(int val) {\n    BSTNode newNode = new BSTNode(val);\n    if (root == null) {\n        root = newNode;\n        return;\n    }\n    BSTNode current = root;\n    while (true) {\n        if (val &lt; current.val) {\n            if (current.left == null) {\n                current.left = newNode;\n                return;\n            }\n            current = current.left;\n        } else {\n            if (current.right == null) {\n                current.right = newNode;\n                return;\n            }\n            current = current.right;\n        }\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-search-tree/#deletion","title":"Deletion","text":"<p>There are three cases when deleting a node from Binary Search Tree.</p> <ul> <li>Node is leaf, has no children.</li> <li>Node has only one child.</li> <li>Node has two children.</li> </ul>"},{"location":"data-structure/data-structure-binary-search-tree/#node-has-no-children","title":"Node Has No Children","text":"<p>The solution is easy, simply remove the node from the tree.</p>"},{"location":"data-structure/data-structure-binary-search-tree/#node-has-one-child","title":"Node Has One Child","text":"<p>If node has only one child, then replace this node with its child.</p>"},{"location":"data-structure/data-structure-binary-search-tree/#node-has-two-children","title":"Node Has Two Children","text":"<p>This case is more complex, and we have two options.  </p>"},{"location":"data-structure/data-structure-binary-search-tree/#populate-successor","title":"Populate successor","text":"<p>Find inorder successor of the node. Replace the node with its successor and delete the successor from its original parent.  </p>"},{"location":"data-structure/data-structure-binary-search-tree/#populate-predecessor","title":"Populate predecessor","text":"<p>Find inorder predecessor of the node. Replace the node with its predecessor and delete the predecessor from its original parent.  </p> <p>The following implementation populates the successor of the deleted node.</p> <pre><code>public boolean delete(int val) {\n    deleteNode(root, val);\n    return true;\n}\n\n// delete the node with the given key and return the root of the tree after deletion\nprivate BSTNode deleteNode(BSTNode root, int key) {\n    if (root == null) {\n        return null;\n    }\n    if (key &lt; root.val) {\n        root.left = deleteNode(root.left, key);\n    } else if (key &gt; root.val) {\n        root.right = deleteNode(root.right, key);\n    } else {\n        if (root.left == null) { // has no child, or left child is null\n            return root.right;\n        } else if (root.right == null) { // right child is null\n            return root.left;\n        }\n\n        // has two children\n        BSTNode minNode = findMin(root.right); // find min in right sub tree\n        root.val = minNode.val; // use the min of right as the new root\n        root.right = deleteNode(root.right, root.val); // delete the min in the original position\n    }\n    return root;\n}\n\nprivate BSTNode findMin(BSTNode node) {\n    while (node.left != null) {\n        node = node.left;\n    }\n    return node;\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-search-tree/#balanced-binary-search-tree","title":"Balanced Binary Search Tree","text":"<p>In some cases, we need to convert a normal BST tree to a balanced BST.</p> <p></p> <p>We can convert it with the following two steps.</p> <ul> <li>Get the sorted node list from existing bst tree by traversing it inorder.</li> <li>Binary construct the balanced BST with the sorted node list.</li> </ul> <pre><code>public BSTNode rebalanceBST(BSTNode root) {\n    List&lt;BSTNode&gt; list = inorder(root);\n    if (list == null || list.size() == 0) {\n        return null;\n    }\n\n    return sortedListToBST(list, 0, list.size() - 1);\n}\n\n// build bst with give node list.\nprivate BSTNode sortedListToBST(List&lt;BSTNode&gt; list, int start, int end) {\n    if (start &gt; end) {\n        return null;\n    }\n\n    int mid = start + (end - start) / 2;\n    BSTNode root = list.get(mid);\n\n    root.left = sortedListToBST(list, start, mid - 1);\n    root.right = sortedListToBST(list, mid + 1, end);\n    return root;\n}\n\n// get the sorted node list of bst tree\npublic List&lt;BSTNode&gt; inorder(BSTNode root) {\n    List&lt;BSTNode&gt; res = new ArrayList&lt;BSTNode&gt;();\n\n    if (root == null) {\n        return res;\n    }\n\n    List&lt;BSTNode&gt; left = inorder(root.left);\n    List&lt;BSTNode&gt; right = inorder(root.right);\n\n    res.addAll(left);\n    res.add(root);\n    res.addAll(right);\n\n    return res;\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-search-tree/#binary-search-tree-iterator","title":"Binary Search Tree Iterator","text":"<pre><code>public class BSTIterator {\n    private Stack&lt;BSTNode&gt; stack = new Stack&lt;BSTNode&gt;();\n    private BSTNode curr;\n    public BSTIterator(BSTNode root) {\n        curr = root;\n    }\n\n    /** @return whether we have a next smallest number */\n    public boolean hasNext() {\n        return (curr != null || !stack.isEmpty());\n    }\n\n    /** @return the next smallest number */\n    public int next() {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n\n        curr = stack.pop();\n        int res = curr.val;\n        curr = curr.right;\n        return res;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-search-tree/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 501 - Find Mode in Binary Search Tree</li> </ul>"},{"location":"data-structure/data-structure-binary-search-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for Binary Search Tree on GitHub</li> <li>Binary Search Tree Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-binary-search-tree/#reference","title":"Reference","text":"<ul> <li>Binary Search Tree - Search and Insertion</li> <li>Binary Search Tree - Delete</li> <li>Binary Search Tree Complete Implementation</li> <li>Sorted Array to Balanced BST</li> </ul>"},{"location":"data-structure/data-structure-binary-tree/","title":"Tree","text":"<p>A tree is a data structure composed of nodes.The tree cannot contain cycles. The nodes may or may not be in a particular order, they could have any data type as values, and they may or may not have links back to their parent nodes.</p>"},{"location":"data-structure/data-structure-binary-tree/#definition-of-tree","title":"Definition of Tree","text":"<ul> <li>Each tree has a root node.</li> <li>The root node has zero or more child nodes.</li> <li>Each child node has zero or more child nodes, and so on.</li> </ul>"},{"location":"data-structure/data-structure-binary-tree/#distinguishing-the-following-concepts","title":"Distinguishing the following Concepts","text":"<ul> <li>Graphs vs. Trees: A tree is a connected graph without cycles.</li> <li>Trees vs. <code>Binary Trees</code>: Each node in binary tree has no more than 2 children nodes.</li> <li>Binary Tree vs. <code>Binary Search Tree</code>: Every node in BST fits a specific ordering property: all left descendents &lt;= current node &lt; all right descendents.</li> <li><code>Complete Binary Trees</code>: A complete binary tree is a binary tree in which every level of the tree is fully filled, except for perhaps the last level. To the extent that the last level is filled, it is filled left to right.</li> <li><code>Full Binary Trees</code>: A full binary tree is a binary tree in which every node has either zero or two children.That is, no nodes have only one child.</li> <li><code>Perfect Binary Trees</code>: A perfect binary tree is one that is both full and complete. All leaf nodes will be at the same level, and this level has the maximum number of nodes.</li> </ul> <ul> <li><code>Balanced</code> vs. Unbalanced: A tree is balanced if each sub-tree is balanced and the height of the two sub-trees differ by at most one.</li> </ul>"},{"location":"data-structure/data-structure-binary-tree/#binary-tree-properties","title":"Binary Tree Properties","text":"<ul> <li>The maximum number of nodes at level <code>'l'</code> of a binary tree is $2^{l-1}$.</li> <li>Maximum number of nodes in a binary tree of height <code>'h'</code> is $2^h-1$, since 1 + 2 + 4 + .. + $2^{h-1}$ = $2^h-1$.</li> <li>In a Binary Tree with <code>'n'</code> nodes, minimum possible height or minimum number of levels is $\\log_{2}(n+1)$.</li> <li>A Binary Tree with <code>'m'</code> leaves has at least $\\log_{2}(m) + 1$ levels.</li> <li>In Binary tree where every node has 0 or 2 children, number of leaf nodes is always one more than nodes with two children.</li> </ul>"},{"location":"data-structure/data-structure-binary-tree/#binary-tree-traversal","title":"Binary Tree Traversal","text":""},{"location":"data-structure/data-structure-binary-tree/#definition-of-binary-tree","title":"Definition of Binary Tree","text":"<p>A tree whose elements have at most 2 children is called a binary tree. Since each element in a binary tree can have only 2 children, we typically name them the left and right child.</p> <p> </p>"},{"location":"data-structure/data-structure-binary-tree/#implementing-tree-node","title":"Implementing Tree Node","text":"<pre><code>public class TreeNode {\n    public int val;\n    public TreeNode left;\n    public TreeNode right;\n    public TreeNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#common-traversal-approaches-on-binary-tree","title":"Common Traversal Approaches On Binary Tree","text":""},{"location":"data-structure/data-structure-binary-tree/#depth-first-traversals","title":"Depth First Traversals","text":"<ul> <li>Preorder -&gt; root, left child, right child</li> <li>Inorder -&gt; left child, root, right child</li> <li>Postorder -&gt; left child, right child, root</li> </ul> <p>Implementation ways:</p> <ul> <li>Recursive</li> <li>Divide and Conquer</li> <li>Iterative</li> </ul>"},{"location":"data-structure/data-structure-binary-tree/#breadth-first-traversals","title":"Breadth First Traversals","text":"<ul> <li>Level order traversal</li> </ul> <p>Most of the tree traversal problems have the <code>O(n)</code> time complexity.</p>"},{"location":"data-structure/data-structure-binary-tree/#implementation-of-binary-tree-traversal-recursive","title":"Implementation of Binary Tree Traversal - Recursive","text":"<p>Pre-Order: Given binary tree {1,2,3,#,#,4,5}, output [1,2,3,4,5].</p> <pre><code>// pre-order, recursive\npublic List&lt;Integer&gt; preorderRecursion(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if (root == null) {\n        return list;\n    }\n\n    preorderHelper(root, list);\n\n    return list;\n}\n\nprivate void preorderHelper(TreeNode root, List&lt;Integer&gt; list) {\n    if (root == null) {\n        return;\n    }\n\n    list.add(root.val);\n    preorderHelper(root.left, res);\n    preorderHelper(root.right, res);\n}\n</code></pre> <p>In-Order: Given binary tree {1,2,3,#,#,4,5}, output [2,1,4,3,5].</p> <pre><code>// in-order, recursive\npublic List&lt;Integer&gt; inorderRecursion(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if (root == null) {\n        return list;\n    }\n\n    inorderHelper(root, list);\n\n    return list;\n}\n\nprivate void inorderHelper(TreeNode root, List&lt;Integer&gt; list) {\n    if (root == null) {\n        return;\n    }\n\n    inorderHelper(root.left, list);\n    res.add(root.val);\n    inorderHelper(root.right, list);\n}\n</code></pre> <p>Post-Order: Given binary tree {1,2,3,#,#,4,5}, output [2,4,5,3,1].</p> <pre><code>// post-order, recursive\npublic List&lt;Integer&gt; postorderRecursion(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if (root == null) {\n        return list;\n    }\n\n    postorderHelper(root, list);\n\n    return list;\n}\n\nprivate void postorderHelper(TreeNode root, List&lt;Integer&gt; list) {\n    if (root == null) {\n        return;\n    }\n\n    postorderHelper(root.left, list);\n    postorderHelper(root.right, list);\n    res.add(root.val);\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#implementation-of-binary-tree-traversal-divide-and-conquer","title":"Implementation of Binary Tree Traversal - Divide and Conquer","text":"<p>Pre-Order: Given binary tree {1,2,3,#,#,4,5}, output [1,2,3,4,5].</p> <pre><code>// pre-order, Divide Conquer\npublic List&lt;Integer&gt; preorderDivideConquer(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if (root == null) {\n        return list;\n    }\n\n    // divide\n    List&lt;Integer&gt; left = preorderDivideConquer(root.left);\n    List&lt;Integer&gt; right = preorderDivideConquer(root.right);\n\n    // conquer\n    list.add(root.val);\n    list.addAll(left);\n    list.addAll(right);\n\n    return list;\n}\n</code></pre> <p>In-Order: Given binary tree {1,2,3,#,#,4,5}, output [2,1,4,3,5].</p> <pre><code>// in-order, Divide Conquer\npublic List&lt;Integer&gt; inorderDivideConquer(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\n    if (root == null) {\n        return list;\n    }\n\n    // divide\n    List&lt;Integer&gt; left = inorderDivideConquer(root.left);\n    List&lt;Integer&gt; right = inorderDivideConquer(root.right);\n\n    // conquer\n    list.addAll(left);\n    list.add(root.val);\n    list.addAll(right);\n\n    return list;\n}\n</code></pre> <p>Post-Order: Given binary tree {1,2,3,#,#,4,5}, output [2,4,5,3,1].</p> <pre><code>// post-order, Divide Conquer\npublic List&lt;Integer&gt; postorderDivideConquer(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n\n    if(root == null) {\n        return list;\n    }\n\n    // divide\n    List&lt;Integer&gt; left = postorderDivideConquer(root.left);\n    List&lt;Integer&gt; right = postorderDivideConquer(root.right);\n\n    // conquer\n    list.addAll(left);\n    list.addAll(right);\n    list.add(root.val);\n\n    return list;\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#implementation-of-binary-tree-traversal-iterative","title":"Implementation of Binary Tree Traversal - Iterative","text":"<p>Pre-Order: Given binary tree {1,2,3,#,#,4,5}, output [1,2,3,4,5].</p> <pre><code>// pre-order, traverse with stack\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    if (root == null) {\n        return list;\n    }\n\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n    stack.push(root);\n    while (!stack.isEmpty()) {\n        TreeNode node = stack.pop();\n        list.add(node.val);\n        if (node.right != null) {\n            stack.push(node.right);\n        }\n        if (node.left != null) {\n            stack.push(node.left);\n        }\n    }\n    return list;\n}\n</code></pre> <p>In-Order: Given binary tree {1,2,3,#,#,4,5}, output [2,1,4,3,5].</p> <pre><code>// in-order, traverse with stack\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    if (root == null) {\n        return list;\n    }\n\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();\n    TreeNode curr = root;\n    while (curr != null || !stack.isEmpty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.pop();\n        list.add(curr.val);\n        curr = curr.right;\n    }\n    return list;\n}\n</code></pre> <p>Post-Order: Given binary tree {1,2,3,#,#,4,5}, output [2,4,5,3,1].</p> <pre><code>// post-order, traverse with stack\npublic List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();\n    if (root == null) {\n        return list;\n    }\n\n    Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();\n    TreeNode curr = root;\n    while (curr != null || !stack.empty()) {\n        while (curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        }\n        curr = stack.peek();\n        if (curr.right == null) {\n            stack.pop();\n            list.add(curr.val);\n            curr = null;\n        } else {\n            TreeNode right = curr.right;\n            curr.right = null; // avoid being added to stack again.\n            curr = right;\n        }\n    }\n    return list;\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#binary-tree-traversalgeneral-template","title":"Binary Tree Traversal(General Template)","text":"<p>Suppose we have a tree as follows.</p> <p></p> <p>There are totally 6 traversal ways.  </p> <pre><code>/**\n * 1-&gt;2-&gt;3\n */\npublic List&lt;Integer&gt; preorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();\n    TreeNode curr = root;\n    while(!stack.isEmpty() || curr != null) {\n        if(curr != null) {\n            stack.push(curr);\n            res.add(curr.val);  // Add before going to children\n            curr = curr.left;\n        } else {\n            TreeNode node = stack.pop();\n            curr = node.right;\n        }\n    }\n    return res;\n}\n\n/**\n * 2-&gt;1-&gt;3\n */\npublic List&lt;Integer&gt; inorderTraversal(TreeNode root) {\n    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();\n    TreeNode curr = root;\n    while(!stack.isEmpty() || curr != null) {\n        if(curr != null) {\n            stack.push(curr);\n            curr = curr.left;\n        } else {\n            TreeNode node = stack.pop();\n            res.add(node.val);  // Add after all left children\n            curr = node.right;\n        }\n    }\n    return res;\n}\n\n/**\n * 2-&gt;3-&gt;1\n */\npublic List&lt;Integer&gt; postorderTraversal(TreeNode root) {\n    LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();\n    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();\n    TreeNode curr = root;\n    while(!stack.isEmpty() || curr != null) {\n        if(curr != null) {\n            stack.push(curr);\n            res.addFirst(curr.val);     // Reverse the process of preorder\n            curr = curr.right;          // Reverse the process of preorder\n        } else {\n            TreeNode node = stack.pop();\n            curr = node.left;           // Reverse the process of preorder\n        }\n    }\n    return res;\n}\n\n/**\n * 1-&gt;3-&gt;2\n */\npublic List&lt;Integer&gt; preorderTraversal2(TreeNode root) {\n    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();\n    TreeNode curr = root;\n    while(!stack.isEmpty() || curr != null) {\n        if(curr != null) {\n            stack.push(curr);\n            res.add(curr.val);  // Add before going to children\n            curr = curr.right;\n        } else {\n            TreeNode node = stack.pop();\n            curr = node.left;\n        }\n    }\n    return res;\n}\n\n/**\n * 3-&gt;1-&gt;2\n */\npublic List&lt;Integer&gt; inorderTraversal2(TreeNode root) {\n    List&lt;Integer&gt; res = new ArrayList&lt;&gt;();\n    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();\n    TreeNode curr = root;\n    while(!stack.isEmpty() || curr != null) {\n        if(curr != null) {\n            stack.push(curr);\n            curr = curr.right;\n        } else {\n            TreeNode node = stack.pop();\n            res.add(node.val);  // Add after all left children\n            curr = node.left;\n        }\n    }\n    return res;\n}\n\n/**\n * 3-&gt;2-&gt;1\n */\npublic List&lt;Integer&gt; postorderTraversal2(TreeNode root) {\n    LinkedList&lt;Integer&gt; res = new LinkedList&lt;&gt;();\n    Deque&lt;TreeNode&gt; stack = new ArrayDeque&lt;&gt;();\n    TreeNode curr = root;\n    while(!stack.isEmpty() || curr != null) {\n        if(curr != null) {\n            stack.push(curr);\n            res.addFirst(curr.val);     // Reverse the process of preorder\n            curr = curr.left;          // Reverse the process of preorder\n        } else {\n            TreeNode node = stack.pop();\n            curr = node.right;           // Reverse the process of preorder\n        }\n    }\n    return res;\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#level-order-traversal-on-binary-tree","title":"Level-Order Traversal on Binary Tree","text":"<p>Given binary tree {3,9,20,#,#,15,7} as follows.</p> <p></p> <p>Return its level order traversal as below.</p> <pre><code> [  \n   [3],  \n   [9,20],  \n   [15,7]  \n ]  \n</code></pre> <p>Approach 1: BSF: Use Queue to traverse the tree by layer.</p> <pre><code>/**\n * @param root, the root node of a tree\n * @return list of the values from the tree nodes in level order\n */\npublic List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    if (root == null) {\n        return res;\n    }\n\n    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n    queue.offer(root);\n\n    while (!queue.isEmpty()) {\n        List&lt;Integer&gt; level = new ArrayList&lt;Integer&gt;();\n        int size = queue.size();\n        for (int i = 0; i &lt; size; i++) {\n            TreeNode node = queue.poll();\n            level.add(node.val);\n            if (node.left != null) {\n                queue.offer(node.left);\n            }\n            if (node.right != null) {\n                queue.offer(node.right);\n            }\n        }\n        res.add(level);\n    }\n\n    return res;\n}\n</code></pre> <p>Approach 2: DFS: recursive</p> <pre><code>public List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) {\n    List&lt;List&lt;Integer&gt;&gt; ans = new ArrayList&lt;List&lt;Integer&gt;&gt;();\n\n    helper(root, ans, 0);\n\n    return ans;\n}\nprivate void helper(TreeNode root, List&lt;List&lt;Integer&gt;&gt; list, int height) {\n    if (root == null) {\n        return;\n    }\n\n    if (height &gt;= list.size()) {\n        list.add(new ArrayList&lt;Integer&gt;());\n    }\n    list.get(height).add(root.val);\n    helper(root.left, list, height + 1);\n    helper(root.right, list, height + 1);\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#constructing-binary-tree","title":"Constructing Binary Tree","text":""},{"location":"data-structure/data-structure-binary-tree/#serialization-and-deserialization-of-binary-tree","title":"Serialization and Deserialization of Binary Tree","text":"<ul> <li>Serialization - Convert a binary tree to string.</li> <li>Deserialization - Decode a string to binary tree.</li> </ul> <p>For example, we have a tree as follows.</p> <p></p> <p>Serialization will convert to tree to string [\"1\",\"2\",\"3\",\"#\",\"#\",\"4\",\"5\"] and deserialization will convert this string to the original tree.</p> <p>Below is the implementation of serialization and deserialization in Java.</p> <pre><code>public class Codec {\n\n    // Encodes a tree to a single string.\n    public String serialize(TreeNode root) {\n        if (root == null) {\n            return \"\";\n        }\n\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n        queue.offer(root);\n        StringBuilder sb = new StringBuilder();\n        sb.append(root.val + \",\");\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i &lt; size; i++) {\n                TreeNode node = queue.poll();\n                if (node.left != null) {\n                    queue.offer(node.left);\n                    sb.append(node.left.val + \",\");\n                } else {\n                    sb.append(\"#,\");\n                }\n                if (node.right != null) {\n                    queue.offer(node.right);\n                    sb.append(node.right.val + \",\");\n                } else {\n                    sb.append(\"#,\");\n                }\n\n            }\n        }\n        sb.deleteCharAt(sb.length() - 1);\n        return sb.toString();\n    }\n\n    // Decodes your encoded data to tree.\n    public TreeNode deserialize(String data) {\n        if (data == null || data.length() == 0) {\n            return null;\n        }\n\n        String[] values = data.split(\",\");\n        Queue&lt;TreeNode&gt; queue = new LinkedList&lt;TreeNode&gt;();\n        TreeNode root = new TreeNode(Integer.parseInt(values[0]));\n        queue.offer(root);\n\n        for (int i = 1; i &lt; values.length; i = i + 2) {\n            TreeNode node = queue.poll();\n            if (!values[i].equals(\"#\")) {\n                node.left = new TreeNode(Integer.parseInt(values[i]));\n                queue.offer(node.left);\n            }\n            if (!values[i + 1].equals(\"#\")) {\n                node.right = new TreeNode(Integer.parseInt(values[i + 1]));\n                queue.offer(node.right);\n            }\n        }\n\n        return root;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#creating-tree-with-level-order-string-array","title":"Creating Tree With Level-Order String Array","text":"<p>For example, the below code create a tree with a root and right sub node. \"#\" stands for a empty node. The array contains level-order values for all the tree nodes.</p> <pre><code>TreeNode root = TreeNode.createInstance(new String[]{\"1\",\"#\",\"3\"});\n</code></pre> <p>Implementation of the 'createInstance' method.</p> <pre><code>public static TreeNode createInstance(String[] arr) {\n    if(arr == null || arr.length == 0) {\n        return null;\n    }\n\n    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n\n    TreeNode root = new TreeNode(Integer.parseInt(arr[0]));\n    queue.offer(root);\n\n    int index = 0;\n    while (index &lt; arr.length - 1) {\n        TreeNode node = queue.poll();\n        if (node != null) {\n            String str = arr[++index];\n            if (!str.equals(\"#\")) {\n                node.left = new TreeNode(Integer.parseInt(str));\n                queue.add(node.left);\n            }\n            str = arr[++index];\n            if (!str.equals(\"#\")) {\n                node.right = new TreeNode(Integer.parseInt(str));\n                queue.add(node.right);\n            }\n        }\n    }\n\n    return root;\n}\n</code></pre>"},{"location":"data-structure/data-structure-binary-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for Tree on GitHub</li> <li>Tree Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-binary-tree/#reference","title":"Reference","text":"<ul> <li>Data Structure and Algorithms - Tree</li> <li>Binary Tree Data Structure</li> <li>Tree Traversals - Inorder, Preorder and Postorder</li> </ul>"},{"location":"data-structure/data-structure-bipartite-graph/","title":"Data Structure - Bipartite Graph","text":""},{"location":"data-structure/data-structure-bipartite-graph/#is-graph-bipartite","title":"Is Graph Bipartite?","text":"<p>Given an undirected graph, return true if and only if it is bipartite.</p> <p>Recall that a graph is bipartite if we can split it's set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p> <p>The graph is given in the following form: graph[i] is a list of indexes j for which the edge between nodes i and j exists.  Each node is an integer between 0 and graph.length - 1.  There are no self edges or parallel edges: graph[i] does not contain i, and it doesn't contain any element twice.</p> <p>Example 1:</p> <pre><code>Input: [[1,3], [0,2], [1,3], [0,2]]\nOutput: true\nExplanation:\nThe graph looks like this:\n0----1\n|    |\n|    |\n3----2\nWe can divide the vertices into two groups: {0, 2} and {1, 3}.\n</code></pre> <p>Example 2:</p> <pre><code>Input: [[1,2,3], [0,2], [0,1,3], [0,2]]\nOutput: false\nExplanation:\nThe graph looks like this:\n0----1\n| \\  |\n|  \\ |\n3----2\nWe cannot find a way to divide the set of nodes into two independent subsets.\n</code></pre>"},{"location":"data-structure/data-structure-bipartite-graph/#solution-graph-coloring","title":"Solution - Graph Coloring","text":"<p>For each node</p> <ul> <li>If has not been colored, color it to RED(1).</li> <li>Color its neighbors with a different color RED(1) to BLUE(-1) or BLUE(-1) to RED(1).</li> </ul> <p>If we can finish the coloring then the graph is bipartite. All red nodes on the left no connections between them and all blues nodes on the right, again no connections between them. red and blue nodes are neighbors.</p> <p>Time complexity: O(V+E), Space complexity: O(V)</p> <p>DFS.</p> <pre><code>public boolean isBipartite(int[][] graph) {\n    if (graph == null || graph.length == 0) {\n        return false;\n    }\n\n    int n = graph.length;\n    int[] colors = new int[n]; // 0: initial, not colored, 1: colored to red, -1: colored to blue.\n\n    for (int i = 0; i &lt; n; i++) { // This graph might be a disconnected graph. So check each unvisited node.\n        if (colors[i] == 0 &amp;&amp; !dfs(graph, colors, 1, i)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nprivate boolean dfs(int[][] graph, int[] colors, int color, int node) {\n    if (colors[node] != 0) {\n        return colors[node] == color;\n    }\n\n    colors[node] = color;\n    for (int next : graph[node]) {\n        if (!dfs(graph, colors, -color, next)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"data-structure/data-structure-bipartite-graph/#possible-bipartition","title":"Possible Bipartition","text":"<p>Given a set of N people (numbered 1, 2, ..., N), we would like to split everyone into two groups of any size. Each person may dislike some other people, and they should not go into the same group. Formally, if <code>dislikes[i] = [a, b]</code>, it means it is not allowed to put the people numbered <code>a</code> and <code>b</code> into the same group.</p> <p>Return true if and only if it is possible to split everyone into two groups in this way.</p> <p>Example 1:</p> <pre><code>Input: N = 4, dislikes = [[1,2],[1,3],[2,4]]\nOutput: true\nExplanation: group1 [1,4], group2 [2,3]\n</code></pre> <p>Example 2:</p> <pre><code>Input: N = 3, dislikes = [[1,2],[1,3],[2,3]]\nOutput: false\n</code></pre> <p>Example 3:</p> <pre><code>Input: N = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]\nOutput: false\n</code></pre>"},{"location":"data-structure/data-structure-bipartite-graph/#solution-with-graph-coloring","title":"Solution with Graph Coloring","text":"<p>DFS.</p> <pre><code>public boolean possibleBipartition(int N, int[][] dislikes) {\n    if (dislikes == null) {\n        return false;\n    }\n\n    List&lt;Integer&gt;[] graph = new ArrayList[N];\n    int[] colors = new int[N]; // 0: initial, not colored, 1: colored to red, -1: colored to blue.\n\n    for (int i = 0; i &lt; N; i++) {\n        graph[i] = new ArrayList&lt;Integer&gt;();\n    }\n\n    for (int[] edge: dislikes) {\n        graph[edge[0] - 1].add(edge[1] - 1);\n        graph[edge[1] - 1].add(edge[0] - 1);\n    }\n\n    for (int i = 0; i &lt; N; i++) {\n        if (colors[i] == 0 &amp;&amp; !dfs(graph, colors, 1, i)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n\nprivate boolean dfs(List&lt;Integer&gt;[] graph, int[] colors, int color, int node) {\n    if (colors[node] != 0) {\n        return colors[node] == color;\n    }\n\n    colors[node] = color;\n    for (int next : graph[node]) {\n        if (!dfs(graph, colors, -color, next)) {\n            return false;\n        }\n    }\n\n    return true;\n}\n</code></pre>"},{"location":"data-structure/data-structure-bipartite-graph/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 785 - Is Graph Bipartite?</li> <li>LeetCode 886 - Possible Bipartition</li> </ul>"},{"location":"data-structure/data-structure-bipartite-graph/#reference","title":"Reference","text":"<ul> <li>\u82b1\u82b1\u9171 LeetCode 785. Is Graph Bipartite?</li> <li>\u4e8c\u5206\u56fe\u7684\u6700\u5927\u5339\u914d\u3001\u5b8c\u7f8e\u5339\u914d\u548c\u5308\u7259\u5229\u7b97\u6cd5</li> <li>Check whether a given graph is Bipartite or not</li> </ul>"},{"location":"data-structure/data-structure-bloom-filter/","title":"Data Structure - Bloom Filter","text":"<p>Bloom filter and its implementation.</p>"},{"location":"data-structure/data-structure-bloom-filter/#bloom-filter","title":"Bloom Filter","text":"<p><code>Bloom filter</code> is a data structure designed to rapidly and memory-efficiently tell whether an element is present in a set.</p> <p>The cost paid for this efficiency is that a Bloom filter is a <code>probabilistic data structure</code>: it tells us that the element either definitely is not in the set or may be in the set.</p> <p>The base data structure of a Bloom filter is a <code>Bit Vector</code>. </p>"},{"location":"data-structure/data-structure-bloom-filter/#implementation","title":"Implementation","text":"<p>Use an integer array as bit vector. Each cell has the value either 0 or 1. One key will be hashed by three hash functions, then it will be stored into the array.</p> <pre><code>public class BloomFilter {\n    private int capacity;\n    private int[] array;\n    public BloomFilter(int capacity) {\n        this.capacity = capacity;\n        array = new int[capacity];\n    }\n\n    public void add(String key) {\n        int first = hash_function1(key);\n        int second = hash_function2(key);\n        int third = hash_function3(key);\n        array[first%capacity] = 1;\n        array[second%capacity] = 1;\n        array[third%capacity] = 1;\n    }\n\n    public boolean contains(String key) {\n        int first = hash_function1(key);\n        int second = hash_function2(key);\n        int third = hash_function3(key);\n\n        int firstIndex = array[first % capacity];\n        if (firstIndex == 0) {\n            return false;\n        }\n\n        int secondIndex = array[second % capacity];\n        if (secondIndex == 0) {\n            return false;\n        }\n\n        int thirdIndex = array[third % capacity];\n        if (thirdIndex == 0) {\n            return false;\n        }\n\n        return true;\n    }\n\n    private int hash_function1(String key) {\n        int hash = 0;\n        for (int i = 0; i &lt; key.length(); ++i) {\n            hash = 33 * hash + key.charAt(i);\n        }\n\n        return Math.abs(hash);\n    }\n\n    private int hash_function2(String key) {\n        final int p = 16777619;\n        int hash = (int) 2166136261L;\n        for (int i = 0; i &lt; key.length(); ++i) {\n            hash = (hash ^ key.charAt(i)) * p;\n        }\n        hash += hash &lt;&lt; 13;\n        hash ^= hash &gt;&gt; 7;\n        hash += hash &lt;&lt; 3;\n        hash ^= hash &gt;&gt; 17;\n        hash += hash &lt;&lt; 5;\n        return Math.abs(hash);\n    }\n\n    private int hash_function3(String key) {\n        int hash, i;\n        for (hash = 0, i = 0; i &lt; key.length(); ++i) {\n            hash += key.charAt(i);\n            hash += (hash &lt;&lt; 10);\n            hash ^= (hash &gt;&gt; 6);\n        }\n        hash += hash &lt;&lt; 13;\n        hash ^= hash &gt;&gt; 11;\n        hash += hash &lt;&lt; 15;\n        return Math.abs(hash);\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-bloom-filter/#performance-test","title":"Performance Test","text":""},{"location":"data-structure/data-structure-bloom-filter/#test-hashset","title":"Test HashSet","text":"<p>We define a hashset with capacity 100,000,000 and insert 10,000,000 entries into the set. Then, we assert several elements to test whether they are in the set.</p> <pre><code>public class HashSetTest {\n    @Test\n    public void testHashSet() {\n        int capacity = 100000000;\n        int count = capacity / 10;\n        long start = System.currentTimeMillis();\n        Set&lt;Integer&gt; set = new HashSet&lt;&gt;(capacity);\n        for (int i = 0; i &lt; count; i++) {\n            set.add(i);\n        }\n        assertTrue(set.contains(1));\n        assertTrue(set.contains(2));\n        assertTrue(set.contains(3));\n        assertTrue(set.contains(999999));\n        assertFalse(set.contains(10000001));\n        assertFalse(set.contains(400230340));\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"Executed Time: \" + (end - start));\n    }\n}\n</code></pre> <p>It takes more than 6 seconds to execute the test.</p> <pre><code>Executed Time: 6442\n</code></pre>"},{"location":"data-structure/data-structure-bloom-filter/#test-bloom-filter","title":"Test Bloom Filter","text":"<p>Create a similar test with the Bloom Filter structure we built previously.</p> <pre><code>class BloomFilterTest {\n    @Test\n    public void testBloomFilter() {\n        int capacity = 100000000;\n        int count = capacity / 10;\n        long start = System.currentTimeMillis();\n        BloomFilter bloomFilter = new BloomFilter(capacity);\n        for (int i = 0; i &lt; count; i++) {\n            bloomFilter.add(i + \"\");\n        }\n        assertTrue(bloomFilter.contains(1 + \"\"));\n        assertTrue(bloomFilter.contains(2 + \"\"));\n        assertTrue(bloomFilter.contains(3 + \"\"));\n        assertTrue(bloomFilter.contains(999999 + \"\"));\n        assertFalse(bloomFilter.contains(10000001 + \"\"));\n        assertFalse(bloomFilter.contains(400230340 + \"\"));\n\n        long end = System.currentTimeMillis();\n        System.out.println(\"Executed Time: \" + (end - start));\n\n    }\n}\n</code></pre> <p>It takes only about 1 second to complete the test, which is much faster than the hash set.</p> <pre><code>Executed Time: 1171\n</code></pre>"},{"location":"data-structure/data-structure-bloom-filter/#source-files","title":"Source files","text":"<ul> <li>Source files for Bloom Filter on GitHub</li> </ul>"},{"location":"data-structure/data-structure-bloom-filter/#references","title":"References","text":"<ul> <li>Bloom filter - Wikipedia</li> <li>Bloom Filters by Example</li> <li>BloomFilter\u2014\u2014\u5927\u89c4\u6a21\u6570\u636e\u5904\u7406\u5229\u5668</li> <li>\u5982\u4f55\u5224\u65ad\u4e00\u4e2a\u5143\u7d20\u5728\u4ebf\u7ea7\u6570\u636e\u4e2d\u662f\u5426\u5b58\u5728\uff1f</li> </ul>"},{"location":"data-structure/data-structure-deque/","title":"Data Structure - Deque","text":"<p>Implement deque with linked list and circular array.</p>"},{"location":"data-structure/data-structure-deque/#real-life-example","title":"Real-life Example","text":"<p>Undo and Redo function in text editor.</p>"},{"location":"data-structure/data-structure-deque/#deque-in-programming-terms","title":"Deque in Programming Terms","text":"<p>A double-ended queue (abbreviated to deque) is an abstract data type that generalizes a queue, for which elements can be added to or removed from either the front (head) or back (tail). It has four principal operations:</p> <ul> <li><code>addFirst</code>: add an element to the head</li> <li><code>addLast</code>: add an element to the tail</li> <li><code>removeFirst</code>: remove the first element</li> <li><code>removeLast</code>: remove the last element</li> </ul> <p></p>"},{"location":"data-structure/data-structure-deque/#common-operations-on-queue","title":"Common Operations on Queue","text":"<ul> <li>addFirst(item): Add an item to the head of the list.</li> <li>addLast(item): Add an item to the tail of the list.</li> <li>removeFirst(): Pull the first item out of the list.</li> <li>removeLast(): Pull the last item out of the list.</li> <li>peekFirst(): Return the first item of the deque.</li> <li>peekLast(): Return the last item of the deque.</li> <li>isEmpty(): Return true if the deque is empty.</li> </ul>"},{"location":"data-structure/data-structure-deque/#time-complexity","title":"Time Complexity","text":"<ul> <li>addFirst: $O(1)$</li> <li>addLast: $O(1)$</li> <li>removeFirst: $O(1)$</li> <li>removeLast: $O(1)$</li> <li>peekFirst: $O(1)$</li> <li>peekLast: $O(1)$</li> </ul>"},{"location":"data-structure/data-structure-deque/#implementation","title":"Implementation","text":""},{"location":"data-structure/data-structure-deque/#using-linked-list","title":"Using Linked List","text":"<p>Define Node.</p> <pre><code>public class ListNode {\n    public int val;\n    public ListNode prev;\n    public ListNode next;\n    public ListNode(int val) {\n        this.val = val;\n        this.prev = null;\n        this.next = null;\n    }\n}\n</code></pre> <p>Implement Deque.</p> <pre><code>public class LinkedListDeque {\n    private ListNode head; // the first node\n    private ListNode tail; // the last node\n\n    public LinkedListDeque() {\n        head = null;\n        tail = null;\n    }\n\n    // Add item to the head of the list\n    public void addFirst(int value) {\n        if (head == null) {\n            head = new ListNode(value);\n            tail = head;\n        } else {\n            head.prev = new ListNode(value);\n            head.prev.next = head;\n            head = head.prev;\n        }\n    }\n\n    // Remove the head from the list and return its value\n    public int removeFirst() throws Exception {\n        if (head == null) {\n            throw new Exception();\n        }\n        int value = head.val;\n        head = head.next;\n        if (head != null) {\n            head.prev = null;\n        } else {\n            tail = null;\n        }\n        return value;\n    }\n\n    // Get the value of the head\n    public int peekFirst() throws Exception {\n        if (head == null) {\n            throw new Exception();\n        }\n        return head.val;\n    }\n\n    // Add item to the tail of the list\n    public void addLast(int value) {\n        if (tail == null) {\n            tail = new ListNode(value);\n            head = tail;\n        } else {\n            tail.next = new ListNode(value);\n            tail.next.prev = tail;\n            tail = tail.next;\n        }\n    }\n\n    // Remove the tail from the list and return its value\n    public int removeLast() throws Exception {\n        if (tail == null) {\n            throw new Exception();\n        }\n        int value = tail.val;\n        tail = tail.prev;\n        if (tail != null) {\n            tail.next = null;\n        } else {\n            head = null;\n        }\n        return value;\n    }\n\n    // Get the value of the tail\n    public int peekLast() throws Exception {\n        if (tail == null) {\n            throw new Exception();\n        }\n        return tail.val;\n    }\n\n    // Return whether the deque is empty\n    public boolean isEmpty() {\n        return head == null || tail == null;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-deque/#using-circular-array","title":"Using Circular Array","text":"<p>Use <code>MOD</code> to get the new position.</p> <pre><code>public class CircularArrayDeque {\n    private int head; // the first node in deque, not the first item in array\n    private int tail; // the last node in deque, not the first item in array\n    private int[] arr;\n    private int size;\n\n    public CircularArrayDeque(int capacity) {\n        arr = new int[capacity];\n        head = 0;\n        tail = 0;\n        size = 0;\n    }\n\n    // Add item to the head of the deque\n    public void addFirst(int value) {\n        // check if deque is full\n        if (isFull()) {\n            return;\n        }\n\n        head = head - 1;\n        if (head &lt; 0) {\n            head = arr.length - 1;\n        }\n        arr[head] = value;\n        size += 1;\n    }\n\n    // Remove the first item from the deque and return its value\n    public int removeFirst() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"Circular Array Deque is empty when dequeue!\");\n        }\n        int value = arr[head];\n        head = (head + 1) % arr.length;\n        size -= 1;\n        return value;\n    }\n\n    // Get the first item\n    public int peekFirst() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"Circular Array Deque is empty when peek!\");\n        }\n        return arr[head];\n    }\n\n    // Add item to the end of the deque\n    public void addLast(int value) {\n        // check if deque is full\n        if (isFull()) {\n            return;\n        }\n        tail = (head + size) % arr.length;\n        arr[tail] = value;\n        size += 1;\n    }\n\n    // Remove the last item from the deque and return its value\n    public int removeLast() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"Circular Array Deque is empty when dequeue!\");\n        }\n\n        int value = arr[tail];\n        tail = tail - 1;\n        if (tail &lt; 0) {\n            tail = arr.length - 1;\n        }\n        size -= 1;\n        return value;\n    }\n\n    // Get the last item\n    public int peekLast() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"Circular Array Deque is empty when peek!\");\n        }\n        return arr[tail];\n    }\n\n    // Return whether the queue is full\n    public boolean isFull() {\n        return size == arr.length;\n    }\n\n    // Return whether the queue is empty\n    public boolean isEmpty() {\n        return size == 0;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-deque/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 239 - Sliding Window Maximum</li> </ul>"},{"location":"data-structure/data-structure-deque/#source-files","title":"Source files","text":"<ul> <li>Source files for Deque on GitHub</li> <li>Deque Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-deque/#reference","title":"Reference","text":"<ul> <li>Deque Set 1 - Introduction and Applications</li> <li>Implementation of Deque using circular array</li> </ul>"},{"location":"data-structure/data-structure-directed-graph/","title":"Data Structure - Directed Graph","text":"<p>Implement directed graph.</p>"},{"location":"data-structure/data-structure-directed-graph/#directed-graph","title":"Directed Graph","text":"<p>A directed graph (or digraph) is a set of vertices and a collection of directed edges that each connects an ordered pair of vertices. We say that a directed edge points from the first vertex in the pair and points to the second vertex in the pair. We use the names 0 through V-1 for the vertices in a V-vertex graph.</p>"},{"location":"data-structure/data-structure-directed-graph/#topological-sorting","title":"Topological Sorting","text":"<p>Out-degree and In-degree</p> <p>Given a digraph, put the vertices in order such that all its directed edges point from a vertex earlier in the order to a vertex later in the order (or report that doing so is not possible). Topological.java solves this problem using depth-first search. Remarkably, a reverse postorder in a DAG provides a topological order.</p>"},{"location":"data-structure/data-structure-directed-graph/#detect-cycle-in-a-directed-graph","title":"Detect Cycle in a Directed Graph","text":"<p>Given a directed graph, check whether the graph contains a cycle or not. Your function should return true if the given graph contains at least one cycle, else return false. For example, the following graph contains three cycles 0-&gt;2-&gt;0, 0-&gt;1-&gt;2-&gt;0 and 3-&gt;3, so your function must return true.</p>"},{"location":"data-structure/data-structure-directed-graph/#classic-problems","title":"Classic Problems","text":"<ul> <li>LintCode 127 - Topological Sorting</li> </ul>"},{"location":"data-structure/data-structure-directed-graph/#source-files","title":"Source files","text":"<ul> <li>Source files for Directed Graph on GitHub</li> </ul>"},{"location":"data-structure/data-structure-directed-graph/#reference","title":"Reference","text":"<ul> <li>Directed Graphs</li> <li>Detect Cycle in a Directed Graph</li> <li>Topological Sorting</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/","title":"Data Structure - Fenwick Tree","text":"<p>Use fenwick tree to efficiently solve the prefix sum problem.</p>"},{"location":"data-structure/data-structure-fenwick-tree/#what-is-fenwick-tree","title":"What is Fenwick Tree?","text":"<p><code>Binary Indexed Tree</code> also called <code>Fenwick Tree</code> provides a way to represent an array of numbers in an array, allowing prefix sums to be calculated efficiently. For example, an array [2, 3, -1, 0, 6] is given, then the prefix sum of first 3 elements [2, 3, -1] is 2 + 3 + -1 = 4.</p> <p>Given an array A, and two types of operations are to be performed on it.</p> <ul> <li>Change the value stored at an index i. (This is called a point update operation)</li> <li>Find the sum of a prefix of length k. (This is called a range sum query)</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#available-solutions","title":"Available Solutions","text":""},{"location":"data-structure/data-structure-fenwick-tree/#naive-solution","title":"Naive Solution","text":"<p>A straightforward implementation looks like this.</p> <pre><code>public class PrefixSumNaive {\n    private int[] nums;\n\n    public PrefixSumNaive(int[] nums) {\n        this.nums = nums;\n    }\n\n    // update value for the specified index\n    public void update(int i, int v) {\n        nums[i] = v;\n    }\n\n    // calculate the sum of all nums[i] such that 0 &lt;= i &lt; k\n    public int prefixSum(int k) {\n        int sum = 0;\n        for (int i = 0; i &lt;= k; i++) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n\n    // calculate the sum of all nums[i] such that start &lt;= i &lt;= end\n    public int rangeSum(int start, int end) {\n        int sum = 0;\n        for (int i = start; i &lt;= end; i++) {\n            sum += nums[i];\n        }\n        return sum;\n    }\n}\n</code></pre> <ul> <li>Space Complexity: $O(n)$</li> <li>Time Complexity:</li> <li>constructor - $O(1)$</li> <li>update - $O(1)$</li> <li>prefixSum - $O(k)$, worst: $O(n)$,</li> <li>rangeSum - $O(end - start)$, worst: $O(n)$</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#improved-solution","title":"Improved Solution","text":"<p>Instead of calculate the sum every time for the query, we can store all sum values in a separate array.</p> <pre><code>public class PrefixSumImproved {\n    private int[] nums;\n    private int[] sum;\n\n    public PrefixSumImproved(int[] nums) {\n        this.nums = nums;\n        this.sum = new int[nums.length];\n        this.sum[0] = nums[0];\n        for (int i = 1; i &lt; nums.length; i++) {\n            this.sum[i] = this.sum[i - 1] + nums[i];\n        }\n    }\n\n    // update value for the specified index\n    public void update(int index, int v) {\n        for (int i = index; i &lt; sum.length; i++) {\n            sum[i] += v - nums[index];\n        }\n    }\n\n    // calculate the sum of all nums[i] such that 0 &lt;= i &lt; k\n    public int prefixSum(int k) {\n        return sum[k];\n    }\n\n    // calculate the sum of all nums[i] such that start &lt;= i &lt;= end\n    public int rangeSum(int start, int end) {\n        if (start == 0) {\n            return sum[end];\n        }\n        return sum[end] - sum[start - 1];\n    }\n}\n</code></pre> <ul> <li>Space Complexity: $O(2n)$</li> <li>Time Complexity:</li> <li>constructor - $O(n)$</li> <li>update - $O(n)$</li> <li>prefixSum - $O(1)$</li> <li>rangeSum - $O(1)$</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#segment-tree","title":"Segment Tree","text":"<pre><code>public class SegmentTree {\n    private SegmentTreeNode root;\n\n    public SegmentTree(int[] arr) {\n        this.root = build(arr, 0, arr.length - 1);\n    }\n\n    private SegmentTreeNode build(int[] arr, int start, int end) {\n        if (start &gt; end) {\n            return null;\n        }\n\n        SegmentTreeNode root = new SegmentTreeNode(start, end);\n        if (start == end) {\n            root.sum = arr[start];\n            return root;\n        }\n\n        int mid = start + (end - start) / 2;\n        root.left = build(arr, start, mid);\n        root.right = build(arr, mid + 1, end);\n        root.sum = root.left.sum + root.right.sum;\n        return root;\n    }\n\n    public int prefixSum(int index) {\n        return querySum(this.root, 0, index);\n    }\n\n    public int rangeSum(int start, int end) {\n        return querySum(this.root, start, end);\n    }\n\n    public int querySum(SegmentTreeNode root, int start, int end) {\n        if (root == null) {\n            return 0;\n        }\n\n        // case 1: search range is same with the range of root node\n        if (root.start == start &amp;&amp; root.end == end) {\n            return root.sum;\n        }\n\n        int mid = root.start + (root.end - root.start) / 2;\n        if (end &lt;= mid) {\n            // case 2: search range is in the range of left child node\n            return querySum(root.left, start, end);\n        } else if (start &gt; mid) {\n            // case 3: search range is in the range of right child node\n            return querySum(root.right, start, end);\n        } else {\n            //case 4: search range crosses both left and right children\n            int leftsum = querySum(root.left, start, mid);\n            int rightsum = querySum(root.right, mid + 1, end);\n            return leftsum + rightsum;\n        }\n    }\n\n    public void update(int index, int value) {\n        update(this.root, index, value);\n    }\n\n    private void update(SegmentTreeNode root, int index, int value) {\n        if (root == null) {\n            return;\n        }\n\n        if (root.start == root.end &amp;&amp; root.start == index) {\n            root.sum = value;\n            return;\n        }\n\n        int mid = root.start + (root.end - root.start) / 2;\n        if (index &lt;= mid) {\n            update(root.left, index, value);\n        } else {\n            update(root.right, index, value);\n        }\n\n        root.sum = root.left.sum + root.right.sum;\n    }\n\n    class SegmentTreeNode {\n        public int start, end;\n        public int sum;\n        public SegmentTreeNode left, right;\n\n        public SegmentTreeNode(int start, int end) {\n            this.start = start;\n            this.end = end;\n            this.left = null;\n            this.right = null;\n        }\n    }\n}\n</code></pre> <ul> <li>Space Complexity: $O(n)$</li> <li>Time Complexity:</li> <li>constructor - $O(n)$</li> <li>update - $O(\\log{}n)$</li> <li>prefixSum - $O(\\log{}n)$</li> <li>rangeSum - $O(\\log{}n)$</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#fenwick-tree-solution","title":"Fenwick Tree Solution","text":""},{"location":"data-structure/data-structure-fenwick-tree/#basic-idea-of-binary-indexed-tree","title":"Basic Idea of Binary Indexed Tree","text":"<p>We know the fact that each integer can be represented as the sum of powers of two. For example, 19 can be represented as 16 + 2 + 1, that is $2^4$ + $2^1$ + $2^0$. 10 can be represented as 8 + 2, that is $2^3$ + $2^1$. We will see how to use this rule in Binary Indexed Tree.</p> <p>In addition, <code>x &amp; (-x)</code> gives the last set bit in a number.</p> <ul> <li>If x = 10, its binary representation is 1010. x&amp;(-x) = 1010 &amp; 0110 = 10 = 2(decimal)</li> <li>If x = 3, its binary representation is 11. x&amp;(-x) = 011 &amp; 101 = 1(decimal)</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#representation-of-bit","title":"Representation of BIT","text":"<p>Binary Indexed Tree(BIT) is represented as an array. Let the array be BIT[]. Each node of the Binary Indexed Tree stores the sum of some elements of the input array. The size of the Binary Indexed Tree is equal to the size of the input array, denoted as n. In the code below, we use a size of n+1 for ease of implementation.  </p>"},{"location":"data-structure/data-structure-fenwick-tree/#get-sum-function","title":"Get Sum Function","text":"<p>Fenwick Tree is constructed as follows.  Create method prefixSum() to get the sum for the given index. We just need to summarize all the values along the path from dummy node to targeted node. Here are some examples.</p> <ul> <li>prefixSum(1) = BIT[1] = 2.</li> <li>prefixSum(3) = BIT[3] + BIT[2] = 6 + 1 = 7.</li> <li>prefixSum(7) = BIT[7] + BIT[6] + BIT[4]= 4 + 2 + 8 = 14.</li> <li>prefixSum(8) = BIT[8] = 15.</li> <li>prefixSum(10) = BIT[10] + BIT[8] = 15 + 5 = 20.</li> </ul> <p>To locate the parent node, we can use following formula.</p> <pre><code>index -= index &amp; (-index);\n</code></pre> <p>Below is another view of the BIT, which helps to understand how getsum works. </p> <ul> <li>prefixSum(10) = range(1, 8) + range(9, 10) = BIT[8] + BIT[10]</li> <li>prefixSum(8) = range(1, 8) = BIT[8]</li> <li>prefixSum(7) = range(1, 4) + range(5, 6) + range(7) = BIT[4] + BIT[6] + BIT[7]</li> <li>prefixSum(2) = range(1, 2) = BIT[2]</li> <li>prefixSum(1) = range(1, 1) = BIT[1]</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#update-function","title":"Update Function","text":"<p>The update function needs to make sure that all the BIT nodes which contain arr[i] within their ranges being updated. We loop over such nodes in the BIT by repeatedly adding the decimal number corresponding to the last set bit of the current index. Notice that the import parameter is the 'delta value' not an absolute value. For example, if the original array is [2, -1, 6, 1, 5, -3, 4, 1, -2, 7] and we want to update the second element arr[1] to 2, we should put 3 as import parameter when calling update() method.  Here are some examples.</p> <ul> <li>To update node1(BIT[1]), we need to update BIT[1], BIT[2], BIT[4], BIT[8].</li> <li>To update node2(BIT[2]), we need to update BIT[2], BIT[4], BIT[8].</li> <li>To update node8(BIT[8]), we need to update BIT[8] only.</li> <li>To update node10(BIT[10]), we need to update BIT[8] only.</li> <li>To update nod9(BIT[9]), we need to update BIT[9], BIT[10].</li> </ul> <p>To locate the parent node, we can use following formula.</p> <pre><code>index += index &amp; (-index);\n</code></pre>"},{"location":"data-structure/data-structure-fenwick-tree/#35-implementation","title":"3.5 Implementation","text":"<p>Create class named FenwickTree with two important methods.</p> <ul> <li>prefixSum(index) - get the pre sum from 0...index.</li> <li>update(index, value) - update with the given index and value(delta).</li> </ul> <pre><code>public class FenwickTree {\n    int[] BIT;\n\n    public FenwickTree(int arr[]) {\n        BIT = new int[arr.length + 1]; // index starts from 1 not 0.\n\n        // store the actual values in BIT[] using update()\n        for (int i = 0; i &lt; arr.length; i++) {\n            update(i, arr[i]);\n        }\n    }\n\n    // return sum of arr[0..index].\n    public int prefixSum(int index) {\n        int sum = 0;\n\n        // index in BIT[] starts from 1\n        index = index + 1;\n\n        // traverse ancestors of BIT[index]\n        while (index &gt; 0) {\n            // add current element of BIT to sum\n            sum += BIT[index];\n\n            // move index to parent node in Sum View\n            index -= index &amp; (-index);\n        }\n        return sum;\n    }\n\n    // return sum of the given range\n    public int rangeSum(int from, int to) {\n        if (from &gt;= 0 &amp;&amp; to &gt;= 0 &amp;&amp; to &gt;= from) {\n            return prefixSum(to) - prefixSum(from - 1);\n        } else {\n            return -1;\n        }\n    }\n\n    // update a node in Binary Index Tree at given index, the given value is the 'delta' value\n    // compared with the original array arr[], not array BIT[]. This delta value is added to BIT[i] and\n    // all of its ancestors.\n    public void update(int index, int val) {\n        // index in BIT[] starts from 1\n        index = index + 1;\n\n        // traverse all ancestors and add 'val'\n        while (index &lt;= BIT.length) {\n           // add 'val' to current node of BI Tree\n            BIT[index] += val;\n\n           // update index to that of parent in Update View\n           index += index &amp; (-index);\n        }\n    }\n}\n</code></pre> <ul> <li>Space Complexity: $O(n)$</li> <li>Time Complexity:</li> <li>constructor - $O(n)$</li> <li>update - $O(\\log{}n)$</li> <li>prefixSum - $O(\\log{}n)$</li> <li>rangeSum - $O(\\log{}n)$</li> </ul> <p>Simplified version of BIT.</p> <pre><code>public class FenwickTreeSimplified {\n    int[] BIT;\n\n    public FenwickTreeSimplified(int arr[]) {\n        BIT = new int[arr.length + 1];\n\n        for (int i = 0; i &lt; arr.length; i++) {\n            update(i, arr[i]);\n        }\n    }\n\n    public int prefixSum(int index) {\n        int sum = 0;\n        index++;\n        for(; index &gt; 0; index -= index&amp;-index)\n            sum += BIT[index];\n        return sum;\n    }\n\n    public int rangeSum(int from, int to) {\n        if (from &gt;= 0 &amp;&amp; to &gt;= 0 &amp;&amp; to &gt;= from) {\n            return prefixSum(to) - prefixSum(from - 1);\n        } else {\n            return -1;\n        }\n    }\n\n    public void update(int index, int val) {\n        index++;\n        for(; index &lt;= BIT.length; index += index&amp;-index)\n            BIT[index] += val;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-fenwick-tree/#performance-comparison","title":"Performance Comparison","text":"Solution Space Complexity Construct Update Get Sum Range Sum Naive $O(n)$ $O(1)$ $O(1)$ $O(n)$ $O(n)$ Improved $O(2n)$ $O(n)$ $O(n)$ $O(1)$ $O(1)$ Segment Tree $O(n)$ $O(n)$ $O(\\log{}n)$ $O(\\log{}n)$ $O(\\log{}n)$ Fenwick Tree $O(n)$ $O(n)$ $O(\\log{}n)$ $O(\\log{}n)$ $O(\\log{}n)$ <ul> <li>Fenwick Tree has same performance with segment tree, but it is much easier to implement BIT than segment tree.</li> <li>If update operation is rare, we should use the improved solution.</li> <li>If update operation is frequent, then we should use either segment tree or fenwick tree.</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for Fenwick Tree on GitHub</li> <li>Fenwick Tree Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-fenwick-tree/#reference","title":"Reference","text":"<ul> <li>Binary Indexed Tree or Fenwick Tree</li> <li>Fenwick (Binary Indexed) Trees</li> <li>Fenwick Tree / Binary Indexed Tree(Video)</li> <li>Fenwick Tree or Binary Indexed Tree(Video)</li> </ul>"},{"location":"data-structure/data-structure-graph-problems/","title":"Data Structure - Graph Problems","text":"<p>Popular graph problems.</p>"},{"location":"data-structure/data-structure-graph-problems/#number-of-islands","title":"Number of Islands","text":""},{"location":"data-structure/data-structure-graph-problems/#description-1","title":"Description 1","text":"<p>Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p> <p>Example 1:</p> <pre><code>Input:\n11110\n11010\n11000\n00000\nOutput: 1\n</code></pre> <p>Example 2:</p> <pre><code>Input:\n11000\n11000\n00100\n00011\nOutput: 3\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#solution-1-dfs","title":"Solution 1: DFS","text":"<p>Recursive. Use additional 'visited' matrix to record whether cell has been accessed. Space: (mn), Time: (mn).</p> <pre><code>// DFS: space: O(m*n), time: (m*n)\npublic int numIslands3(char[][] grid) {\n    if (grid == null || grid.length == 0 || grid[0].length == 0) {\n        return 0;\n    }\n\n    int m = grid.length;\n    int n = grid[0].length;\n    boolean[][] visited = new boolean[m][n];\n\n    int ans = 0;\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (grid[i][j] == '1' &amp;&amp; !visited[i][j]) {\n                dfs(grid, i, j, visited);\n                ans++;\n            }\n        }\n    }\n\n    return ans;\n}\n\nprivate void dfs(char[][] grid, int r, int c, boolean[][] visited) {\n    int m = grid.length;\n    int n = grid[0].length;\n    if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || visited[r][c] || grid[r][c] == '0') {\n        return;\n    }\n\n    visited[r][c] = true;\n    dfs(grid, r - 1, c, visited); // up\n    dfs(grid, r + 1, c, visited); // down\n    dfs(grid, r, c - 1, visited); // left\n    dfs(grid, r, c + 1, visited); // right\n}\n</code></pre> <p>Modifying the original given grid, space: O(1), time: (m*n).</p> <pre><code>// DFS: change values of given grid, space: O(1), time: (m*n)\npublic int numIslands2(char[][] grid) {\n    if (grid == null || grid.length == 0 || grid[0].length == 0) {\n        return 0;\n    }\n\n    int m = grid.length;\n    int n = grid[0].length;\n    int ans = 0;\n\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (grid[i][j] == '1') {\n                ans++;\n                dfs(grid, i, j);\n            }\n        }\n    }  \n\n    return ans;\n}\n\n// set adjacent cell to 0\nprivate void dfs(char[][] grid, int i, int j) {\n    int m = grid.length;\n    int n = grid[0].length;\n    if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n) {\n        return;\n    }\n\n    if (grid[i][j] == '1') {\n        grid[i][j] = '0';\n        dfs(grid, i - 1, j); // up\n        dfs(grid, i + 1, j); // down\n        dfs(grid, i, j - 1); // left\n        dfs(grid, i, j + 1); // right\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#solution-2-bfs","title":"Solution 2: BFS","text":"<p>Use queue to to store all cells for the next round scan. Use hashset to avoid adding duplicate cells to queue. Space: min(m,n), time: (m*n)</p> <pre><code>// BFS: change values of given grid, space: O(1), time: (m*n)\npublic int numIslands(char[][] grid) {\n    if (grid == null || grid.length == 0 || grid[0].length == 0) {\n        return 0;\n    }\n\n    int m = grid.length;\n    int n = grid[0].length;\n    int[] dr = new int[]{0, -1, 0, 1};\n    int[] dc = new int[]{1, 0, -1, 0};\n    int ans = 0;\n\n    for (int i = 0; i &lt; m; i++) {\n        for (int j = 0; j &lt; n; j++) {\n            if (grid[i][j] == '1') {\n                ans++;\n                Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();\n                queue.offer(new int[] {i, j});\n                while (!queue.isEmpty()) {\n                    Set&lt;Integer&gt; set = new HashSet&lt;&gt;();\n                    int size = queue.size();\n                    for (int k = 0; k &lt; size; k++) {\n                        int[] pos = queue.poll();\n                        grid[pos[0]][pos[1]] = '0';\n                        for (int p = 0; p &lt; 4; p++) {\n                            int r = pos[0] + dr[p];\n                            int c = pos[1] + dc[p];\n                            if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || grid[r][c] == '0') {\n                                continue;\n                            }\n                            if (!set.contains(r * n + c)) {\n                                queue.offer(new int[] {r, c});\n                                set.add(r * n + c);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }  \n\n    return ans;\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#shortest-bridge","title":"Shortest Bridge","text":""},{"location":"data-structure/data-structure-graph-problems/#description-2","title":"Description 2","text":"<p>In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)</p> <p>Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.</p> <p>Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)</p> <p>Example 1:</p> <pre><code>Input:\n[[0,1],\n [1,0]]\nOutput: 1\n</code></pre> <p>Example 2:</p> <pre><code>Input:\n[[0,1,0],\n [0,0,0],\n [0,0,1]]\nOutput: 2\n</code></pre> <p>Example 3:</p> <pre><code>Input:\n[[1,1,1,1,1],\n [1,0,0,0,1],\n [1,0,1,0,1],\n [1,0,0,0,1],\n [1,1,1,1,1]]\nOutput: 1\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#solution-2-with-dfs-bfs","title":"Solution 2 with DFS + BFS","text":"<p>Use DFS to find out all islands, then use BFS to find the shortest distance.</p> <pre><code>public int shortestBridge(int[][] A) {\n    if (A == null || A.length == 0 || A[0].length == 0) {\n        return 0;\n    }\n\n    int m = A.length;\n    int n = A[0].length;\n    Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();\n    // add any node of the first island into queue\n    boolean found = false;\n    for (int i = 0; i &lt; m &amp;&amp; !found; i++) {\n        for (int j = 0; j &lt; n &amp;&amp; !found; j++) {\n            if (A[i][j] == 1) {\n                dfs(A, m, n, i, j, queue);\n                found = true; // only one node is enough\n            }\n        }\n    }\n\n    int[] dr = new int[]{0, -1, 0, 1};\n    int[] dc = new int[]{1, 0, -1, 0};\n\n    int ans = 0;\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        while (size &gt; 0) {\n            int[] pos = queue.poll();\n            for (int i = 0; i &lt; 4; i++) {\n                int r = pos[0] + dr[i];\n                int c = pos[1] + dc[i];\n                if (r &lt; 0 || r &gt;= m || c &lt; 0 || c &gt;= n || A[r][c] == 2) {\n                    continue;\n                }\n\n                if (A[r][c] == 1) {\n                    return ans;\n                }\n\n                A[r][c] = 2;\n                queue.offer(new int[] {r,c});\n            }\n            size--;\n        }\n        ans++;\n    }\n\n    return ans;\n}\n\nprivate void dfs(int[][] grid, int m, int n, int i, int j, Queue&lt;int[]&gt; queue) {\n    if (i &lt; 0 || i &gt;= m || j &lt; 0 || j &gt;= n || grid[i][j] != 1) {\n        return;\n    }\n    grid[i][j] = 2; // mark as growing\n    queue.offer(new int[]{i, j});\n    dfs(grid, m, n, i - 1, j, queue);\n    dfs(grid, m, n, i + 1, j, queue);\n    dfs(grid, m, n, i, j - 1, queue);\n    dfs(grid, m, n, i, j + 1, queue);\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#closest-leaf-in-a-binary-tree","title":"Closest Leaf in a Binary Tree","text":""},{"location":"data-structure/data-structure-graph-problems/#description-3","title":"Description 3","text":"<p>Given a binary tree where every node has a unique value, and a target key <code>k</code>, find the value of the nearest leaf node to target k in the tree.</p> <p>Here, nearest to a leaf means the least number of edges travelled on the binary tree to reach any leaf of the tree. Also, a node is called a leaf if it has no children.</p> <p>In the following examples, the input tree is represented in flattened form row by row. The actual root tree given will be a TreeNode object.</p> <pre><code>Example 3:\n\nInput:\nroot = [1,2,3,4,null,null,null,5,null,6], k = 2\nDiagram of binary tree:\n             1\n            / \\\n           2   3\n          /\n         4\n        /\n       5\n      /\n     6\n\nOutput: 3\nExplanation: The leaf node with value 3 (and not the leaf node with value 6) is nearest to the node with value 2.\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#solution-3-with-dfs-bfs","title":"Solution 3 with DFS + BFS","text":"<p>Use DFS to convert tree to graph with HashMap, then use BFS to find the shortest path from target <code>k</code> to leaf in graph.</p> <pre><code>TreeNode nodeK = null;\npublic int findClosestLeaf(TreeNode root, int k) {\n    Map&lt;Integer, List&lt;TreeNode&gt;&gt; map = new HashMap&lt;&gt;();\n    helper(map, root, k);\n    Set&lt;TreeNode&gt; set = new HashSet&lt;&gt;();\n    Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();\n    queue.offer(nodeK);\n\n    while (!queue.isEmpty()) {\n        int size = queue.size();\n        while (size-- &gt; 0) {\n            TreeNode node = queue.poll();\n            if (node.left == null &amp;&amp; node.right == null) {\n                return node.val;\n            }\n            set.add(node);\n            List&lt;TreeNode&gt; neis = map.get(node.val);\n            for (TreeNode nei : neis) {\n                if (!set.contains(nei)) {\n                    queue.offer(nei);\n                }\n            }\n        }\n    }\n\n    return 0;\n}\n\nprivate void helper(Map&lt;Integer, List&lt;TreeNode&gt;&gt; map, TreeNode root, int k) {\n    if (root == null) {\n        return;\n    }\n\n    if (root.val == k) {\n        nodeK = root;\n    }\n    if (!map.containsKey(root.val)) {\n        map.put(root.val, new ArrayList&lt;TreeNode&gt;());\n    }\n    if (root.left != null) {\n        if (!map.containsKey(root.left.val)) {\n            map.put(root.left.val, new ArrayList&lt;TreeNode&gt;());\n        }\n        map.get(root.val).add(root.left);\n        map.get(root.left.val).add(root);\n        helper(map, root.left, k);\n    }\n    if (root.right != null) {\n        if (!map.containsKey(root.right.val)) {\n            map.put(root.right.val, new ArrayList&lt;TreeNode&gt;());\n        }\n        map.get(root.val).add(root.right);\n        map.get(root.right.val).add(root);\n        helper(map, root.right, k);\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#redundant-connection","title":"Redundant Connection","text":""},{"location":"data-structure/data-structure-graph-problems/#description-4","title":"Description 4","text":"<p>In this problem, a tree is an undirected graph that is connected and has no cycles.</p> <p>The given input is a graph that started as a tree with N nodes (with distinct values 1, 2, ..., N), with one additional edge added. The added edge has two different vertices chosen from 1 to N, and was not an edge that already existed.</p> <p>The resulting graph is given as a 2D-array of edges. Each element of edges is a pair [u, v] with u &lt; v, that represents an undirected edge connecting nodes u and v.</p> <p>Return an edge that can be removed so that the resulting graph is a tree of N nodes. If there are multiple answers, return the answer that occurs last in the given 2D-array. The answer edge [u, v] should be in the same format, with u &lt; v.</p> <pre><code>Example 1:\nInput: [[1,2], [1,3], [2,3]]\nOutput: [2,3]\nExplanation: The given undirected graph will be like this:\n  1\n / \\\n2 - 3\n\nExample 2:\nInput: [[1,2], [2,3], [3,4], [1,4], [1,5]]\nOutput: [1,4]\nExplanation: The given undirected graph will be like this:\n5 - 1 - 2\n    |   |\n    4 - 3\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#solution-with-graph-dfs","title":"Solution with Graph + DFS","text":"<p>Construct graph with the given edges. During the construction, use DFS to search the target edge.</p> <pre><code>public int[] findRedundantConnection(int[][] edges) {\n    Map&lt;Integer, List&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();\n    for (int[] edge : edges) {\n        if (!map.containsKey(edge[0])) {\n            map.put(edge[0], new ArrayList&lt;Integer&gt;());\n        }\n        if (!map.containsKey(edge[1])) {\n            map.put(edge[1], new ArrayList&lt;Integer&gt;());\n        }\n        Set&lt;Integer&gt; visited = new HashSet&lt;&gt;();\n        if (dfs(map, edge[0], edge[1], visited)) {\n            return edge;\n        }\n        map.get(edge[0]).add(edge[1]);\n        map.get(edge[1]).add(edge[0]);\n    }\n\n    return new int[]{0,0};\n}\n\nprivate boolean dfs(Map&lt;Integer, List&lt;Integer&gt;&gt; map, int start, int target, Set&lt;Integer&gt; visited) {\n\n    if (start == target) {\n        return true;\n    }\n    visited.add(start);\n    if (!map.containsKey(start) || !map.containsKey(target)) {\n        return false;\n    }\n    for (int nei : map.get(start)) {\n        if (visited.contains(nei)) {\n            continue;\n        }\n        if (dfs(map, nei, target, visited)) {\n            return true;\n        }\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#solution-with-union-find","title":"Solution with Union Find","text":"<p>Create parents array, go through each edge, find and union them until find the target edge.</p> <pre><code>public int[] findRedundantConnection(int[][] edges) {\n    int[] parents = new int[edges.length + 1];\n    for (int i = 0; i &lt; parents.length; i++) {\n        parents[i] = i;\n    }\n\n    for (int[] edge : edges) {\n        int u = edge[0];\n        int v = edge[1];\n        int pu = find(u, parents);\n        int pv = find(v, parents);\n        if (pu == pv) {\n            return edge;\n        }\n        parents[pv] = pu;\n    }\n\n    return new int[] {0,0};\n}\n\nprivate int find(int curr, int[] parents) {\n    while (parents[curr] != curr) {\n        parents[curr] = parents[parents[curr]];\n        curr = parents[curr];\n    }\n\n    return curr;\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#solution-with-union-find-template","title":"Solution With Union Find Template","text":"<pre><code>class DSU {\n    int[] rank;\n    int[] parent;\n    public DSU(int size) {\n        parent = new int[size];\n        for (int i = 0; i &lt; size; i++) {\n            parent[i] = i;\n        }\n        rank = new int[size];\n    }\n\n    public int find(int i) {\n        while (parent[i] != i) {\n            parent[i] = parent[parent[i]];\n            i = parent[i];\n        }\n        return parent[i];\n    }\n\n    public boolean union(int i, int j) {\n        int p1 = find(i);\n        int p2 = find(j);\n        if (p1 == p2) { // found\n            return false;\n        } else if (rank[p1] &lt; rank[p2]) {\n            parent[p1] = p2;\n        } else if (rank[p1] &gt; rank[p1]) {\n            parent[p2] = p1;\n        } else {\n            parent[p2] = p1;\n            rank[p1]++;\n        }\n        return true;\n    }\n}\n\npublic int[] findRedundantConnection(int[][] edges) {\n    DSU dsu = new DSU(edges.length + 1);\n    for (int[] edge: edges) {\n        if (!dsu.union(edge[0], edge[1])) {\n            return edge;\n        }\n    }\n    return new int[] {0,0};\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph-problems/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 200 - Number of Islands</li> <li>LeetCode 934 - Shortest Bridge</li> <li>LeetCode 742 - Closest Leaf in a Binary Tree</li> <li>LeetCode 684 - Redundant Connection</li> </ul>"},{"location":"data-structure/data-structure-graph/","title":"Data Structure - Graph","text":"<p>Implement undirected graph.</p>"},{"location":"data-structure/data-structure-graph/#definition-of-graph","title":"Definition of Graph","text":"<p>Graph is a data structure that consists of following two components: <code>vertex</code> and <code>edge</code>.</p> <ul> <li>A finite set of vertices, also called as nodes.</li> <li>A finite set of ordered pair of the form (u, v), also called as edge. The pair is ordered because (u, v) is not same as (v, u) in case of a directed graph(di-graph). The pair of the form (u, v) indicates that there is an edge from vertex u to vertex v. The edges may contain weight/value/cost.</li> </ul> <p>Following is an example of an undirected graph with 5 vertices. </p>"},{"location":"data-structure/data-structure-graph/#graph-features","title":"Graph Features","text":"<ul> <li>Graphs can be either <code>directed</code> or <code>undirected</code>. While directed edges are like a one-way street, undirected edges are like a two-way street.</li> <li>Graph might consist of multiple isolated subgraphs. If there is a path between every pair of vertices, it is called a 'connected graph'.</li> <li>Graph can also have cycles (or not). An 'acyclic graph' is one without cycles.</li> </ul>"},{"location":"data-structure/data-structure-graph/#implementation-of-graph","title":"Implementation of Graph","text":"<p>There are two most common ways to implement graph:</p> <ul> <li>Adjacency Matrix</li> <li>Adjacency List</li> </ul>"},{"location":"data-structure/data-structure-graph/#adjacency-matrix","title":"Adjacency Matrix","text":"<p>Adjacency Matrix is a 2D array of size V x V where <code>V</code> is the number of vertices in a graph. Let the 2D array be matrix[][], a slot <code>matrix[i][j] = 1</code> indicates that there is an edge from vertex <code>i</code> to vertex <code>j</code>. Adjacency matrix for undirected graph is always symmetric. Adjacency Matrix is also used to represent weighted graphs. If <code>matrix[i][j] = w</code>, then there is an edge from vertex i to vertex j with weight w.</p> <p>The adjacency matrix for the above example graph is: </p> <ul> <li>Pros: Representation is easier to implement and follow. Removing an edge takes $O(1)$ time. Queries like whether there is an edge from vertex \u2018u\u2019 to vertex \u2018v\u2019 are efficient and can be done $O(1)$.</li> <li>Cons: Consumes more space $O(V^2)$. Even if the graph is sparse(contains less number of edges), it consumes the same space. Adding a vertex is $O(V^2)$ time, as you have to rebuild the matrix.</li> </ul> <p>Below is the sample code which implements Graph with Adjacency Matrix.</p> <pre><code>public class Vertex {\n    public int index;\n    public String name;\n    public boolean visited;\n\n    public Vertex(int index, String name) {\n        this.index = index;\n        this.name = name;\n        this.visited = false;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n\npublic class AdjMatrixGraph {\n    private int[][] matrix;    // adjacency matrix\n    private Vertex[] vertices; // array of vertices\n    private int size;          // current number of vertices\n\n    public AdjMatrixGraph(int capacity)\n    {\n        matrix = new int[capacity][capacity];\n        vertices = new Vertex[capacity];\n        size = 0;\n\n        // initialize matrix\n        for (int i = 0; i &lt; capacity; i++) {\n            for (int j = 0; j &lt; capacity; j++) {\n                matrix[i][j] = 0;\n            }\n        }\n    }\n\n    public void addVertex(String name) {\n        int index = size++;\n        vertices[index] = new Vertex(index, name);\n    }\n\n    public void addEdge(int start, int end) {\n        matrix[start][end] = 1;\n        matrix[end][start] = 1;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph/#adjacency-list","title":"Adjacency List","text":"<p>Adjacency List an array of lists. Size of the array is equal to the number of vertices. Let the array be vertexList[]. An entry <code>vertexList[i]</code> represents the list of vertices adjacent to the $i^{th}$ vertex.</p> <p>Following is adjacency list representation of the above graph. </p> <ul> <li>Pros: Saves space. Generally, it takes $O(V+2E)$, V is number of vertices and E is the number of edges. In the worst case, there can be $V^2$ number of edges in a graph(Every vertex connects to all other vertices) thus consuming $O(V^2)$ space. Adding a vertex is easier, just append a new node into the vertex list.</li> <li>Cons: Queries like whether there is an edge from vertex u to vertex v are not efficient and can be done $O(V)$, as you have to search one by one in the vertex list.</li> </ul> <p>Below is the sample code which implements Graph with Adjacency List.</p> <pre><code>public class AdjListGraph {\n    private LinkedList&lt;Vertex&gt;[] vertexList; // list of adjacency vertex\n    private Vertex[] vertices;               // array of vertices\n    private int size;                        // current number of vertices\n\n    public AdjListGraph(int capacity)\n    {\n        vertexList = new LinkedList[capacity];\n        vertices = new Vertex[capacity];\n        size = 0;\n\n        // initialize array\n        for (int i = 0; i&lt; vertexList.length; i++) {\n            vertexList[i] = new LinkedList&lt;Vertex&gt;();\n        }\n    }\n\n    public void addVertex(String name) {\n        int index = size++;\n        vertices[index] = new Vertex(index, name);\n    }\n\n    public void addEdge(int start, int end) {\n        vertexList[start].add(vertices[end]);\n        vertexList[end].add(vertices[start]);\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph/#search-in-graph","title":"Search In Graph","text":""},{"location":"data-structure/data-structure-graph/#search-approaches","title":"Search Approaches","text":"<p>There are two common approaches to search a graph:</p> <ul> <li>Depth-First Search: <code>DFS</code> is implemented with a <code>stack</code>.</li> <li>Breadth-First Search: <code>BFS</code> is implemented with a <code>queue</code>.</li> </ul> <p>Depth-First Search(DFS)</p> <ul> <li>Rule 1: If possible, visit an adjacent unvisited vertex, mark it, and push it on the stack.</li> <li>Rule 2: If you can\u2019t follow Rule 1, then, if possible, pop a vertex off the stack.</li> <li>Rule 3: If you can\u2019t follow Rule 1 or Rule 2, you\u2019re done.</li> </ul> <p>Breadth-First Search(BFS)</p> <ul> <li>Rule 1: Visit the next unvisited vertex (if there is one) that\u2019s adjacent to the current vertex, mark it, and insert it into the queue.</li> <li>Rule 2: If you can\u2019t carry out Rule 1 because there are no more unvisited vertices, remove a vertex from the queue (if possible) and make it the current vertex.</li> <li>Rule 3: If you can\u2019t carry out Rule 2 because the queue is empty, you\u2019re done.</li> </ul>"},{"location":"data-structure/data-structure-graph/#search-in-adjacency-matrix-graph","title":"Search In Adjacency Matrix Graph","text":"<p>Given the above graph, the below dfs method returns [A, B, C, D, E] and the bfs method returns [A, B, E, C, D].</p> <pre><code>// dfs\nprivate Stack&lt;Vertex&gt; stack = new Stack&lt;Vertex&gt;();\npublic String[] dfs() {\n    String[] res = new String[size];\n    vertices[0].visited = true;\n    int idx = 0;\n    res[idx++] = vertices[0].name;\n    stack.push(vertices[0]);\n    while (!stack.isEmpty()) {\n        int index = getUnvisitedVertex(stack.peek().index);\n        if (index == -1) { // no unvisited neighbor\n            stack.pop();\n        } else {\n            vertices[index].visited = true;\n            res[idx++] = vertices[index].name;\n            stack.push(vertices[index]);\n        }\n    }\n\n    // reset vertices\n    for (Vertex vertex : vertices) {\n        vertex.visited = false;\n    }\n\n    return res;\n}\n\n// bfs\nprivate Queue&lt;Vertex&gt; queue = new LinkedList&lt;Vertex&gt;();\npublic String[] bfs() {\n    String[] res = new String[size];\n    vertices[0].visited = true;\n    int idx = 0;\n    res[idx++] = vertices[0].name;\n    queue.add(vertices[0]);\n    while (!queue.isEmpty() ) {\n        Vertex vertex = queue.poll();\n        int nextIdx = getUnvisitedVertex(vertex.index);\n        while (nextIdx != -1) {\n            vertices[nextIdx].visited = true;\n            res[idx++] = vertices[nextIdx].name;\n            queue.add(vertices[nextIdx]);\n            nextIdx = getUnvisitedVertex(vertex.index);\n        }\n    }\n\n    // reset vertices\n    for (Vertex vertex : vertices) {\n        vertex.visited = false;\n    }\n\n    return res;\n}\n\nprivate int getUnvisitedVertex(int index) {\n    for (int i = 0; i &lt; size; i++) {\n        if (matrix[index][i] == 1 &amp;&amp; vertices[i].visited == false) {\n            return i;\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph/#search-in-adjacency-list-graph","title":"Search In Adjacency List Graph","text":"<p>Given the above graph, the below dfs method returns [A, B, C, D, E] and the bfs method returns [A, B, E, C, D].</p> <pre><code>// dfs\nprivate Stack&lt;Vertex&gt; stack = new Stack&lt;Vertex&gt;();\npublic String[] dfs() {\n    String[] res = new String[size];\n    vertices[0].visited = true;\n    int idx = 0;\n    res[idx++] = vertices[0].name;\n    stack.push(vertices[0]);\n    while (!stack.isEmpty()) {\n        int index = getUnvisitedVertex(stack.peek().index);\n        if (index == -1) { // no unvisited neighbor\n            stack.pop();\n        } else {\n            vertices[index].visited = true;\n            res[idx++] = vertices[index].name;\n            stack.push(vertices[index]);\n        }\n    }\n\n    // reset vertices\n    for (Vertex vertex : vertices) {\n        vertex.visited = false;\n    }\n    return res;\n}\n\n// bfs\nprivate Queue&lt;Vertex&gt; queue = new LinkedList&lt;Vertex&gt;();\npublic String[] bfs() {\n    String[] res = new String[size];\n    vertices[0].visited = true;\n    int idx = 0;\n    res[idx++] = vertices[0].name;\n    queue.add(vertices[0]);\n    while (!queue.isEmpty() ) {\n        Vertex vertex = queue.poll();\n        int nextIdx = getUnvisitedVertex(vertex.index);\n        while (nextIdx != -1) {\n            vertices[nextIdx].visited = true;\n            res[idx++] = vertices[nextIdx].name;\n            queue.add(vertices[nextIdx]);\n            nextIdx = getUnvisitedVertex(vertex.index);\n        }\n    }\n\n    // reset vertices\n    for (Vertex vertex : vertices) {\n        vertex.visited = false;\n    }\n\n    return res;\n}\n\nprivate int getUnvisitedVertex(int index) {\n    for (int i = 0; i &lt; vertexList[index].size(); i++) {\n        if (vertexList[index].get(i).visited == false) {\n            return vertexList[index].get(i).index;\n        }\n    }\n    return -1;\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph/#bidirectional-search","title":"Bidirectional Search","text":"<p>Bidirectional search is used to find the shortest path between a source and destination node.</p>"},{"location":"data-structure/data-structure-graph/#node-graph","title":"Node Graph","text":"<p>There is one additional way to represent graph. Graph can be represented with vertex(node) only. The edges are represented with <code>neighbor</code> nodes, stored as a property of the node.</p>"},{"location":"data-structure/data-structure-graph/#implementation","title":"Implementation","text":"<p>Node.</p> <pre><code>public class Node {\n    public String name;\n    public boolean visited;\n    public Node[] neighbors;\n\n    public Node(String name) {\n        this.name = name;\n        this.visited = false;\n    }\n\n    @Override\n    public String toString() {\n        return name;\n    }\n}\n</code></pre> <p>Node Graph.</p> <pre><code>public class NodeGraph {\n    public Node[] nodes;\n\n    public NodeGraph(int size)\n    {\n        nodes = new Node[size];\n    }\n\n    public void addNeighbors(int index, Node[] neighbors) {\n        nodes[index].neighbors = neighbors;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph/#search","title":"Search","text":"<p>Both DFS and BFS approaches can be applied to Node Graph.</p>"},{"location":"data-structure/data-structure-graph/#traverse-all-nodes-in-graph-with-dfs","title":"Traverse all nodes in graph with DFS","text":"<pre><code>// dfs, stack\npublic List&lt;String&gt; dfs(Node root) {\n    List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n    if (root == null) {\n        return ans;\n    }\n    Stack&lt;Node&gt; stack = new Stack&lt;Node&gt;();\n    root.visited = true;\n    ans.add(root.name);\n    stack.push(root);\n    while (!stack.isEmpty()) {\n        Node node = stack.peek();\n        Node neighbor = getUnvisitedNeighbor(node);\n        if (neighbor == null) {\n            stack.pop();\n        } else {\n            neighbor.visited = true;\n            ans.add(neighbor.name);\n            stack.push(neighbor);\n        }\n    }\n\n    return ans;\n}\nprivate Node getUnvisitedNeighbor(Node node) {\n    for (int i = 0; i &lt; node.neighbors.length; i++) {\n        if (node.neighbors[i].visited == false) {\n            return node.neighbors[i];\n        }\n    }\n    return null;\n}\n</code></pre> <p>For the DFS search, we can simplify the implementation without using stack. The dfs2 method calls itself recursively to generate the list.</p> <pre><code>// dfs, recursion\npublic void dfs2(Node root, List&lt;String&gt; list) {\n    if (root == null) {\n        return;\n    }\n    list.add(root.name);\n    root.visited = true;\n    for (Node neighbor : root.neighbors) {\n        if (neighbor.visited == false) {\n            dfs2(neighbor, list);\n        }\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph/#traverse-all-nodes-in-graph-with-bfs","title":"Traverse all nodes in graph with BFS","text":"<pre><code>public List&lt;String&gt; bfs(Node root) {\n    List&lt;String&gt; ans = new ArrayList&lt;&gt;();\n    if (root == null) {\n        return ans;\n    }\n    Queue&lt;Node&gt; queue = new LinkedList&lt;Node&gt;();\n    root.visited = true;\n    ans.add(root.name);\n    queue.offer(root);\n    while (!queue.isEmpty()) {\n        Node node = queue.poll();\n        for (Node neighbor : node.neighbors) {\n            if (neighbor.visited == false) {\n                neighbor.visited = true;\n                ans.add(neighbor.name);\n                queue.offer(neighbor);\n            }\n        }\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"data-structure/data-structure-graph/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 133 - Clone Graph</li> </ul>"},{"location":"data-structure/data-structure-graph/#source-files","title":"Source files","text":"<ul> <li>Source files for Graph on GitHub</li> <li>Graph Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-graph/#reference","title":"Reference","text":"<ul> <li>Data Structure - Graph Data Structure</li> <li>Graph and its representations</li> <li>Breadth First Search or BFS for a Graph</li> <li>Depth First Search or DFS for a Graph</li> <li>Handout of Graphs Greedy</li> </ul>"},{"location":"data-structure/data-structure-hashmap/","title":"Data Structure - HashMap","text":"<p>Implement HashMap with array and linked list.</p>"},{"location":"data-structure/data-structure-hashmap/#concepts-in-hashmapor-hash-table","title":"Concepts in HashMap(or Hash Table)","text":""},{"location":"data-structure/data-structure-hashmap/#hash-code-and-compressor","title":"Hash Code and Compressor","text":"<p><code>Hash code</code> is an Integer number (random or nonrandom). In Java every Object has its own hash code. We will use the hash code generated by JVM in our <code>hash function</code> and to compress the hash code we <code>modulo(%)</code> the hash code by size of the hash table. So modulo operator is <code>compressor</code> in our implementation.</p>"},{"location":"data-structure/data-structure-hashmap/#hash-function","title":"Hash Function","text":"<p><code>Hash function</code> hashes (converts) a number in a large range into a number in a smaller range. This smaller range corresponds to the index numbers in an array.  </p> <pre><code>private int hashFunc(K key) {\n    int hashCode = key.hashCode();\n    int index = hashCode % numBuckets;\n    return index;\n}\n</code></pre>"},{"location":"data-structure/data-structure-hashmap/#collision","title":"Collision","text":"<p>If multiple keys has same hashCode, then collision occurs. Approaches to solve collision:</p> <ul> <li>Open Addressing: move to an empty cell. <code>clustering</code> issue may happen.</li> <li>Separate Chaining: store values in linked list instead of themselves.</li> </ul>"},{"location":"data-structure/data-structure-hashmap/#open-addressing-vs-separate-chaining","title":"Open Addressing Vs Separate Chaining","text":"<p>If open addressing is to be used, double hashing seems to be the preferred system by a small margin over quadratic probing. The exception is the situation in which plenty of memory is available and the data won\u2019t expand after the table is created; in this case linear probing is somewhat simpler to implement and, if load factors below 0.5 are used, causes little performance penalty. If the number of items that will be inserted in a hash table is <code>unknown</code> when the table is created, <code>separate chaining is preferable</code> to open addressing. Increasing the load factor causes major performance penalties in open addressing, but performance degrades only linearly in separate chaining. When in doubt, use separate chaining. Its drawback is the need for a linked list class, but the payoff is that adding more data than you anticipated won\u2019t cause performance to slow to a crawl.</p>"},{"location":"data-structure/data-structure-hashmap/#load-factor-and-rehashing","title":"Load Factor and Rehashing","text":"<p><code>Load Factor</code> is the ratio of the number of items in a hash table to its size. If the total number of buckets is 10 and 7 of them got filled now, the load factor is 7/10=0.7.</p> <p>In our implementation whenever we add a key value pair to the Hash Table we check the load factor if it is greater than 0.7 we double the size of our hash table.</p>"},{"location":"data-structure/data-structure-hashmap/#implementing-hashmap","title":"Implementing HashMap","text":""},{"location":"data-structure/data-structure-hashmap/#structure-of-hashmap","title":"Structure of HashMap","text":"<p>An array list contains Hash Nodes. Each node can have none or multiple descendant nodes. They have the same index, but contains different hashcode.  </p>"},{"location":"data-structure/data-structure-hashmap/#common-operations-for-hashmap","title":"Common Operations for HashMap","text":"<ul> <li>get(key): returns the value corresponding to the key if the key is present in HashMap</li> <li>add(key, value): adds new valid key, value pair to the HashMap, if already present updates the value</li> <li>remove(key): removes the key, value pair</li> <li>size(): return the size of the HashMap</li> <li>isEmpty(): returns true if size is zero</li> </ul>"},{"location":"data-structure/data-structure-hashmap/#time-complexity","title":"Time Complexity","text":"<ul> <li>get: $O(1)$</li> <li>add: $O(1)$</li> <li>remove: $O(1)$</li> </ul>"},{"location":"data-structure/data-structure-hashmap/#hashnode","title":"HashNode","text":"<p>HashNode is a storage unit for storing date. It has the <code>next</code> attribute pointing to the next hashnode, behaves like a linked list.</p> <pre><code>public class HashNode&lt;K, V&gt; {\n    public K key;\n    public V val;\n    public HashNode&lt;K, V&gt; next;\n    public HashNode(K key, V val) {\n        this.key = key;\n        this.val = val;\n        this.next = null;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-hashmap/#implementation-of-hashmap","title":"Implementation of HashMap","text":"<p>Generic HashMap.</p> <pre><code>public class HashMap&lt;K, V&gt; {\n    // bucketArray is used to store array of chains\n    private ArrayList&lt;HashNode&lt;K, V&gt;&gt; bucketList;\n    // Current capacity of array list\n    private int numBuckets;\n    // Current size of array list\n    private int size;\n\n    // Constructor (Initializes capacity, size and empty chains.\n    public HashMap() {\n        bucketList = new ArrayList&lt;&gt;();\n        numBuckets = 10;\n        size = 0;\n\n        // Create empty chains\n        for (int i = 0; i &lt; numBuckets; i++) {\n            bucketList.add(null);\n        }\n    }\n\n    public int size() {\n        return size;\n    }\n\n    public boolean isEmpty() {\n        return size() == 0;\n    }\n\n    // Returns value for a key\n    public V get(K key) {\n        // Find head of chain for given key\n        int bucketIndex = hashFunc(key);\n        HashNode&lt;K, V&gt; head = bucketList.get(bucketIndex);\n\n        // Search key in chain\n        while (head != null) {\n            if (head.key.equals(key)) {\n                return head.val;\n            }\n            head = head.next;\n        }\n\n        // If key not found\n        return null;\n    }\n\n    // Adds a key value pair to hash\n    public void add(K key, V value) {\n        // Find head of chain for given key\n        int bucketIndex = hashFunc(key);\n        HashNode&lt;K, V&gt; head = bucketList.get(bucketIndex);\n\n        // Check if key is already present\n        while (head != null) {\n            if (head.key.equals(key)) {\n                head.val = value;\n                return;\n            }\n            head = head.next;\n        }\n\n        // Insert key in chain\n        size++;\n        head = bucketList.get(bucketIndex);\n        HashNode&lt;K, V&gt; newNode = new HashNode&lt;K, V&gt;(key, value);\n        newNode.next = head; // add to header\n        bucketList.set(bucketIndex, newNode);\n\n        // If load factor goes beyond threshold, then double hash table size\n        if ((1.0*size)/numBuckets &gt;= 0.7) {\n            ArrayList&lt;HashNode&lt;K, V&gt;&gt; tempList = bucketList;\n            bucketList = new ArrayList&lt;&gt;();\n            numBuckets = 2 * numBuckets; // double the capacity\n            size = 0;\n            for (int i = 0; i &lt; numBuckets; i++) {\n                bucketList.add(null);\n            }\n\n            for (HashNode&lt;K, V&gt; headNode : tempList) { // traverse array\n                while (headNode != null) { // traverse each linked list\n                    add(headNode.key, headNode.val);\n                    headNode = headNode.next;\n                }\n            }\n        }\n    }\n\n    // Method to remove a given key\n    public V remove(K key) {\n        // Apply hash function to find index for given key\n        int bucketIndex = hashFunc(key);\n\n        // Get head of chain\n        HashNode&lt;K, V&gt; head = bucketList.get(bucketIndex);\n\n        // Search for key in its chain\n        HashNode&lt;K, V&gt; prev = null;\n        while (head != null) {\n            // If Key found\n            if (head.key.equals(key)) {\n                break;\n            }\n\n            // Else keep moving in chain\n            prev = head;\n            head = head.next;\n        }\n\n        // If key was not there\n        if (head == null) {\n            return null;\n        }\n\n        // Reduce size\n        size--;\n\n        // Remove key\n        if (prev != null) {\n            prev.next = head.next;\n        } else {\n            bucketList.set(bucketIndex, head.next);\n        }\n\n        return head.val;\n    }\n\n    // hash function\n    private int hashFunc(K key) {\n        int hashCode = key.hashCode();\n        int index = hashCode % numBuckets;\n        return index;\n    }\n}\n</code></pre> <p>Integer type, implemented with node.</p> <pre><code>class MyHashMap {\n    class HashNode {\n        int key, val;\n        HashNode next;\n\n        HashNode(int key, int val) {\n            this.key = key;\n            this.val = val;\n        }\n    }\n    HashNode[] bucket;\n    /** Initialize your data structure here. */\n    public MyHashMap() {\n        bucket = new HashNode[1000000];\n    }\n\n    /** value will always be non-negative. */\n    public void put(int key, int value) {\n        int hash = hashFunc(key);\n        if (bucket[hash] == null) {\n            bucket[hash] = new HashNode(key, value);\n        } else {\n            HashNode header = bucket[hash];\n            while (header != null &amp;&amp; header.next != null) {\n                if (header.key == key) {\n                    header.val = value;\n                    return;\n                }\n                header = header.next;\n            }\n            if (header.key == key) {\n                header.val = value;\n            } else {\n                header.next = new HashNode(key, value);\n            }\n        }\n    }\n\n    /** Returns the value to which the specified key is mapped, or -1 if this map contains no mapping for the key */\n    public int get(int key) {\n        int hash = hashFunc(key);\n        if (bucket[hash] == null) {\n            return -1;\n        } else {\n            HashNode header = bucket[hash];\n            while (header != null) {\n                if (header.key == key) {\n                    return header.val;\n                }\n                header = header.next;\n            }\n            return -1;\n        }\n    }\n\n    /** Removes the mapping of the specified value key if this map contains a mapping for the key */\n    public void remove(int key) {\n        int hash = hashFunc(key);\n        if (bucket[hash] == null) {\n            return;\n        } else {\n            HashNode dummy = new HashNode(0, 0);\n            dummy.next = bucket[hash];\n            HashNode prev = dummy;\n            HashNode curr = dummy.next;\n            while (curr != null) {\n                if (curr.key == key) {\n                    prev.next = curr.next;\n                    break;\n                }\n                curr = curr.next;\n                prev = prev.next;\n            }\n            bucket[hash] = dummy.next;\n        }\n    }\n\n    private int hashFunc(int key) {\n        return key % 1000000;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-hashmap/#implementation-of-hashset","title":"Implementation of HashSet","text":"<p>Implemented with node.</p> <pre><code>public class MyHashSet {\n    class HashNode {\n        int key;\n        HashNode next;\n\n        HashNode(int key) {\n            this.key = key;\n        }\n    }\n\n    HashNode[] bucket;\n    public MyHashSet() {\n        bucket = new HashNode[1000000];\n    }\n\n    public void add(int key) {\n        int hash = hashFunc(key);\n        if (bucket[hash] == null) {\n            bucket[hash] = new HashNode(key);\n        } else {\n            HashNode header = bucket[hash];\n            while (header != null) {\n                if (header.key == key) {\n                    return;\n                }\n                if (header.next == null) {\n                    header.next = new HashNode(key);\n                } else {\n                    header = header.next;\n                }\n            }\n        }\n    }\n\n    public void remove(int key) {\n        int hash = hashFunc(key);\n        if (bucket[hash] == null) {\n            return;\n        } else {\n            HashNode dummy = new HashNode(0);\n            dummy.next = bucket[hash];\n            HashNode prev = dummy;\n            HashNode curr = dummy.next;\n            while (curr != null) {\n                if (curr.key == key) {\n                    prev.next = curr.next;\n                    break;\n                }\n                curr = curr.next;\n                prev = prev.next;\n            }\n            bucket[hash] = dummy.next;\n        }\n    }\n\n    public boolean contains(int key) {\n        int hash = hashFunc(key);\n        if (bucket[hash] == null) {\n            return false;\n        } else {\n            HashNode header = bucket[hash];\n            while (header != null) {\n                if (header.key == key) {\n                    return true;\n                }\n                header = header.next;\n            }\n            return false;\n        }\n    }\n\n    private int hashFunc(int key) {\n        return key % 1000000;\n    }\n}\n</code></pre> <p>Implemented with array.</p> <pre><code>public class MyHashSet {\n    int[] arr;\n    private int capacity = 1000000;\n\n    // Initialize your data structure here.\n    public MyHashSet() {\n        arr = new int[capacity];\n        // Create empty chains\n        for (int i = 0; i &lt; capacity; i++) {\n            arr[i] = Integer.MIN_VALUE;\n        }\n    }\n\n    public void add(int key) {\n        int hash = hashFunc(key);\n        arr[hash] = key;\n    }\n\n    public void remove(int key) {\n        int hash = hashFunc(key);\n        if (arr[hash] == key) {\n            arr[hash] = Integer.MIN_VALUE;\n        }\n    }\n\n    public boolean contains(int key) {\n        int hash = hashFunc(key);\n        return arr[hash] != Integer.MIN_VALUE;\n    }\n\n    // hash function\n    private int hashFunc(int key) {\n        return key % capacity;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-hashmap/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 1 - Two Sum</li> <li>LeetCode 128 - Longest Consecutive Sequence</li> </ul>"},{"location":"data-structure/data-structure-hashmap/#source-files","title":"Source files","text":"<ul> <li>Source files for HashMap on GitHub</li> <li>HashMap Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-hashmap/#reference","title":"Reference","text":"<ul> <li>Java.util.HashMap in Java</li> <li>Implementing our Own Hash Table with Separate Chaining in Java</li> <li>HashMap vs. TreeMap vs. HashTable vs. LinkedHashMap</li> </ul>"},{"location":"data-structure/data-structure-heap/","title":"Data Structure - Heap","text":"<p>Implement heap with array.</p>"},{"location":"data-structure/data-structure-heap/#definition-of-heap","title":"Definition of Heap","text":"<p>A heap is a binary tree with these characteristics:</p> <ul> <li>It\u2019s complete. This means it\u2019s completely filled in, reading from left to right across each row, although the last row need not be full.</li> <li>It\u2019s (usually) implemented as an array. Binary trees can be stored in arrays, rather than using references to connect the nodes.</li> <li>Each node in a heap satisfies the <code>heap condition</code>, which states that every node\u2019s key is larger/smaller than the keys of its children.</li> </ul> <p> </p>"},{"location":"data-structure/data-structure-heap/#types-of-heap","title":"Types of Heap","text":"<ul> <li>Max Heap - The value of each node is less than the value of its parent, with the maximum-value element at the root.</li> <li>Min Heap - The value of each node is greater than the value of its parent, with the minimum-value element at the root.</li> </ul>"},{"location":"data-structure/data-structure-heap/#common-operations-on-heap","title":"Common Operations on Heap","text":"<ul> <li>Insertion - Insert a new value to heap.</li> <li>Removal - Remove and return the root.</li> <li>Get - Get the value of root.</li> </ul>"},{"location":"data-structure/data-structure-heap/#time-complexity","title":"Time Complexity","text":"<ul> <li>Insertion - $O(\\log{}n)$</li> <li>Removal - $O(\\log{}n)$</li> <li>Get - $O(1)$</li> </ul>"},{"location":"data-structure/data-structure-heap/#efficiency-of-heap-operations","title":"Efficiency of Heap Operations","text":"<p>A heap is a special kind of binary tree, the number of levels <code>L</code> in a binary tree equals $\\log_{2}(N+1)$, where N is the number of nodes. The <code>bubble up</code> and <code>bubble down</code> routines cycle through their loops L-1 times, so the first takes time proportional to $\\log_{2}N$, and the second somewhat more because of the extra comparison. Thus, the heap operations we\u2019ve talked about here all operate in $O(\\log{}N)$ time.</p>"},{"location":"data-structure/data-structure-heap/#elements-sequence","title":"Elements Sequence","text":"<p>If you remove a node and then insert the same node, the result is <code>not</code> necessarily the restoration of the original heap. A given set of nodes can be arranged in <code>many</code> valid heaps, depending on the <code>order</code> in which nodes are inserted.</p>"},{"location":"data-structure/data-structure-heap/#heap-implementation","title":"Heap Implementation","text":""},{"location":"data-structure/data-structure-heap/#array-heap","title":"Array Heap","text":"<p>Heap can be implemented with array. A heap is a complete binary tree implies that there are no \u201choles\u201d in the array used to represent it. The traversal method use to achieve array representation is <code>Level Order</code>.  </p>"},{"location":"data-structure/data-structure-heap/#index-relationship","title":"Index Relationship","text":"<p>For a node at index <code>i</code> in the array,</p> <ul> <li>Its parent is (i - 1) / 2.</li> <li>Its left child is 2 * i + 1.</li> <li>Its right child is 2 * i + 2.</li> </ul>"},{"location":"data-structure/data-structure-heap/#max-heap","title":"Max Heap","text":"<p>A max-heap is a complete binary tree where each node is larger than its children. The root, therefore, is the maximum element in the heap.</p>"},{"location":"data-structure/data-structure-heap/#insertion","title":"Insertion","text":"<p>Insertion means add new element to the heap. Initially, the new element is placed in the first open position at the end of the array. Insertion increases the array size by one. Here are the steps for adding the new element to max heap:</p> <ul> <li>1) Add new node to bottom, rightmost.</li> <li>2) Compare the value of this node with its parent. If value of parent is less than child, then swap them.</li> <li>3) Repeat step 2) to bubble up this new node to maintain the heap condition if possible; otherwise, stop.</li> </ul> <p></p>"},{"location":"data-structure/data-structure-heap/#removal","title":"Removal","text":"<p>Removal means removing the node with the maximum key. This node is always the root. Removing decreases the array size by one. Here are the steps for removing the maximum node:</p> <ul> <li>1) Remove the root node.</li> <li>2) Move the last element(bottom, rightmost) to root.  </li> <li>3) Compare the value of this child with its parent. If value of parent is less than child, then swap them.</li> <li>4) Repeat step 3) to bubble down this node to maintain the heap condition if possible; otherwise, stop.  </li> </ul> <p></p>"},{"location":"data-structure/data-structure-heap/#implementing-maxheap","title":"Implementing MaxHeap","text":"<p>The following code is the implementation of max heap with type integer.</p> <pre><code>public class MaxHeap {\n    private int capacity = 10;\n    protected Integer[] array;\n    protected int size;\n\n    public MaxHeap () {\n        array = new Integer[capacity];\n        size = 0;\n    }\n\n    public MaxHeap (int capacity) {\n        this.capacity = capacity;\n        array = new Integer[capacity];\n        size = 0;\n    }\n\n    // add new element into heap\n    public void add(int value) {\n        if (size &gt;= array.length - 1) {\n            array = this.resize();\n        }\n\n        // place element into heap at bottom (right most)\n        array[size] = value;\n        size++;\n\n        bubbleUp();\n    }\n\n    // bubble up the last node with it's parent until they are in the order of max heap\n    protected void bubbleUp() {\n        int index = this.size - 1;  // last node (right most)\n\n        while (hasParent(index) &amp;&amp; (parent(index) &lt; array[index])) {\n            // parent and child are out of order; swap them\n            swap(index, parentIndex(index));\n            index = parentIndex(index);\n        }\n    }\n\n\n    // remove and return the maximum element in the heap\n    public int remove() {\n        if (this.isEmpty()) {\n            throw new IllegalStateException();\n        }\n        // get the root, which is the maximum value\n        int result = peek();\n\n        // move the last leaf to root\n        array[0] = array[size - 1];\n        array[size - 1] = null;\n        size--;\n\n        bubbleDown();\n\n        return result;\n    }\n\n    // bubble down the new root to proper position to maintain the order of max heap\n    protected void bubbleDown() {\n        // root\n        int index = 0;\n\n        // heap is complete tree, so it's safe to check left child first\n        while (hasLeftChild(index)) {\n            int biggerChild = leftIndex(index);\n\n            // find the smaller child\n            if (hasRightChild(index)\n                &amp;&amp; array[leftIndex(index)] &lt; (array[rightIndex(index)])) {\n                biggerChild = rightIndex(index);\n            }\n\n            if (array[index] &gt; array[biggerChild]) {\n                break;\n            } else {\n                // parent and child are out of order; swap them\n                swap(index, biggerChild);\n                index = biggerChild;\n            }\n        }\n    }\n\n    // get the root without removing it from heap\n    public int peek() {\n        if (this.isEmpty()) {\n            throw new IllegalStateException();\n        }\n\n        return array[0];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    protected boolean hasParent(int i) {\n        return i &gt; 0;\n    }\n\n    protected int leftIndex(int i) {\n        return 2 * i + 1;\n    }\n\n    protected int rightIndex(int i) {\n        return 2 * i + 2;\n    }\n\n    protected boolean hasLeftChild(int i) {\n        return leftIndex(i) &lt;= size - 1;\n    }\n\n    protected boolean hasRightChild(int i) {\n        return rightIndex(i) &lt;= size - 1;\n    }\n\n    protected int parent(int i) {\n        return array[parentIndex(i)];\n    }\n\n    protected int parentIndex(int i) {\n        return (i - 1) / 2;\n    }\n\n    protected Integer[] resize() {\n        return Arrays.copyOf(array, array.length * 2);\n    }\n\n    protected void swap(int index1, int index2) {\n        int tmp = array[index1];\n        array[index1] = array[index2];\n        array[index2] = tmp;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-heap/#min-heap","title":"Min Heap","text":"<p>A min-heap is a complete binary tree where each node is smaller than its children. The root, therefore, is the minimum element in the heap.</p>"},{"location":"data-structure/data-structure-heap/#implementing-minheap","title":"Implementing MinHeap","text":"<p>The following code is the implementation of max heap with type integer. The only difference with max heap is the comparison.</p> <pre><code>public class MinHeap {\n    private int capacity = 10;\n    protected Integer[] array;\n    protected int size;\n\n    public MinHeap () {\n        array = new Integer[capacity];\n        size = 0;\n    }\n\n    public MinHeap (int capacity) {\n        this.capacity = capacity;\n        array = new Integer[capacity];\n        size = 0;\n    }\n\n    // add new element into heap\n    public void add(int value) {\n        if (size &gt;= array.length - 1) {\n            array = this.resize();\n        }\n\n        // place element into heap at bottom (right most)\n        array[size] = value;\n        size++;\n\n        bubbleUp();\n    }\n\n    // bubble up the last node with it's parent until they are in the order of max heap\n    protected void bubbleUp() {\n        int index = this.size - 1;  // last node (right most)\n\n        while (hasParent(index) &amp;&amp; (parent(index) &gt; array[index])) {\n            // parent and child are out of order; swap them\n            swap(index, parentIndex(index));\n            index = parentIndex(index);\n        }\n    }\n\n\n    // remove and return the maximum element in the heap\n    public int remove() {\n        if (this.isEmpty()) {\n            throw new IllegalStateException();\n        }\n        // get the root, which is the maximum value\n        int result = peek();\n\n        // move the last leaf to root\n        array[0] = array[size - 1];\n        array[size - 1] = null;\n        size--;\n\n        bubbleDown();\n\n        return result;\n    }\n\n    // bubble down the new root to proper position to maintain the order of max heap\n    protected void bubbleDown() {\n        // root\n        int index = 0;\n\n        // heap is complete tree, so it's safe to check left child first\n        while (hasLeftChild(index)) {\n            int biggerChild = leftIndex(index);\n\n            // find the smaller child\n            if (hasRightChild(index)\n                &amp;&amp; array[leftIndex(index)] &gt; (array[rightIndex(index)])) {\n                biggerChild = rightIndex(index);\n            }\n\n            if (array[index] &lt; array[biggerChild]) {\n                break;\n            } else {\n                // parent and child are out of order; swap them\n                swap(index, biggerChild);\n                index = biggerChild;\n            }\n        }\n    }\n\n    // get the root without removing it from heap\n    public int peek() {\n        if (this.isEmpty()) {\n            throw new IllegalStateException();\n        }\n\n        return array[0];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public int size() {\n        return size;\n    }\n\n    protected boolean hasParent(int i) {\n        return i &gt; 0;\n    }\n\n    protected int leftIndex(int i) {\n        return 2 * i + 1;\n    }\n\n    protected int rightIndex(int i) {\n        return 2 * i + 2;\n    }\n\n    protected boolean hasLeftChild(int i) {\n        return leftIndex(i) &lt;= size - 1;\n    }\n\n    protected boolean hasRightChild(int i) {\n        return rightIndex(i) &lt;= size - 1;\n    }\n\n    protected int parent(int i) {\n        return array[parentIndex(i)];\n    }\n\n    protected int parentIndex(int i) {\n        return (i - 1) / 2;\n    }\n\n    protected Integer[] resize() {\n        return Arrays.copyOf(array, array.length * 2);\n    }\n\n    protected void swap(int index1, int index2) {\n        int tmp = array[index1];\n        array[index1] = array[index2];\n        array[index2] = tmp;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-heap/#heap-sort","title":"Heap Sort","text":"<p>Construct a heap with all numbers, and delete root one by one to get the sorted list.</p>"},{"location":"data-structure/data-structure-heap/#priority-queue","title":"Priority Queue","text":"<p>Priority queues are useful for any application that involves processing elements based on some priority.</p> <p><code>Priority Queue vs Heap</code> A priority queue can be implemented using many of the data structures(Array, Linked List, or Binary Search Tree). However, those data structures do not provide the most efficient operations. To make all of the operations very efficient, we'll use a new data structure called a heap.</p> <p><code>Priority Queue vs TreeMap</code> </p> <ul> <li>PriorityQueue Allows Duplicate(i.e with same priority) while TreeMap doesn't.</li> <li>Complexity of PriorityQueue is O(n)(when is increases its size), while that of TreeMap is O(logn)(as it is based on Red Black Tree)</li> <li>PriorityQueue is based on Array while in TreeMap nodes are linked to each other, so contains method of PriorityQueue would take O(n) time while TreeMap would take O(logn) time.</li> </ul>"},{"location":"data-structure/data-structure-heap/#common-operations-on-priority-queue","title":"Common Operations on Priority Queue","text":"<ul> <li>Add - Insert a new value to priority queue.</li> <li>Poll - Remove and return the maximum/minimum.</li> <li>Peek - Get the maximum/minimum.</li> </ul>"},{"location":"data-structure/data-structure-heap/#time-complexity-of-priority-queue","title":"Time Complexity of Priority Queue","text":"<ul> <li>Add - $O(\\log{}n)$</li> <li>Poll - $O(\\log{}n)$</li> <li>Peek - $O(1)$</li> </ul>"},{"location":"data-structure/data-structure-heap/#max-priority-queue","title":"Max Priority Queue","text":"<pre><code>public class PriorityQueueMax {\n    private MaxHeap heap;\n\n    public PriorityQueueMax() {\n        heap = new MaxHeap();\n    }\n\n    public PriorityQueueMax(int capacity) {\n        heap = new MaxHeap(capacity);\n    }\n\n    public void add(int val) {\n        heap.add(val);\n    }\n\n    public int poll() {\n        return heap.remove();\n    }\n\n    public int peek() {\n        return heap.peek();\n    }\n\n    public boolean isEmpty() {\n        return heap.size == 0;\n    }\n\n    public int size() {\n        return heap.size;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-heap/#min-priority-queue","title":"Min Priority Queue","text":"<pre><code>public class PriorityQueueMin {\n    private MinHeap heap;\n\n    public PriorityQueueMin() {\n        heap = new MinHeap();\n    }\n\n    public PriorityQueueMin(int capacity) {\n        heap = new MinHeap(capacity);\n    }\n\n    public void add(int val) {\n        heap.add(val);\n    }\n\n    public int poll() {\n        return heap.remove();\n    }\n\n    public int peek() {\n        return heap.peek();\n    }\n\n    public boolean isEmpty() {\n        return heap.size == 0;\n    }\n\n    public int size() {\n        return heap.size;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-heap/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 295 - Find Median from Data Stream</li> <li>LeetCode 42 - Trapping Rain Water</li> <li>LintCode 364 - Trapping Rain Water II</li> <li>LeetCode 218 - The Skyline Problem</li> <li>LeetCode 480 - Sliding Window Median</li> </ul>"},{"location":"data-structure/data-structure-heap/#source-files","title":"Source files","text":"<ul> <li>Source files for Heap on GitHub</li> <li>Heap Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-heap/#reference","title":"Reference","text":"<ul> <li>Binary Heaps</li> <li>Binary Heap</li> <li>Heap Data Structures</li> <li>Binary Min-Heap Implementation</li> <li>Difference between a heap and a priority queue</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/","title":"Data Structure - LFU Cache","text":"<p>Implement Least Frequently Used(LFU) cache.</p>"},{"location":"data-structure/data-structure-lfu-cache/#lfu-cache-algorithm","title":"LFU Cache Algorithm","text":"<p>Least Frequently Used(LFU) cache algorithm uses a counter to keep track of how often an entry is accessed. With the LFU cache algorithm, the entry with the lowest count is removed first. This method isn't used that often, as it does not account for an item that had an initially high access rate and then was not accessed for a long time.</p>"},{"location":"data-structure/data-structure-lfu-cache/#how-it-works","title":"How It Works?","text":"<p>The <code>LFU</code> cache provides two methods: <code>add</code> and <code>get</code>.</p> <ul> <li>add(key, value) - Add the value into cache if it is not already present. When the cache reached its capacity, it should invalidate the least frequently used item before inserting a new item. If there is a tie (i.e., two or more keys that have the same frequency), the least recently used key would be evicted.</li> <li>get(key) - If the key doesn't exist in the cache, return the minimum value of Integer. Otherwise, return the value of the key and move this element to the proper position of the cache.</li> </ul> <p>The following diagram illustrates how LFU works. </p>"},{"location":"data-structure/data-structure-lfu-cache/#implementation","title":"Implementation","text":""},{"location":"data-structure/data-structure-lfu-cache/#data-structure","title":"Data Structure","text":"<p>LFU algorithm can be easily implemented with HashMap and Doubly Linked List. </p> <ul> <li>The head and tail nodes don't store any data. They are created just for conveniently manipulating the linked list.</li> <li>Nodes between the head and tail nodes are used to store data, each node for one value. Every node has two pointers, pointing to the previous and the next nodes. Each node has two attributes, one is the value and another is the count of this node.</li> <li>Nodes near the tail are least frequently accessed. They will be removed if cache reaches to its capacity.</li> <li>Nodes in LFU are sorted by frequency(count).</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#operations-on-lfu","title":"Operations On LFU","text":""},{"location":"data-structure/data-structure-lfu-cache/#initialization","title":"Initialization","text":"<ul> <li>Only two dummy nodes, head and tail.</li> <li>Notice that there is another HashMap which stores the value-node pair.</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#add-cache-is-not-full-and-maximum-frequency-0","title":"Add (Cache is not full and maximum frequency = 0)","text":"<ul> <li>Create new node for the given value and insert it to the head of the linked list.</li> <li>Add the new node to HashMap with the given value as key.</li> <li>Size is increased by one.</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#add-cache-is-not-full-and-maximum-frequency-0_1","title":"Add (Cache is not full and maximum frequency &gt; 0)","text":"<ul> <li>Create new node for the given value and insert it before the node which has the same frequency or to the tail.</li> <li>Add the new node to HashMap with the given value as key.</li> <li>Size is increased by one.</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#add-cache-is-full","title":"Add (Cache is full)","text":"<ul> <li>Remove the last element(The one tail.prev is pointing) from the list.</li> <li>Create new node for the given value and insert it before the node which has the same frequency or to the tail.</li> <li>Add the new node to HashMap with the given value as key.</li> <li>Size remains unchanged.</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#get","title":"Get","text":"<ul> <li>Find the given value in HashMap.</li> <li>Increase the frequency of this node by one. Move it to proper position of the linked list.</li> <li>Return the value.</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#built-with-custom-node","title":"Built With Custom Node","text":"<p>The following code is the implementation of LFU based on custom nodes. The node is defined as follows.</p> <pre><code>public class Node {\n    public int value;\n    public int count;\n    public Node prev;\n    public Node next;\n\n    public Node(int value, int count) {\n        this.value = value;\n        this.count = count;\n        this.prev = null;\n        this.next = null;\n    }\n}\n</code></pre> <p>Following is the LFU class which implements the <code>add()</code> and <code>get()</code> methods.</p> <pre><code>public class LFU {\n    private int capacity;\n    private HashMap&lt;Integer, Node&gt; map; // key, node\n    private Node head;                  // The most frequently accessed element\n    private Node tail;                  // The least frequently used element\n    private final int MAX = Integer.MAX_VALUE;\n    private final int MIN = Integer.MIN_VALUE;\n\n    public LFU(int capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap&lt;Integer, Node&gt;();\n        this.head = new Node(this.MAX, this.MAX);\n        this.tail = new Node(this.MIN, this.MIN);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public void add(int key, int value) {\n        if (map.containsKey(key)) {\n            return;\n        }\n\n        if (map.size() == capacity) {\n            map.remove(tail.prev.value);\n            tail.prev = tail.prev.prev;\n            tail.prev.next = tail;\n        }\n\n        Node newNode = new Node(key, 0);\n        map.put(key, newNode);\n\n        // move new node to proper position\n        move(newNode);\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return this.MIN;\n        }\n\n        // remove current\n        Node current = map.get(key);\n        current.prev.next = current.next;\n        current.next.prev = current.prev;\n\n        current.count++; // increment before move\n\n        // move current node to proper position\n        move(current);\n\n        return map.get(key).value;\n    }\n\n    private void move(Node node) {\n        Node curr = head;\n        while (curr != null) {\n            if (curr.count &gt; node.count) {\n                curr = curr.next;\n            } else {\n                node.prev = curr.prev;\n                node.next = curr;\n                node.next.prev = node;\n                node.prev.next = node;\n                break;\n            }\n        }\n    }\n}\n</code></pre> <p>Time complexity:</p> <ul> <li>add() - $O(n)$</li> <li>get() - $O(n)$</li> </ul> <p>Space complexity:</p> <ul> <li>$O(n)$, 2*N, N is the number of nodes</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#testing","title":"Testing","text":"<p>Create an instance of LFU class and call add() and get() methods. The changes of the value and frequency list are described in the inline comments.</p> <pre><code>LFU lfu = new LFU(5); //capacity = 5\nlfu.add(1,1); // value = [1],         frequency = [0]\nlfu.add(2,2); // value = [2,1],       frequency = [0,0]\nlfu.add(3,3); // value = [3,2,1],     frequency = [0,0,0]\nlfu.get(1);   // value = [1,3,2],     frequency = [1,0,0], return 1\nlfu.get(3);   // value = [3,1,2],     frequency = [1,1,0], return 3\nlfu.get(3);   // value = [3,1,2],     frequency = [2,1,0], return 3\nlfu.add(4,4); // value = [3,1,4,2],   frequency = [2,1,0,0]\nlfu.add(5,5); // value = [3,1,5,4,2], frequency = [2,1,0,0,0], cache is full\nlfu.add(6,6); // value = [3,1,6,5,4], frequency = [2,1,0,0,0], last element 2 is removed\nlfu.get(4);   // value = [3,4,1,6,5], frequency = [2,1,1,0,0], return 4\nlfu.add(7,7); // value = [3,4,1,7,6], frequency = [2,1,1,0,0], last element 5 is removed\nlfu.get(7);   // value = [3,7,4,1,6], frequency = [2,1,1,1,0], return 7\nlfu.get(6);   // value = [3,6,7,4,1], frequency = [2,1,1,1,1], return 6\nlfu.get(6);   // value = [6,3,7,4,1], frequency = [2,2,1,1,1], return 6\nlfu.get(6);   // value = [6,3,7,4,1], frequency = [3,2,1,1,1], return 6\nlfu.add(8,8); // value = [6,3,7,4,8], frequency = [3,2,1,1,0], last element 1 is removed\n</code></pre>"},{"location":"data-structure/data-structure-lfu-cache/#optimization","title":"Optimization","text":""},{"location":"data-structure/data-structure-lfu-cache/#implementation-with-custom-node","title":"Implementation With Custom Node","text":"<p>Time complexity can be $O(n)$ in worst case. This is because in the 'move' method, we may have to traverse all the node to find the proper position to insert the given node.</p> <pre><code>private void move(Node node) {\n    Node curr = head;\n    while (curr != null) {\n        if (curr.count &gt; node.count) {\n            curr = curr.next;\n        } else {\n            node.prev = curr.prev;\n            node.next = curr;\n            node.next.prev = node;\n            node.prev.next = node;\n            break;\n        }\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-lfu-cache/#potential-improvement","title":"Potential Improvement","text":"<p>To improve the performance, we have two destinations, $O(\\log{}n)$ or $O(1)$. Use hashmap.</p> <pre><code>public class LFUHashMap {\n    HashMap&lt;Integer, Integer&gt; values;               // key, value\n    HashMap&lt;Integer, Integer&gt; counts;               // key, count\n    HashMap&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; lists; // count, list-&gt;keys\n    int cap;\n    int min = -1;\n    public LFUHashMap(int capacity) {\n        cap = capacity;\n        values = new HashMap&lt;&gt;();\n        counts = new HashMap&lt;&gt;();\n        lists = new HashMap&lt;&gt;();\n        lists.put(0, new LinkedHashSet&lt;&gt;());\n    }\n\n    public void add(int key, int value) {\n        if (cap &lt;= 0) {\n            return;\n        }\n        if (values.containsKey(key)) {\n            values.put(key, value);\n            get(key); // trigger the reorder\n            return;\n        }\n        if (values.size() &gt;= cap) {\n            int evict = lists.get(min).iterator().next();\n            lists.get(min).remove(evict);\n            values.remove(evict);\n            counts.remove(evict);\n        }\n        values.put(key, value);\n        counts.put(key, 0);\n        min = 0;\n        lists.get(0).add(key);\n    }\n\n    public int get(int key) {\n        if (!values.containsKey(key)) {\n            return -1;\n        }\n        int count = counts.get(key);\n        counts.put(key, count + 1);\n        lists.get(count).remove(key);\n        if (count == min &amp;&amp; lists.get(count).size() == 0) {\n            min++;\n        }\n        if (!lists.containsKey(count+1)) {\n            lists.put(count + 1, new LinkedHashSet&lt;&gt;());\n        }\n        lists.get(count + 1).add(key);\n        return values.get(key);\n    }\n}\n</code></pre> <p>Time complexity:</p> <ul> <li>add() - $O(1)$</li> <li>get() - $O(1)$</li> </ul> <p>Space complexity:</p> <ul> <li>$O(n)$, 3*N, N is the number of keys</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#source-files","title":"Source files","text":"<ul> <li>Source files for LFU Cache on GitHub</li> <li>LFU Cache Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-lfu-cache/#reference","title":"Reference","text":"<ul> <li>LFU (Least Frequently Used) Cache Implementation</li> <li>LFU Cache on LeetCode</li> </ul>"},{"location":"data-structure/data-structure-linked-list/","title":"Data Structure - Linked List","text":"<p>A linked list is represented by a sequence of nodes. Each node contains a link to another node. There are two main types of linked list.</p> <ul> <li>Singly Linked List - Each node has only one link, points to the next node.</li> <li>Doubly Linked List - Each node has two links, one points to previous node, another points to the next node.</li> </ul>"},{"location":"data-structure/data-structure-linked-list/#singly-linked-list","title":"Singly Linked List","text":"<p>Each node has an attribute to represent its value. It also has one pointer, linking it to the next node in the linked list. </p>"},{"location":"data-structure/data-structure-linked-list/#doubly-linked-list","title":"Doubly Linked List","text":"<p>Each node has an attribute to represent its value. Meanwhile, it has two pointers, the first pointer links to the next node, and the second pointer links to the previous node. </p>"},{"location":"data-structure/data-structure-linked-list/#implementation","title":"Implementation","text":""},{"location":"data-structure/data-structure-linked-list/#creating-singly-linked-list","title":"Creating Singly Linked List","text":"<p>First, define the structure of <code>SinglyLinkedNode</code>. Each node has an attribute <code>val</code>, storing the value of the node. And it also has one pointer <code>next</code>, storing the address of the next node.</p> SinglyLinkedNode.java<pre><code>public class SinglyLinkedNode {\n    public int val;\n    public SinglyLinkedNode next;\n    public SinglyLinkedNode(int val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n</code></pre> <p>Next, create a class named <code>SinglyLinkedList</code> with one static method <code>create</code>. This method reads values from an array and constructs a list with <code>SinglyLinkedNode</code>. Be aware of the fact that, for the last node, its next is always NULL.</p> SinglyLinkedList.java<pre><code>public class SinglyLinkedList {\n    // create a singly linked list with the given array\n    public static SinglyLinkedNode create(int[] arr) {  \n        if (arr == null || arr.length == 0) {\n            return null;\n        }\n\n        SinglyLinkedNode dummy = new SinglyLinkedNode(0);\n        SinglyLinkedNode curr = dummy;\n        for (int i = 0; i &lt; arr.length; i++) {\n            curr.next = new SinglyLinkedNode(arr[i]);\n            curr = curr.next;\n        }\n\n        return dummy.next;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-linked-list/#creating-doubly-linked-list","title":"Creating Doubly Linked List","text":"<p>First, define the structure of <code>DoublyLinkedNode</code>. Each node has an attribute <code>val</code>, storing the value of the node. And it has two pointers <code>previous</code> and <code>next</code>, storing the addresses of the previous node and the next node.</p> DoublyLinkedNode.java<pre><code>public class DoublyLinkedNode {\n    public int val;\n    public DoublyLinkedNode previous;\n    public DoublyLinkedNode next;\n    public DoublyLinkedNode(int val) {\n        this.val = val;\n        this.previous = null;\n        this.next = null;\n    }\n}\n</code></pre> <p>Next, create a class named <code>DoublyLinkedList</code> with one static method <code>create</code>. This method reads values from an array and constructs a list with <code>DoublyLinkedNode</code>. During creation of DoublyLinkedNode, set its <code>previous</code> and <code>next</code> accordingly.</p> DoublyLinkedList.java<pre><code>public class DoublyLinkedList {\n    // create a doubly linked list with the given array\n    public static DoublyLinkedNode create(int[] arr) {  \n        if (arr == null || arr.length == 0) {\n            return null;\n        }\n\n        DoublyLinkedNode dummy = new DoublyLinkedNode(0);\n        DoublyLinkedNode curr = dummy;\n        for (int i = 0; i &lt; arr.length; i++) {\n            curr.next = new DoublyLinkedNode(arr[i]);\n            curr.next.previous = curr;\n            curr = curr.next;\n        }\n\n        return dummy.next;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-linked-list/#common-operations","title":"Common Operations","text":"<p>Here are some basic approaches for solving linked list problems.</p> <ul> <li>Dummy Node</li> <li>Reversing Linked List</li> <li>Fast and Slow Pointers</li> <li>Find middle node</li> </ul> <p>All below questions/codes are based on singly linked list.  </p>"},{"location":"data-structure/data-structure-linked-list/#reversing-linked-list","title":"Reversing Linked List","text":"<p>Reverse a linked list and return the head of the new reversed list.</p> Reverse a given linked list<pre><code>/**\n * @param head of the original linked list\n * @return reversed linked list\n *\n * Sample\n * Input:  7-&gt;3-&gt;12-&gt;8-&gt;4-&gt;9\n * Output: 9-&gt;4-&gt;8-&gt;12-&gt;3-&gt;7\n *\n */\npublic ListNode reverse(ListNode head) {\n    ListNode prev = null;\n    while (head != null) {\n        ListNode next = head.next;\n        head.next = prev;\n        prev = head;\n        head = next;\n    }\n    return prev;\n}\n</code></pre>"},{"location":"data-structure/data-structure-linked-list/#finding-the-middle-node-in-linked-list","title":"Finding the Middle Node in Linked List","text":"<p>Find the middle node of the given linked list and return it.</p> Find the middle node in a linked list<pre><code>/**\n * @param head of the original linked list\n * @return middle node of the linked list\n *\n * Sample\n * Input:  7-&gt;3-&gt;12-&gt;8-&gt;4\n * Output: 12\n * Input:  7-&gt;3-&gt;12-&gt;8-&gt;4-&gt;9\n * Output: 12\n *\n */\npublic ListNode findMiddle(ListNode head) {\n    if (head == null) {\n        return null;\n    }\n\n    // define fast and slow pointers\n    ListNode fast = head.next;\n    ListNode slow = head;\n    while (fast != null &amp;&amp; fast.next != null) {\n        fast = fast.next.next; // two steps for each pace\n        slow = slow.next;      // one step for each pace\n    }\n\n    return slow;\n}\n</code></pre>"},{"location":"data-structure/data-structure-linked-list/#detecting-cycle-in-linked-list","title":"Detecting Cycle in Linked List","text":"<p>Check whether there is any cycle exists in a given linked list. The below approach adapts the <code>Floyd's Cycle Detection Algorithm</code>, Tortoise &amp; Hare or two pointers.</p> Check whether linked list has any cycle<pre><code>/**\n * @param head of the original linked list\n * @return true if linked list has cycle, otherwise false\n *\n * Sample\n * Input:  7-&gt;3-&gt;12-&gt;8-&gt;4-&gt;9\n * Output: false\n * Input:  7-&gt;3-&gt;12-&gt;8-&gt;4-&gt;9-&gt;12\n * Output: true (12-&gt;8-&gt;4-&gt;9-&gt;12 is the loop)\n *\n */\npublic boolean hasCycle(ListNode head) {\n    if (head == null || head.next == null) {\n        return false;\n    }\n\n    ListNode fast = head.next; // or ListNode fast = head.next\n    ListNode slow = head;\n\n    while (fast != null &amp;&amp; fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n        if (fast == slow) {\n            return true;\n        }\n    }\n\n    return false;\n}\n</code></pre>"},{"location":"data-structure/data-structure-linked-list/#finding-the-node-where-cycle-begins","title":"Finding the Node Where Cycle Begins","text":"<p>Find the node where cycle begins in a given linked list. If there is no cycle, return null.</p> <p>We use the following figure to illustrate the solution. We will use the fast pointer and the slow pointer to solve this problem. </p> <ul> <li>X is the start node of the linked list.</li> <li>Y is the node where the cycle begins. It is the node we are looking for.</li> <li>Z is the node where the fast and slow pointers meet for the first time.</li> <li>For fast pointer, the distance it has walked through is <code>a + b + c + b</code>; for slow pointer, the distance is <code>a + b</code>. Since the speed of fast pointer is twice of the slow pointer, then we have <code>a + b + c + b = 2 * (a + b)</code>. Finally we have <code>a = c</code>.</li> <li>When they meet at node Z, we can put fast pointer to the start node X, and let the slow pointer continue walk in the cycle. This time, we let both pointers move one step each time. When they meet again, they should be at node Y, where the cycle begins.</li> </ul> Find out the node where cycle starts in the linked list<pre><code>/**\n * @param head of the original linked list\n * @return the node where cycle starts in the linked list, otherwise return null\n *\n * Sample\n * Input:  7-&gt;3-&gt;12-&gt;8-&gt;4-&gt;9-&gt;12\n * Output: 12\n * Input:  7-&gt;3-&gt;12-&gt;8-&gt;4\n * Output: null\n *\n */\npublic ListNode detectCycle(ListNode head) {\n    if (head == null) {\n        return null;\n    }\n\n    ListNode fast = head; // ListNode fast = head.next doesn't work\n    ListNode slow = head;\n\n    while (fast != null &amp;&amp; fast.next != null) {\n        fast = fast.next.next;\n        slow = slow.next;\n        if (fast == slow) {\n            fast = head;\n            while (fast != slow) {\n                fast = fast.next;\n                slow = slow.next;\n            }\n            return fast;\n        }\n    }\n\n    return null;\n}\n</code></pre>"},{"location":"data-structure/data-structure-linked-list/#classic-problems","title":"Classic Problems","text":"<ul> <li> <p>LeetCode 83 - Remove Duplicates from Sorted List</p> </li> <li> <p>LeetCode 82 - Remove Duplicates from Sorted List II</p> </li> <li>LeetCode 206 - Reverse Linked List</li> <li>LeetCode 92 - Reverse Linked List II</li> <li>LeetCode 148 - Sort List</li> <li>LeetCode 143 - Reorder List</li> <li>LeetCode 141 - Linked List Cycle</li> <li>LeetCode 26 - Merge k Sorted Lists</li> <li>LeetCode 109 - Convert Sorted List to Binary Search Tree</li> </ul>"},{"location":"data-structure/data-structure-linked-list/#source-files","title":"Source files","text":"<ul> <li> <p>Source files for Linked List on GitHub</p> </li> <li> <p>Linked List Diagrams(draw.io) in Google Drive</p> </li> </ul>"},{"location":"data-structure/data-structure-linked-list/#reference","title":"Reference","text":"<ul> <li> <p>Data Structure and Algorithms - Linked List</p> </li> <li> <p>Linked List</p> </li> <li>Linked List Operations</li> <li>Detecting a Loop in Singly Linked List - Tortoise &amp; Hare</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/","title":"Data Structure - LRU Cache","text":"<p>Implement Least Recently Used(LRU) cache.</p>"},{"location":"data-structure/data-structure-lru-cache/#lru-cache-algorithm","title":"LRU Cache Algorithm","text":"<p>Least Recently Used(LRU) cache algorithm keeps recently used items near the front of cache. Whenever a new item is accessed, the LRU places it at the head of the cache. When the cache reaches to its capacity, items that have been accessed less recently will be removed starting from the end of the cache.</p>"},{"location":"data-structure/data-structure-lru-cache/#how-it-works","title":"How It Works?","text":"<p>The LRU cache provides two methods: <code>put</code> and <code>get</code>.</p> <ul> <li>put(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.</li> <li>get(key) - Get the value of the key and move this item to the head of the cache. If the key doesn't exist in the cache, return -1.</li> </ul> <p>The following diagram illustrates how LRU works.  </p>"},{"location":"data-structure/data-structure-lru-cache/#implementation","title":"Implementation","text":""},{"location":"data-structure/data-structure-lru-cache/#data-structure","title":"Data Structure","text":"<p>Generally, LRU algorithm is implemented with HashMap and Doubly Linked List. </p> <ul> <li>The head and tail nodes don't store any data. They are created just for conveniently manipulating the linked list.</li> <li>Nodes between the head and tail nodes are used to store data, each node for one value. Every node has two pointers, pointing to the previous and the next nodes. They are connected to each other.</li> <li>Nodes near the tail are least recently accessed. They will be removed if cache reaches to its capacity.</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#operations-on-lru","title":"Operations On LRU","text":""},{"location":"data-structure/data-structure-lru-cache/#initialization","title":"Initialization","text":"<ul> <li>Only two dummy nodes, head and tail.</li> <li>Notice that there is another HashMap which stores the value-node pair.</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#put-cache-is-not-full","title":"Put (Cache is not full)","text":"<ul> <li>Create new node for the given value and insert it to the head of the linked list.</li> <li>Put the new node to HashMap with the given value as key.</li> <li>Size is increased by one.</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#put-cache-is-full","title":"Put (Cache is full)","text":"<ul> <li>Remove the last element(The one tail.prev is pointing) from the list.</li> <li>Create new node for the given value and insert it to the head of the linked list.</li> <li>Put the new node to HashMap with the given value as key.</li> <li>Size remains unchanged.</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#get","title":"Get","text":"<ul> <li>Find the given value in HashMap.</li> <li>If the corresponding node is not at the head position of the linked list, move it to head.</li> <li>Update the tail pointers accordingly.</li> <li>Return the value.</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#implementation-with-custom-node","title":"Implementation with Custom Node","text":"<p>The following code is the implementation of LRU based on custom nodes. The node is defined as follows.</p> <pre><code>public class Node {\n    public int key;\n    public int val;\n    public Node prev;\n    public Node next;\n\n    public Node(int key, int val) {\n        this.key = key;\n        this.value = val;\n        this.prev = null;\n        this.next = null;\n    }\n}\n</code></pre> <p>Following is the LRU class which implements the <code>put()</code> and <code>get()</code> methods.</p> <pre><code>public class LRU {\n    private int capacity;\n    private HashMap&lt;Integer, Node&gt; map; // key, node\n    private Node head;                  // The latest accessed element\n    private Node tail;                  // The least recently used element\n\n    public LRU(int capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap&lt;&gt;();\n        this.head = new Node(-1,-1);\n        this.tail = new Node(-1,-1);\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public void put(int key, int val) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.val = val;\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n            moveToHead(node);\n            return;\n        }\n\n        if (map.size() == capacity) {\n            map.remove(tail.prev.key);\n            tail.prev = tail.prev.prev;\n            tail.prev.next = tail;\n        }\n\n        Node node = new Node(key, val);\n        map.put(key, node);\n\n        // move new node to head\n        moveToHead(node);\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n\n        // remove current\n        Node node = map.get(key);\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n\n        // move current node to head\n        moveToHead(node);\n\n        return node.val;\n    }\n\n    private void moveToHead(Node node) {\n        node.prev = head;\n        node.next = head.next;\n        node.next.prev = node;\n        head.next = node;\n    }\n}\n</code></pre> <p>Time complexity:</p> <ul> <li>put() - $O(1)$</li> <li>get() - $O(1)$</li> </ul> <p>Space complexity:</p> <ul> <li>$O(n)$, 2*N, N is the number of nodes</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#implementation-with-deque","title":"Implementation with Deque","text":"<p>Instead of creating the doubly linked list by hand, we can use <code>Deque</code> directly in Java. The following LRUDeque class implements LRU with Deque. The efficiency of the <code>get()</code> method may be $O(n)$ in the worst case.</p> <pre><code>public class LRUDeque {\n    private int capacity;\n    private HashMap&lt;Integer, Integer&gt; map; // key, value\n    private Deque&lt;Integer&gt; deque;          // key\n\n    public LRUDeque(int capacity) {\n        this.capacity = capacity;\n        this.map = new HashMap&lt;&gt;();\n        this.deque = new LinkedList&lt;&gt;();\n    }\n\n    public void put(int key, int val) {\n        if (map.containsKey(key)) {\n            map.put(key, val);\n            // remove current\n            deque.remove(key); // equivalent to removeFirstOccurrence(), performance issue, O(n)\n            // move it to head\n            deque.addFirst(key);\n            return;\n        }\n\n        if (map.size() == capacity) {\n            // remove the least recently used element from map and deque\n            map.remove(deque.removeLast());\n        }\n\n        // add to map\n        map.put(key, val);\n        // add to the head of deque\n        deque.addFirst(key);\n    }\n\n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n\n        // remove current\n        deque.remove(key); // equivalent to removeFirstOccurrence(), performance issue, O(n)\n        // move it to head\n        deque.addFirst(key);\n\n        return map.get(key);\n    }\n}\n</code></pre> <p>Time complexity:</p> <ul> <li>put() - $O(1)$</li> <li>get() - $O(n)$</li> </ul> <p>Space complexity:</p> <ul> <li>$O(n)$, 2*N, N is the number of nodes</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#testing","title":"Testing","text":"<p>Create an instance of LRU class and call put() and get() methods. The change of the list is described in the inline comments.</p> <pre><code>LRU lru = new LRU(5); //capacity = 5\nlru.put(1,1); // values = [1]\nlru.put(2,2); // values = [2,1]\nlru.put(3,3); // values = [3,2,1]\nlru.get(1);   // values = [1,3,2], return 1\nlru.get(3);   // values = [3,1,2], return 3\nlru.get(3);   // values = [3,1,2], return 3\nlru.put(4,4); // values = [4,3,1,2]\nlru.put(5,5); // values = [5,4,3,1,2], cache is full\nlru.put(6,6); // values = [6,5,4,3,1], remove least recently visited element, 2\nlru.get(4);   // values = [4,6,5,3,1], return 4\nlru.put(7,7); // values = [7,4,6,5,3], remove 1\nlru.put(7,2); // values = [2,4,6,5,3], element with key=7 is updated\nlru.get(7);   // keys = [7,4,6,5,3], values = [2,4,6,5,3], return 2\nlru.put(3,9); // keys = [3,7,4,6,5], values = [9,2,4,6,5], move key=3 to head\nlru.get(3);   // keys = [3,7,4,6,5], values = [9,2,4,6,5], return 9\n</code></pre>"},{"location":"data-structure/data-structure-lru-cache/#source-files","title":"Source files","text":"<ul> <li>Source files for LRU Cache on GitHub</li> <li>LRU Cache Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-lru-cache/#reference","title":"Reference","text":"<ul> <li>LRU Cache Implementation</li> <li>LRU Cache on LeetCode</li> </ul>"},{"location":"data-structure/data-structure-minimum-spanning-tree/","title":"Data Structure - Minimum Spanning Tree","text":"<p>Implement minimum spanning tree.</p>"},{"location":"data-structure/data-structure-minimum-spanning-tree/#spanning-tree","title":"Spanning Tree","text":"<p>Spanning tree can be defined as a sub-graph of connected, undirected graph G that is a tree produced by removing the desired number of edges from a graph. In other words, Spanning tree is a non-cyclic sub-graph of a connected and undirected graph G that connects all the vertices together. A graph G can have multiple spanning trees.</p>"},{"location":"data-structure/data-structure-minimum-spanning-tree/#minimum-spanning-tree","title":"Minimum Spanning Tree","text":"<p>There can be weights assigned to every edge in a weighted graph. However, A minimum spanning tree is a spanning tree which has minimal total weight. In other words, minimum spanning tree is the one which contains the least weight among all other spanning tree of some particular graph.</p> <p>Shortest path algorithms In this section of the tutorial, we will discuss the algorithms to calculate the shortest path between two nodes in a graph.</p>"},{"location":"data-structure/data-structure-minimum-spanning-tree/#implementation-of-minimum-spanning-trees","title":"Implementation of Minimum Spanning Trees","text":"<p>A <code>minimum spanning tree</code> (MST) is a graph with the minimum number of edges necessary to connect the vertices.</p> <pre><code>public class MinimumSpanningTree {\n    private int MAX_VERTS = 0;\n    private Vertex[] vertexList; // array of vertices\n    private int[][] adjMatrix; // adjacency matrix\n    private int nVerts; // current number of vertices\n\n    public MinimumSpanningTree(int maxverts)\n    {\n        MAX_VERTS = maxverts; // maximum number of vertices\n        vertexList = new Vertex[MAX_VERTS];\n        adjMatrix = new int[MAX_VERTS][MAX_VERTS];\n        nVerts = 0;\n\n        // initialize matrix\n        for(int i=0; i&lt;MAX_VERTS; i++) {\n            for(int j=0; j&lt;MAX_VERTS; j++) {\n                adjMatrix[i][j] = 0;\n            }\n        }\n    }\n\n    public void addVertex(String label) {\n        int index = nVerts++;\n        vertexList[index] = new Vertex(index, label);\n    }\n\n    public void addEdge(int start, int end) {\n        adjMatrix[start][end] = 1;\n        adjMatrix[end][start] = 1;\n    }\n\n    public Vertex[] getVertices() {\n        return vertexList;\n    }\n\n    public int[][] getAdjMatrix() {\n        return adjMatrix;\n    }\n\n    public void displayVertex(int index) {\n        System.out.print(vertexList[index].name);\n    }\n\n    // mst, similar with dfs\n    private Stack&lt;Vertex&gt; stack = new Stack&lt;Vertex&gt;();\n    public void mst() {\n        vertexList[0].visited = true; // different start vertex leads to different mst.\n        stack.push(vertexList[0]);\n        while (!stack.isEmpty()) {\n            int currentVertex = stack.peek().index;\n            int index = getAdjUnvisitedVertex(currentVertex);\n            if (index == -1) { // no unvisited neighbor\n                stack.pop();\n            } else {\n                vertexList[index].visited = true;\n                stack.push(vertexList[index]);\n                displayVertex(currentVertex);\n                displayVertex(index);\n                System.out.print(\" \");\n            }\n        }\n\n        // reset vertices\n        for (int i=0; i&lt;nVerts; i++) {\n            vertexList[i].visited = false;\n        }\n    }\n\n    private int getAdjUnvisitedVertex(int index) {\n        for (int i=0; i&lt;nVerts; i++) {\n            if (adjMatrix[index][i] == 1 &amp;&amp; vertexList[i].visited == false) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n</code></pre> <p>Test Junit.</p> <pre><code>public void testMST() {\n    System.out.println(\"testMST\");\n    /*\n    Vertex | A | B | C | D | E\n    -------|---|---|---|---|---\n    A      | 0 | 1 | 0 | 1 | 0\n    B      | 1 | 0 | 1 | 0 | 0\n    C      | 0 | 1 | 0 | 0 | 0\n    D      | 1 | 0 | 0 | 0 | 1\n    E      | 0 | 0 | 0 | 1 | 0\n    */\n    MinimumSpanningTree mst = new MinimumSpanningTree(5);\n    mst.addVertex(\"A\");\n    mst.addVertex(\"B\");\n    mst.addVertex(\"C\");\n    mst.addVertex(\"D\");\n    mst.addVertex(\"E\");\n    mst.addEdge(0, 1);  //AB\n    mst.addEdge(0, 2);  //AC\n    mst.addEdge(0, 3);  //AD\n    mst.addEdge(0, 4);  //AE\n    mst.addEdge(1, 2);  //BC\n    mst.addEdge(1, 3);  //BD\n    mst.addEdge(1, 4);  //BE\n    mst.addEdge(2, 3);  //CD\n    mst.addEdge(2, 4);  //CE\n    mst.addEdge(3, 4);  //DE\n\n    System.out.print(\"Minimum spanning tree: \");\n    mst.mst();  // Minimum spanning tree: AB BC CD DE\n    System.out.println();\n}\n</code></pre>"},{"location":"data-structure/data-structure-minimum-spanning-tree/#related-questions","title":"Related Questions","text":"<ul> <li>Cheapest Flights Within K Stops</li> </ul>"},{"location":"data-structure/data-structure-minimum-spanning-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for Minimum Spanning Tree on GitHub</li> </ul>"},{"location":"data-structure/data-structure-minimum-spanning-tree/#reference","title":"Reference","text":"<ul> <li>Spanning Tree</li> </ul>"},{"location":"data-structure/data-structure-monotonic-queue/","title":"Data Structure - Monotonic Queue","text":"<p><code>Monotonic queue</code> is a data structure where the order of the elements is strictly increasing or strictly decreasing. For example a strictly increasing monotonic queue will be able to contain <code>[1, 3, 5, 6, 7]</code>, but not <code>[1, 1, 3, 5]</code> and <code>[2, 1, 4, 5]</code> as the elements are not strictly increasing (<code>1, 1</code> is not strictly increasing, and <code>2, 1</code> is decreasing).</p> <p>There are two types of monotonic queue, increasing or decreasing queue.</p> <ul> <li>Monotonic increasing queue: to push an element e, starts from the rear element, we pop out element s\u2265e(violation);</li> <li>Monotonic decreasing queue: we pop out element s&lt;=e (violation).</li> <li>Sometimes, we can relax the strict monotonic condition, and can allow the stack or queue have duplicate value.</li> </ul> <p>To get the feature of the monotonic queue, with [5, 3, 1, 2, 4] as example.</p> Index Value Increasing queue Decreasing queue 1 5 [5] [5] 2 3 [3] 3 kick out 5 [5, 3] #3-&gt;5 3 1 [1] 1 kick out 3 [5, 3, 1] #1-&gt;3 4 2 [1, 2] #2-&gt;1 [5, 3, 2] 2 kick out 1 #2-&gt;3 5 4 [1, 2, 4] #4-&gt;2 [5,4] 4 kick out 2, 3 #4-&gt;2"},{"location":"data-structure/data-structure-monotonic-queue/#question-of-first-smaller-element","title":"Question of First Smaller Element","text":"<p>Find the first element smaller than current either in the left or in the right.</p> <p>For example, given array [5,3,1,2,4]:</p> <ul> <li>The answer to the first element smaller than current in left is [-1,-1,-1,1,2].</li> <li>The answer to the first element smaller than current in right is [3,1,-1,-1,-1].</li> </ul>"},{"location":"data-structure/data-structure-monotonic-queue/#naive-solution","title":"Naive Solution","text":"<p>We can find the smaller element in brute force way. Use one for loop to point at the current element, and another embedding for loop to look for the first element that is smaller than the current, which gives us $O(n^2)$ time complexity.</p> <pre><code>// input:  [ 5, 3,  1, 2, 4]\n// output: [-1,-1, -1, 1, 2]\n// O(n^2)\npublic int[] firstSmallerLeft(int[] nums) {\n    int[] ans = new int[nums.length];\n    for (int i = 0; i &lt; nums.length; i++) {\n        ans[i] = -1;\n        int curr = nums[i];\n        for (int j = i - 1; j &gt;=0; j--) { // scan from head\n            if (nums[j] &lt; curr) {\n                ans[i] = nums[j];\n                break;\n            }\n        }\n    }\n\n    return ans;\n}\n\n// input:  [5, 3,  1,  2,  4]\n// output: [3, 1, -1, -1, -1]\n// O(n^2)\npublic int[] firstSmallerRight(int[] nums) {\n    int[] ans = new int[nums.length];\n    for (int i = 0; i &lt; nums.length; i++) {\n        ans[i] = -1;\n        int curr = nums[i];\n        for (int j = i + 1; j &lt; nums.length; j++) { // scan from tail\n            if (nums[j] &lt; curr) {\n                ans[i] = nums[j];\n                break;\n            }\n        }\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"data-structure/data-structure-monotonic-queue/#solution-with-stack","title":"Solution with Stack","text":"<p>We can use stack with better performance, the time complexity is $O(n)$.</p> <pre><code>// input:  [ 5, 3,  1, 2, 4]\n// output: [-1,-1, -1, 1, 2]\n// O(n)\npublic int[] firstSmallerLeft(int[] nums) {\n    int[] ans = new int[nums.length];\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();   // increasing stack\n    for (int i = 0; i &lt; nums.length; i++) { // left to right\n        while (!stack.isEmpty() &amp;&amp; stack.peek() &gt;= nums[i]) {\n            stack.pop();\n        }\n        if (stack.isEmpty()) {\n            ans[i] = -1;\n        } else {\n            ans[i] = stack.peek();\n        }\n        stack.push(nums[i]);\n    }\n\n    return ans;\n}\n\n// input:  [5, 3,  1,  2,  4]\n// output: [3, 1, -1, -1, -1]\n// O(n)\npublic int[] firstSmallerRight(int[] nums) {\n    int[] ans = new int[nums.length];\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();        // increasing stack\n    for (int i = nums.length - 1; i &gt;= 0; i--) { // right to left\n        while (!stack.isEmpty() &amp;&amp; stack.peek() &gt;= nums[i]) {\n            stack.pop();\n        }\n        if (stack.isEmpty()) {\n            ans[i] = -1;\n        } else {\n            ans[i] = stack.peek();\n        }\n        stack.push(nums[i]);\n    }\n\n    return ans;\n}\n</code></pre>"},{"location":"data-structure/data-structure-monotonic-queue/#solution-with-monotonic-queue","title":"Solution with Monotonic Queue","text":"<p>We can use monotonic queue with better performance, the time complexity is $O(n)$. Instead of creating two methods to get smaller left and smaller right separately, we can use one method to get both results at once.</p> <pre><code>// input:  [5, 3, 1, 2, 4]\n// output: [[-1,-1, -1, 1, 2], [3, 1, -1, -1, -1]]\n// O(n)\npublic int[][] firstSmaller(int[] nums) {\n    int[] leftSmaller = new int[nums.length];\n    int[] rightSmaller = new int[nums.length];\n    Arrays.fill(leftSmaller, -1);\n    Arrays.fill(rightSmaller, -1);\n    Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // increasing queue\n    for (int i = 0; i &lt; nums.length; i++) {    // left to right\n        while (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &gt;= nums[i]) {\n            rightSmaller[queue.pollLast()] = nums[i];\n        }\n        if (!queue.isEmpty()) {\n            leftSmaller[i] = nums[queue.peekLast()];\n        }\n        queue.offerLast(i);\n    }\n\n    return new int[][]{leftSmaller, rightSmaller};\n}\n</code></pre> <ul> <li>Use Deque as monotonic queue.</li> <li>The deque stores the index of the element, not the value of it.</li> </ul> <p>Similarly, we can get larger left and larger right at once with monotonic queue.</p> <pre><code>// input:  [5, 3, 1, 2, 4]\n// output: [[-1, 5, 3, 3, 5], [-1, 4, 2, 4, -1]]\n// O(n)\npublic int[][] firstLarger(int[] nums) {\n    int[] leftLarger = new int[nums.length];\n    int[] rightLarger = new int[nums.length];\n    Arrays.fill(leftLarger, -1);\n    Arrays.fill(rightLarger, -1);\n    Deque&lt;Integer&gt; queue = new LinkedList&lt;&gt;(); // decreasing queue\n    for (int i = 0; i &lt; nums.length; i++) {    // left to right\n        while (!queue.isEmpty() &amp;&amp; nums[queue.peekLast()] &lt;= nums[i]) {\n            rightLarger[queue.pollLast()] = nums[i];\n        }\n        if (!queue.isEmpty()) {\n            leftLarger[i] = nums[queue.peekLast()];\n        }\n        queue.offerLast(i);\n    }\n\n    return new int[][]{leftLarger, rightLarger};\n}\n</code></pre>"},{"location":"data-structure/data-structure-monotonic-queue/#source-files","title":"Source files","text":"<ul> <li>Source files for Monotonic Queue on GitHub</li> </ul>"},{"location":"data-structure/data-structure-monotonic-queue/#reference","title":"Reference","text":"<ul> <li>Monotonic Queue Explained with LeetCode Problems</li> <li>Monotonic Queue</li> <li>This is a typical monotonic queue problem</li> </ul>"},{"location":"data-structure/data-structure-nary-tree/","title":"Data Structure - N-ary Tree","text":"<p>Implement and traverse N-ary Tree.</p>"},{"location":"data-structure/data-structure-nary-tree/#classic-problems","title":"Classic Problems","text":""},{"location":"data-structure/data-structure-nary-tree/#source-files","title":"Source files","text":""},{"location":"data-structure/data-structure-nary-tree/#reference","title":"Reference","text":""},{"location":"data-structure/data-structure-queue/","title":"Data Structure - Queue","text":""},{"location":"data-structure/data-structure-queue/#real-life-example","title":"Real-life Example","text":"<p>Queue is similar to the ticket queue outside a cinema hall, where the first person entering the queue is the first person who gets the ticket.</p>"},{"location":"data-structure/data-structure-queue/#queue-in-programming-terms","title":"Queue in Programming Terms","text":"<p>Queue is an abstract data type that serves as a collection of elements, with two principal operations:</p> <ul> <li><code>enqueue</code>: add an element to the collection</li> <li><code>dequeue</code>: remove the least recently added element</li> </ul> <p>Queue follows the <code>FIFO</code>(First-in, first-out) rule. The item that goes in first is the item that comes out first too.</p> <p></p>"},{"location":"data-structure/data-structure-queue/#common-operations-on-queue","title":"Common Operations on Queue","text":"<ul> <li>enqueue(item): Add an item to the end of the list.</li> <li>dequeue(): Pull the first item out of the list.</li> <li>peek(): Return the top of the queue.</li> <li>isEmpty(): Return true if and only if the queue is empty.</li> </ul>"},{"location":"data-structure/data-structure-queue/#time-complexity","title":"Time Complexity","text":"<ul> <li>enqueue: $O(1)$</li> <li>dequeue: $O(1)$</li> <li>peek: $O(1)$</li> </ul>"},{"location":"data-structure/data-structure-queue/#implementation","title":"Implementation","text":"<p>Four ways to implement queue.</p> <ul> <li>Linked List</li> <li>Array</li> <li>Circular Array</li> <li>Stack</li> </ul>"},{"location":"data-structure/data-structure-queue/#using-linked-list","title":"Using Linked List","text":"<p>Use two pointers(head and tail) to locate the first and last nodes in the list and track the change.</p> <p></p> <ul> <li>enqueue: Create new node with the given value in the tail of the list, set current tail's next pointer point to the new node and let the tail pointer point to the last node.</li> <li>dequeue: Get value of the head node, let the head pointer point to the next node.</li> </ul> <p>See the implementation below.</p> <pre><code>public class LinkedListQueue {\n    private ListNode head; // the first node\n    private ListNode tail; // the last node\n\n    public LinkedListQueue() {\n        head = null;\n        tail = null;\n    }\n\n    // Add item to the tail of the list\n    public void enqueue(int value) {\n        if (tail == null) {\n            tail = new ListNode(value);\n            head = tail;\n        } else {\n            tail.next = new ListNode(value);\n            tail = tail.next;\n        }\n    }\n\n    // Remove the head from the list and return its value\n    public int dequeue() throws Exception {\n        if (head == null) {\n            throw new Exception();\n        }\n        int value = head.val;\n        head = head.next;\n        if (head == null) {\n          tail = null;\n        }\n        return value;\n    }\n\n    // Get the value of the head\n    public int peek() throws Exception {\n        if (head == null) {\n            throw new Exception();\n        }\n        return head.val;\n    }\n\n    // Return whether the queue is empty\n    public boolean isEmpty() {\n        return head == null;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-queue/#using-array","title":"Using Array","text":"<p>Use two pointers(head and tail) to locate the first and last position in the array and track the change.</p> <p></p> <ul> <li>enqueue: Move tail one step ahead and set value.</li> <li>dequeue: Return the head value and move head one step ahead.</li> </ul> <p>See the implementation below.</p> <pre><code>public class ArrayQueue {\n    private int head; // the first node\n    private int tail; // the last node\n    private int[] arr;\n\n    public ArrayQueue(int capacity) {\n        arr = new int[capacity];\n        head = -1;\n        tail = -1;\n    }\n\n    // Add item to the end of the array\n    public void enqueue(int value) {\n        if (tail &gt;= arr.length - 1) {\n            return;\n        }\n        arr[++tail] = value;\n        if (head == -1) {\n            head = 0;\n        }\n    }\n\n    // Remove the first item from the array and return its value\n    public int dequeue() throws Exception {\n        if (isEmpty()) {\n            throw new Exception();\n        }\n        int value = arr[head];\n        head++;\n        return value;\n    }\n\n    // Get the first item\n    public int peek() throws Exception {\n        if (isEmpty()) {\n            throw new Exception();\n        }\n        return arr[head];\n    }\n\n    // Return whether the queue is empty\n    public boolean isEmpty() {\n        return (head == -1) || (head &gt; tail);\n    }\n}\n</code></pre> <ul> <li>There is one problem with the above implementation. Notice that both head and tail only increase, never decrease. When tail reaches to the end of the array, you cannot add more items into it. Even if you call dequeue method to clear some space, however, the head and tail won't move back.</li> </ul>"},{"location":"data-structure/data-structure-queue/#using-circular-array","title":"Using Circular Array","text":"<p>To solve the issue mentioned above, we can use a circular array to implement the queue.</p> <p></p> <p>See the details below.</p> <p></p> <p>Notice the step of 'enqueue 9' and 'dequeue 8'.</p> <ul> <li>If <code>tail</code> is at the last position of the array, it will be moved back to the first position if new item needs to be added.</li> <li>If <code>head</code> is at the last position of the array, it will be moved back to the first position if old item needs to be deleted.</li> </ul> <p>See the implementation below.</p> <pre><code>public class CircularArrayQueue {\n    private int head; // the first node in queue, not the first item in array\n    private int tail; // the last node in queue, not the first item in array\n    private int[] arr;\n    private int size;\n\n    public CircularArrayQueue(int capacity) {\n        arr = new int[capacity];\n        head = 0;\n        tail = 0;\n        size = 0;\n    }\n\n    // Add item to the end of the queue\n    public void enqueue(int value) {\n        // check if deque is full\n        if (isFull()) {\n            System.out.println(\"queue is full.\");\n            return;\n        }\n        tail = (head + size) % arr.length;\n        arr[tail] = value;\n        size += 1;\n    }\n\n    // Remove the first item from the queue and return its value\n    public int dequeue() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"Array Queue is empty when dequeue!\");\n        }\n\n        int value = arr[head];\n        head = (head + 1) % arr.length;\n        size -= 1;\n        return value;\n    }\n\n    // Get the first item\n    public int peek() throws Exception {\n        if (isEmpty()) {\n            throw new Exception(\"Array Queue is empty when peek!\");\n        }\n        return arr[head];\n    }\n\n    // Return whether the queue is full\n    public boolean isFull() {\n        return size == arr.length;\n    }\n\n    // Return whether the queue is empty\n    public boolean isEmpty() {\n        return size == 0;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-queue/#using-stack","title":"Using Stack","text":"<p>Use two stacks. The first one only stores new items, and the second one only stores old items.</p> <pre><code>import java.util.Stack;\n\npublic class StackQueue {\n    private Stack&lt;Integer&gt; stack1; // s1 stores new items\n    private Stack&lt;Integer&gt; stack2; // s2 stores old items\n\n    public StackQueue() {\n        stack1 = new Stack&lt;&gt;();\n        stack2 = new Stack&lt;&gt;();\n    }\n\n    // Add new item onto queue\n    public void enqueue(int value) {\n        stack1.push(value);\n    }\n\n    // Remove the first item from the queue and return its value\n    public int dequeue() throws Exception {\n        peek();\n        return stack2.pop();\n    }\n\n    // Get the first element\n    public int peek() throws Exception {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n\n        if (stack2.isEmpty()) {\n            throw new Exception();\n        }\n\n        return stack2.peek();\n    }\n\n    // Return whether the queue is empty\n    public boolean isEmpty() {\n        return stack1.isEmpty() &amp;&amp; stack2.empty();\n    }\n}\n</code></pre> <ul> <li>The average time complexity is $O(1)$.</li> </ul>"},{"location":"data-structure/data-structure-queue/#implementing-sorting-algorithms-with-queue","title":"Implementing Sorting Algorithms with Queue","text":""},{"location":"data-structure/data-structure-queue/#merge-sort-with-queue","title":"Merge Sort with Queue","text":"<p>If we call the sort method with array {2,4,5,7,1,2,3,6}, it will return a queue, which contains {1,2,2,3,4,5,6,7}, 1 is the header and 7 is the tail.</p> <pre><code>import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class QueueMergeSort {\n    // Merge Sort\n    public Queue&lt;Integer&gt; sort(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n\n        // initialize queue\n        Queue&lt;int[]&gt; queue = new LinkedList&lt;int[]&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            // convert number to number array\n            queue.offer(new int[]{nums[i]});\n        }\n\n        while (queue.size() &gt; 1) {\n            int[] l = queue.poll();\n            int[] r = queue.poll();\n            int[] merged = merge(l, r);\n            queue.offer(merged);\n        }\n\n        int[] sorted = queue.poll();\n        Queue&lt;Integer&gt; finalQueue = new LinkedList&lt;&gt;();\n        for (int i : sorted) {\n            finalQueue.offer(i);\n        }\n\n        return finalQueue;\n    }\n\n    private int[] merge(int[] nums1, int[] nums2) {\n        if (nums1 == null || nums1.length == 0) {\n            return nums2;\n        }\n        if (nums2 == null || nums2.length == 0) {\n            return nums1;\n        }\n\n        int[] nums = new int[nums1.length + nums2.length];\n        int i = 0, j = 0;\n        for (int k = 0; k &lt; nums.length; k++) {\n            if (i &gt;= nums1.length) {\n                nums[k] = nums2[j];\n                j++;\n            } else if (j &gt;= nums2.length) {\n                nums[k] = nums1[i];\n                i++;\n            } else if (nums1[i] &lt;= nums2[j]) {\n                nums[k] = nums1[i];\n                i++;\n            } else {\n                nums[k] = nums2[j];\n                j++;\n            }\n        }\n\n        return nums;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-queue/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 346 - Moving Average from Data Stream</li> </ul>"},{"location":"data-structure/data-structure-queue/#source-files","title":"Source files","text":"<ul> <li>Source files for Queue on GitHub</li> <li>Queue Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-queue/#reference","title":"Reference","text":"<ul> <li>Data Structure and Algorithms - Queue</li> <li>Stacks and Queues</li> <li>Queue</li> <li>Circular Queue - Introduction and Array Implementation</li> </ul>"},{"location":"data-structure/data-structure-red-black-tree/","title":"Data Structure - Red Black Tree","text":"<p>Introduce red black tree and its properties.</p>"},{"location":"data-structure/data-structure-red-black-tree/#problems-with-binary-search-tree","title":"Problems with Binary Search Tree","text":"<p>For Binary Search Tree, although the average time complexity for the search, insertion and deletion are all $O(\\log{}n)$, where n is the number of nodes in the tree, the time complexity becomes to $O(n)$ in worst case - BST is not balanced. </p> <p>We can guarantee $O(\\log{}n)$ time for all three operations by using a balanced tree - a tree that always has height <code>log(n)</code>.</p>"},{"location":"data-structure/data-structure-red-black-tree/#red-black-tree","title":"Red Black Tree","text":""},{"location":"data-structure/data-structure-red-black-tree/#definition-of-rbt","title":"Definition of RBT","text":"<p>A red black tree is a binary search tree with following four properties.</p> <ul> <li><code>Color property</code>: Each node has a color (red or black) associated with it (in addition to its key, left and right children).</li> <li><code>Root property</code>: The root of the red-black tree is black.</li> <li><code>Red property</code>: The children of a red node are black.</li> <li><code>Black property</code>: For each node with at least one null child, the number of black nodes on the path from the root to the null child is the same.</li> </ul> <p>Examples of Red Black Tree. </p> <p>The following examples are NOT Red Black Tree. </p>"},{"location":"data-structure/data-structure-red-black-tree/#time-complexity","title":"Time Complexity","text":"<ul> <li>Search - $O(\\log{}n)$</li> <li>Insertion - $O(\\log{}n)$</li> <li>Deletion - $O(\\log{}n)$</li> </ul>"},{"location":"data-structure/data-structure-red-black-tree/#space-complexity","title":"Space Complexity","text":"<ul> <li>$O(n)$</li> </ul>"},{"location":"data-structure/data-structure-red-black-tree/#search","title":"Search","text":"<p>Same as Binary Search Tree.</p>"},{"location":"data-structure/data-structure-red-black-tree/#insertion","title":"Insertion","text":"<p>The goal of the insert operation is to insert key <code>x</code> into tree <code>T</code>, and keep T's red-black tree properties. We use <code>Recoloring</code> and <code>Rotation</code> to achieve that.</p> <p>There are several cases when inserting a new key to RBT. We will go through all of them below.</p>"},{"location":"data-structure/data-structure-red-black-tree/#special-case-empty-tree","title":"Special Case: Empty Tree","text":"<p>A special case is required for an empty tree. If T is empty, replace it with a single black node containing x. This ensures that the root property is satisfied. </p>"},{"location":"data-structure/data-structure-red-black-tree/#non-empty-tree","title":"Non-empty Tree","text":"<p>If T is a non-empty tree, then we do the following:</p> <ul> <li>1) Use the BST insert algorithm to add x to the tree</li> <li>2) color the node containing x to red</li> <li>3) restore red-black tree properties (if necessary)</li> </ul> <p>For step 3, what we need to do depends on the color of x's parent. Let <code>p</code> be x's parent. We need to consider two cases:</p> <ul> <li>Case 1: x's parent p is black. The insertion of x does not result in the red property being violated, so there's nothing more to do.</li> <li>Case 2: K's parent p is red. For easy understanding, we have the following naming convention.  If <code>p</code> is red, then p now has a red child, which violates the red property. Note that p's parent, <code>g</code>, must be black. In order to handle this double-red situation, we will need to consider the color of g's other child, that is, p's sibling, <code>s</code>. (Note that s might be null, i.e., g only has one child and that child is p.) We have two cases:</li> <li>Case 2a: <code>p</code>'s sibling <code>s</code> is red.     Perform recoloring of <code>p</code>, <code>s</code> and <code>g</code>: the color of <code>p</code> and <code>s</code> is changed to black and the color of <code>g</code> is changed to red (unless <code>g</code> is the root, in which case we leave <code>g</code> black to preserve the root property).          Recoloring does not affect the black property of a tree: the number of black nodes on any path that goes through <code>p</code> and <code>g</code> is unchanged when <code>p</code> and <code>g</code> switch colors (similarly for <code>s</code> and <code>g</code>). But, the recoloring may have introduced a double-red situation between <code>g</code> and <code>g</code>'s parent. If that is the case, then we <code>recursively</code> handle the double-red situation starting at <code>g</code> and <code>g</code>'s parent (instead of <code>x</code> and <code>x</code>'s parent).</li> <li>Case 2b: <code>p</code>'s sibling <code>s</code> is black or null.     If <code>s</code> is black or null, then we will do a tri-node restructuring of <code>x</code>, <code>p</code> and <code>g</code>. There are four subcases for the relative ordering of x, p and g. The way a restructuring is done for each of the possibilities is shown below.<ul> <li>i) Left Left Case (p is left child of g and x is left child of p) </li> <li>ii) Left Right Case (p is left child of g and x is right child of p) </li> <li>iii) Right Right Case (Mirror of case i) </li> <li>iv) Right Left Case (Mirror of case ii) </li> </ul> </li> </ul>"},{"location":"data-structure/data-structure-red-black-tree/#example-of-insertion","title":"Example of Insertion","text":""},{"location":"data-structure/data-structure-red-black-tree/#deletion","title":"Deletion","text":"<p>There are three cases when deleting a node from Binary Search Tree.</p> <ul> <li>Node is leaf, has no children.</li> <li>Node has only one child.</li> <li>Node has two children.</li> </ul>"},{"location":"data-structure/data-structure-red-black-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for Red Black Tree on GitHub</li> <li>Red Black Tree Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-red-black-tree/#reference","title":"Reference","text":"<ul> <li>Red-Black Trees</li> <li>Red-Black Tree - Set 1 (Introduction)</li> <li>Red-Black Tree - Set 2 (Insert)</li> <li>Red-Black Tree - Set 3 (Delete)</li> <li>Red-black trees in 4 minutes \u2014 The basics</li> <li>Red-Black Trees - Data Structures</li> <li>Insertion for Red-Black Trees</li> <li>Red/Black Tree Visualization</li> </ul>"},{"location":"data-structure/data-structure-segment-tree/","title":"Data Structure - Segment Tree","text":"<p>Segment Tree (a.k.a Interval Tree) is an advanced data structure which can support queries like:</p> <ul> <li>which of these intervals contain a given point</li> <li>which of these points are in a given interval</li> </ul>"},{"location":"data-structure/data-structure-segment-tree/#the-range-search-question","title":"The Range Search Question","text":"<ul> <li>What is the minimum number of array {4,-1,3,0,2}? The answer is <code>-1</code>.  </li> <li>What is the minimum number of this array within the range of index {2,3}? The answer is <code>0</code>.  </li> <li>How to answer such question for any given range?</li> </ul> <p>We have to create a matrix to store all the minimum values for all ranges. The matrix looks as follows.</p> Index 0 1 2 3 4 0 4 -1 -1 -1 -1 1 -1 -1 -1 -1 2 3 0 0 3 0 0 4 2 <p>For example, to get the minimum number of range {2,4}, just find the cell {2,4}, which is <code>0</code>.</p> <p>Performance of Matrix Search:</p> <ul> <li>The space complexity is $O(n^2)$.</li> <li>The time complexity for building the matrix is $O(n^2)$, for searching is $O(1)$.</li> </ul>"},{"location":"data-structure/data-structure-segment-tree/#solution-with-segment-tree","title":"Solution with Segment Tree","text":"<p>The above question can be solved with Segment Tree as well. It has less storage and better performance.</p> <ul> <li>The space complexity is $O(n)$.</li> <li>The time complexity for building the tree is $O(n)$, for searching is $O(\\log{}n)$.</li> </ul> <p>Common Operations on Segment Tree:</p> <ul> <li>Build - $O(n)$</li> <li>Search - $O(\\log{}n)$</li> <li>Modification - $O(\\log{}n)$</li> </ul>"},{"location":"data-structure/data-structure-segment-tree/#minimum-segment-tree","title":"Minimum Segment Tree","text":""},{"location":"data-structure/data-structure-segment-tree/#definition-of-minimum-segment-tree","title":"Definition of Minimum Segment Tree","text":"<p>The digram below shows what Minimum Segment Tree for given array {4,-1,3,0,2} looks like.  </p>"},{"location":"data-structure/data-structure-segment-tree/#creating-segment-tree-node","title":"Creating Segment Tree Node","text":"<p>Create a class named <code>SegmentTreeNode</code>. Attributes <code>start</code> and <code>end</code> define the range. Attributes <code>left</code> and <code>right</code> are the children of the current node.</p> <pre><code>public class SegmentTreeNode {\n    public int start, end;\n    public int max, min, sum; // You can add other additional attributes\n    public SegmentTreeNode left, right;\n\n    public SegmentTreeNode(int start, int end) {\n        this.start = start;\n        this.end = end;\n        this.left = null;\n        this.right = null;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-segment-tree/#constructing-minimum-segment-tree","title":"Constructing Minimum Segment Tree","text":"<p>Recursively construct the segment tree from top to bottom in binary approach. At each level, set the minimum value for the node.</p> <pre><code>private SegmentTreeNode build(int[] arr) {\n    if (arr == null || arr.length == 0) {\n        return null;\n    }\n\n    return buildMinHelpler(arr, 0, arr.length - 1);\n}\n\nprivate SegmentTreeNode buildMinHelpler(int[] arr, int start, int end) {\n    if (start &gt; end) {\n        return null;\n    }\n\n    SegmentTreeNode root = new SegmentTreeNode(start, end);\n    if (start == end) {\n        root.min = arr[start];\n        return root;\n    }\n\n    int mid = start + (end - start) / 2;\n    root.left = buildMinHelpler(arr, start, mid);\n    root.right = buildMinHelpler(arr, mid + 1, end);\n    root.min = Math.min(root.left.min, root.right.min);\n    return root;\n}\n</code></pre>"},{"location":"data-structure/data-structure-segment-tree/#searching-on-minimum-segment-tree","title":"Searching on Minimum Segment Tree","text":"<p>There are four cases when searching with the given range.</p> <ul> <li>Search range is same with the range of root node, return the value directly.</li> <li>Search range is within the range of left child, continue searching in left node.</li> <li>Search range is within the range of right child, continue searching in right node.</li> <li>Search range crosses both left and right children, split the search and merge the result.</li> </ul> <pre><code>public int queryMin(int start, int end) {\n    return queryMin(this.root, start, end);\n}\n\nprivate int queryMin(SegmentTreeNode root, int start, int end) {\n    if (root == null) {\n        return 0;\n    }\n\n    // case 1: search range is same with the range of root node\n    if (root.start == start &amp;&amp; root.end == end) {\n        return root.min;\n    }\n\n    int mid = root.start + (root.end - root.start) / 2;\n    // left range = [root.start, root.mid], right range = [root.mid + 1, root.end]\n    if (end &lt;= mid) {\n        // case 2: search range is in the range of left child node\n        return queryMin(root.left, start, end);\n    } else if (start &gt; mid) {\n        // case 3: search range is in the range of right child node\n        return queryMin(root.right, start, end);\n    } else {\n        //case 4: search range crosses both left and right children\n        int leftmin = queryMin(root.left, start, mid);\n        int rightmin = queryMin(root.right, mid + 1, end);\n        return Math.min(leftmin, rightmin);\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-segment-tree/#including-maximum-and-sum","title":"Including Maximum and Sum","text":""},{"location":"data-structure/data-structure-segment-tree/#definition-of-minimummaximumsum-segment-tree","title":"Definition of Minimum/Maximum/Sum Segment Tree","text":"<p>Actually, we can build Segment Tree for minimum, maximum and sum all at once.  For each node, it contains min, max and sum value. Here are the samples for different ranges.</p> Range Min Max Sum (0,4) -1 4 8 (2,3) 0 3 3 (0,1) -1 4 3 (1,4) -1 3 4"},{"location":"data-structure/data-structure-segment-tree/#constructing-segment-tree","title":"Constructing Segment Tree","text":"<p>Refine the <code>build</code> method to include minimum, maximum and sum all together.</p> <pre><code>private SegmentTreeNode build(int[] arr) {\n    if (arr == null || arr.length == 0) {\n        return null;\n    }\n\n    return buildHelpler(arr, 0, arr.length - 1);\n}\n\nprivate SegmentTreeNode buildHelpler(int[] arr, int start, int end) {\n    if (start &gt; end) {\n        return null;\n    }\n\n    SegmentTreeNode root = new SegmentTreeNode(start, end);\n    if (start == end) {\n        root.min = arr[start];\n        root.max = arr[start];\n        root.sum = arr[start];\n        return root;\n    }\n\n    int mid = start + (end - start) / 2;\n    root.left = buildHelpler(arr, start, mid);\n    root.right = buildHelpler(arr, mid + 1, end);\n    root.min = Math.min(root.left.min, root.right.min);\n    root.max = Math.max(root.left.max, root.right.max);\n    root.sum = root.left.sum + root.right.sum;\n    return root;\n}\n</code></pre>"},{"location":"data-structure/data-structure-segment-tree/#searching-on-segment-tree","title":"Searching on Segment Tree","text":"<p>Create three query methods named <code>queryMin</code>, <code>queryMax</code> and <code>querySum</code>. For the given segment tree and range, find the minimum value, maximum value and sum accordingly.</p> <pre><code>public int queryMin(int start, int end) {\n    return queryMin(this.root, start, end);\n}\n\nprivate int queryMin(SegmentTreeNode root, int start, int end) {\n    if (root == null) {\n        return 0;\n    }\n\n    // case 1: search range is same with the range of root node\n    if (root.start == start &amp;&amp; root.end == end) {\n        return root.min;\n    }\n\n    int mid = root.start + (root.end - root.start) / 2;\n    if (end &lt;= mid) {\n        // case 2: search range is in the range of left child node\n        return queryMin(root.left, start, end);\n    } else if (start &gt; mid) {\n        // case 3: search range is in the range of right child node\n        return queryMin(root.right, start, end);\n    } else {\n        //case 4: search range crosses both left and right children\n        int leftmin = queryMin(root.left, start, mid);\n        int rightmin = queryMin(root.right, mid + 1, end);\n        return Math.min(leftmin, rightmin);\n    }\n}\n\npublic int queryMax(int start, int end) {\n    return queryMax(this.root, start, end);\n}\n\npublic int queryMax(SegmentTreeNode root, int start, int end) {\n    if (root == null) {\n        return 0;\n    }\n\n    // case 1: search range is same with the range of root node\n    if (root.start == start &amp;&amp; root.end == end) {\n        return root.max;\n    }\n\n    int mid = root.start + (root.end - root.start) / 2;\n    if (end &lt;= mid) {\n        // case 2: search range is in the range of left child node\n        return queryMax(root.left, start, end);\n    } else if (start &gt; mid) {\n        // case 3: search range is in the range of right child node\n        return queryMax(root.right, start, end);\n    } else {\n        //case 4: search range crosses both left and right children\n        int leftmax = queryMax(root.left, start, mid);\n        int rightmax = queryMax(root.right, mid + 1, end);\n        return Math.max(leftmax, rightmax);\n    }\n}\n\npublic int querySum(int start, int end) {\n    return querySum(this.root, start, end);\n}\n\npublic int querySum(SegmentTreeNode root, int start, int end) {\n    if (root == null) {\n        return 0;\n    }\n\n    // case 1: search range is same with the range of root node\n    if (root.start == start &amp;&amp; root.end == end) {\n        return root.sum;\n    }\n\n    int mid = root.start + (root.end - root.start) / 2;\n    if (end &lt;= mid) {\n        // case 2: search range is in the range of left child node\n        return querySum(root.left, start, end);\n    } else if (start &gt; mid) {\n        // case 3: search range is in the range of right child node\n        return querySum(root.right, start, end);\n    } else {\n        //case 4: search range crosses both left and right children\n        int leftsum = querySum(root.left, start, mid);\n        int rightsum = querySum(root.right, mid + 1, end);\n        return leftsum + rightsum;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-segment-tree/#modification","title":"Modification","text":""},{"location":"data-structure/data-structure-segment-tree/#modify-minimum-segment-tree","title":"Modify Minimum Segment Tree","text":"<p>If value on leaf node is changed, we need to update its parent accordingly. For example, if we change the value of the second leaf from '-1' to '5' in minimum segment tree, then all nodes from root to this leaf need to be updated. </p> <p>The implementation of the <code>modify</code> method.</p> <pre><code>public void modify(int index, int value) {\n    modify(this.root, index, value);\n}\n\nprivate void modify(SegmentTreeNode root, int index, int value) {\n    if (root == null) {\n        return;\n    }\n\n    if (root.start == root.end &amp;&amp; root.start == index) {\n        root.min = value;\n        return;\n    }\n\n    int mid = root.start + (root.end - root.start) / 2;\n    if (index &lt;= mid) {\n        modify(root.left, index, value);\n    } else {\n        modify(root.right, index, value);\n    }\n\n    root.min = Math.min(root.left.min, root.right.min);\n}\n</code></pre>"},{"location":"data-structure/data-structure-segment-tree/#modifying-maximum-and-sum","title":"Modifying Maximum and Sum","text":"<p>Similarly, if we change the value, the max value and the sum value will be affected as well.  Refine the <code>modify</code> method to update the max value and the sum value together.</p> <pre><code>public void modify(int index, int value) {\n    modify(this.root, index, value);\n}\n\nprivate void modify(SegmentTreeNode root, int index, int value) {\n    if (root == null) {\n        return;\n    }\n\n    if (root.start == root.end &amp;&amp; root.start == index) {\n        root.min = value;\n        root.max = value;\n        root.sum = value;\n        return;\n    }\n\n    int mid = root.start + (root.end - root.start) / 2;\n    if (index &lt;= mid) {\n        modify(root.left, index, value);\n    } else {\n        modify(root.right, index, value);\n    }\n\n    root.min = Math.min(root.left.min, root.right.min);\n    root.max = Math.max(root.left.max, root.right.max);\n    root.sum = root.left.sum + root.right.sum;\n}\n</code></pre>"},{"location":"data-structure/data-structure-segment-tree/#classic-problems","title":"Classic Problems","text":"<ul> <li>LintCode 201 - Segment Tree Build</li> <li>LintCode 202 - Segment Tree Query</li> <li>LintCode 203 - Segment Tree Modify</li> <li>LintCode 205 - Interval Minimum Number</li> <li>LintCode 206 - Interval Sum</li> <li>LintCode 207 - Interval Sum II</li> <li>LintCode 248 - Count of Smaller Number</li> <li>LintCode 249 - Count of Smaller Number before itself</li> </ul>"},{"location":"data-structure/data-structure-segment-tree/#source-files","title":"Source files","text":"<ul> <li>Source files for Segment Tree on GitHub</li> <li>Segment Tree Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-segment-tree/#reference","title":"Reference","text":"<ul> <li>Segment Tree Set 2 - Range Minimum Query</li> <li>Segment Tree Set 1 - Sum of given range</li> <li>Segment Tree Range Minimum Query(Video on Youtube)</li> </ul>"},{"location":"data-structure/data-structure-skip-list/","title":"Skip List","text":"<p>A skip list is a data structure that allows <code>log(n)</code> search complexity as well as <code>log(n)</code> insertion complexity within an ordered sequence of <code>n</code> elements.</p>"},{"location":"data-structure/data-structure-skip-list/#problem-of-linked-list","title":"Problem of Linked List","text":"<p>A linked list is represented by a sequence of nodes. Each node contains a link to another node. The worst case search time for a sorted linked list is <code>O(n)</code> as we can only linearly traverse the list and cannot skip nodes while searching.</p>"},{"location":"data-structure/data-structure-skip-list/#why-skip-list","title":"Why Skip List?","text":"<p>It skips over many of the items of the full list in one step, that\u2019s why it is known as skip list.  </p>"},{"location":"data-structure/data-structure-skip-list/#insert-search-and-delete","title":"Insert, Search and Delete","text":"<p>Insert 44.  Search 44.  Delete 25. </p>"},{"location":"data-structure/data-structure-skip-list/#implementation","title":"Implementation","text":"<p>Define skip list node.</p> <pre><code>public class SkipNode {\n    public int val;\n\n    public SkipNode left;\n    public SkipNode right;\n    public SkipNode up;\n    public SkipNode down;\n\n    public SkipNode(int val) {\n        this.val = val;\n        this.left = null;\n        this.right = null;\n        this.up = null;\n        this.down = null;\n    }\n\n    public SkipNode(SkipNode lowerLevelNode) {\n        this.val = lowerLevelNode.val;\n        this.left = null;\n        this.right = null;\n        this.up = null;\n        this.down = lowerLevelNode;\n    }\n}\n</code></pre> <p>List.</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class SkipList {\n    /*\n     * These are starting pointers. They are always from top layer.\n     */\n    private SkipNode head;\n    private SkipNode tail;\n\n    public SkipList() {\n        head = new SkipNode(Integer.MIN_VALUE);\n        tail = new SkipNode(Integer.MAX_VALUE);\n\n        head.right = tail;\n        tail.left = head;\n    }\n\n    public SkipNode search(int val) {\n        SkipNode curr = head;\n\n        while (curr != null) {\n            while (curr.right != null &amp;&amp; curr.right.val &lt;= val ) {\n                curr = curr.right;\n            }\n\n            if (curr.val == val) {\n                break;\n            }\n\n            curr = curr.down;\n        }\n\n        return curr;\n    }\n\n    public boolean insert(int data) {\n        List&lt;SkipNode&gt; pointersToUpdate = new ArrayList&lt;&gt;();\n\n        SkipNode curr = head;\n        while (curr != null) {\n            while (curr.right != null &amp;&amp; curr.right.val &lt; data ) {\n                curr = curr.right;\n            }\n\n            pointersToUpdate.add(curr);\n            curr = curr.down;\n        }\n\n        // insert after this node.\n        int level = 0;\n        SkipNode newNode = null;\n\n        while (level == 0 || flipCoin()) {\n            // now move up.\n            if (newNode == null) {\n                newNode = new SkipNode(data);\n            } else {\n                newNode = new SkipNode(newNode);\n            }\n\n            SkipNode nodeToUpdate;\n\n            if (pointersToUpdate.size() &lt;= level) {\n                createNewLayer();\n                nodeToUpdate = this.head;\n            } else {\n                nodeToUpdate = pointersToUpdate.get(pointersToUpdate.size() - level - 1);\n            }\n\n            // insert\n            newNode.right = nodeToUpdate.right;\n            newNode.left = nodeToUpdate;\n\n            newNode.right.left = newNode;\n            nodeToUpdate.right = newNode;\n\n            level++;\n        }\n\n        return true;\n    }\n\n    public boolean delete(int data) {\n        List&lt;SkipNode&gt; pointersToUpdate = new ArrayList&lt;&gt;();\n\n        SkipNode curr = this.head;\n        while (curr != null) {\n            while (curr.right != null &amp;&amp; curr.right.val &lt; data ) {\n                curr = curr.right;\n            }\n\n            if (curr.right.val == data) {\n                pointersToUpdate.add(curr);\n            }\n\n            curr = curr.down;\n        }\n\n        for (int i = 0; i &lt; pointersToUpdate.size(); i++) {\n            SkipNode nodeToUpdate = pointersToUpdate.get(i);\n            SkipNode nodeToDelete = nodeToUpdate.right;\n\n            nodeToUpdate.right = nodeToDelete.right;\n            nodeToDelete.right.left = nodeToUpdate;\n\n            nodeToDelete.up = null;\n            nodeToDelete.down = null;\n        }\n\n        return true;\n    }\n\n    private void createNewLayer() {\n        SkipNode newHead = new SkipNode(Integer.MIN_VALUE);\n        SkipNode newTail = new SkipNode(Integer.MAX_VALUE);\n\n        newHead.right = newTail;\n        newTail.left = newHead;\n\n        head.up = newHead;\n        newHead.down = head;\n        head = newHead;\n\n        tail.up = newTail;\n        newTail.down = tail;\n        tail = newTail;\n    }\n\n    private boolean flipCoin() {\n        return Math.random() &gt;= 0.5;\n    }\n\n    public void print() {\n        SkipNode curr = this.head;\n\n        while (curr.down != null) {\n            curr = curr.down;\n        }\n\n        curr = curr.right;\n\n        while (curr.right != null) {\n            System.out.print(curr.val + \" \");\n            curr = curr.right;\n        }\n\n        System.out.println();\n    }\n\n    public void printAllLevel() {\n        SkipNode curr = this.head;\n\n        while (curr != null) {\n            SkipNode firstInLevel = curr;\n            firstInLevel = firstInLevel.right;\n\n            while (firstInLevel.right != null) {\n                System.out.print(firstInLevel.val + \" \");\n                firstInLevel = firstInLevel.right;\n            }\n\n            curr = curr.down;\n            System.out.println();\n        }\n    }\n}\n</code></pre> <p>Test.</p> <pre><code>public class SkipListExample {\n    public static void main( String[] args ) {\n        SkipList list = new SkipList();\n        list.insert(5);\n        list.insert(10);\n        list.insert(9);\n        list.insert(8);\n        list.insert(12);\n        list.insert(1);\n        list.insert(50);\n        list.insert(60);\n        list.insert(70);\n        list.insert(90);\n\n        list.print();\n        SkipNode node = list.search(9);\n        System.out.println(node.val);\n        //list.printAllLevel();\n\n        list.delete(10);\n        list.delete(1);\n        list.print();\n        //list.printAllLevel();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>1 5 8 9 10 12 50 60 70 90\n9\n5 8 9 12 50 60 70 90\n</code></pre>"},{"location":"data-structure/data-structure-skip-list/#source-files","title":"Source files","text":"<ul> <li>Source files for Skip List on GitHub</li> </ul>"},{"location":"data-structure/data-structure-skip-list/#reference","title":"Reference","text":"<ul> <li>SkipList \u8df3\u8868</li> <li>\u8df3\u8dc3\u8868-\u539f\u7406\u53caJava\u5b9e\u73b0</li> <li>Implementing the skip list data structure</li> <li>Implements a dictionary as a SkipList</li> <li>Java Implementation of SkipList</li> <li>Inserting and Removing from a Skip List</li> </ul>"},{"location":"data-structure/data-structure-stack/","title":"Data Structure - Stack","text":"<p>A stack is a linear data structure that follows the principle of <code>Last In First Out (LIFO)</code>. This means the last element inserted inside the stack is removed first.</p>"},{"location":"data-structure/data-structure-stack/#real-life-example","title":"Real-life Example","text":"<p>Stack is just like a pile of plates kept on top of each other. You can only take out a plate from the top and put a plate on top of the other plates.</p> <p> </p> <p>Think about the things you can do with such a pile of plates.</p> <ul> <li>Put a new plate on top</li> <li>Remove the top plate</li> </ul> <p>If you want the plate at the bottom, you have to first remove all the plates on top.</p>"},{"location":"data-structure/data-structure-stack/#stack-in-programming-terms","title":"Stack in Programming Terms","text":"<p>Stack is an abstract data type that serves as a collection of elements, with two principal operations:</p> <ul> <li><code>push</code>: add an element to the collection</li> <li><code>pop</code>: remove the most recently added element</li> </ul> <p>Stack follows the <code>LIFO</code>(Last-in, first-out) rule. The last item that was placed is the first item to go out.  </p>"},{"location":"data-structure/data-structure-stack/#common-operations-on-stack","title":"Common Operations on Stack","text":"<ul> <li>push(item): Add an item to the top of the stack.</li> <li>pop(): Remove the top item from the stack.</li> <li>peek(): Return the top of the stack.</li> <li>isEmpty(): Return true if the stack is empty.</li> </ul>"},{"location":"data-structure/data-structure-stack/#time-complexity","title":"Time Complexity","text":"<ul> <li>push: $O(1)$</li> <li>pop: $O(1)$</li> <li>peek: $O(1)$</li> </ul>"},{"location":"data-structure/data-structure-stack/#implementation","title":"Implementation","text":"<p>Four ways to implement stack.</p> <ul> <li>Linked List</li> <li>Array</li> <li>Circular Array(No need)</li> <li>Queues</li> </ul>"},{"location":"data-structure/data-structure-stack/#using-linked-list","title":"Using Linked List","text":"<p>The head of the Linked List keeps the latest added item, which is the top of stack. </p> <ul> <li>push: Create new node with the given value, set its next pointer point to the current head node and let the head pointer point to the new node.</li> <li>pop: Get value of the head node, let the head pointer point to the next node.</li> </ul> <p>See the implementation below. First, define the list node as follows.</p> <pre><code>public class ListNode {\n    public int val;\n    public ListNode next;\n    public ListNode(int val) {\n        this.val = val;\n        this.next = null;\n    }\n}\n</code></pre> <p>Then, create the stack with list nodes.</p> <pre><code>public class LinkedListStack {\n    private ListNode head; // the head node\n\n    public LinkedListStack() {\n        head = null;\n    }\n\n    // Add item to the list, let head point to the new node\n    public void push(int value) {\n        ListNode oldHead = head;\n        head = new ListNode(value);\n        head.next = oldHead;\n    }\n\n    // Remove the head item from the list and return its value\n    public int pop() throws Exception {\n        if (head == null) {\n            throw new Exception();\n        }\n        int value = head.val;\n        head = head.next;\n        return value;\n    }\n\n    // Get the value of the head item\n    public int peek() throws Exception {\n        if (head == null) {\n            throw new Exception();\n        }\n        return head.val;\n    }\n\n    // Return whether the list is empty\n    public boolean isEmpty() {\n        return head == null;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-stack/#using-array","title":"Using Array","text":"<p>The top pointer is always pointing to the latest added item, which is the top of stack. </p> <ul> <li>push: Move top pointer one step ahead and put the given value.</li> <li>pop: Return the top value and move top pointer one step backward.</li> </ul> <p>See the implementation below.</p> <pre><code>public class ArrayStack {\n    private int top;\n    private int[] arr;\n\n    public ArrayStack(int capacity) {\n        arr = new int[capacity];\n        top = -1;\n    }\n\n    // Add new element to the end of the array\n    public void push(int value) {\n        arr[++top] = value;\n    }\n\n    // Remove the last element from the array and return its value\n    public int pop() throws Exception {\n        if (top &lt; 0) {\n            throw new Exception();\n        }\n        int value = arr[top];\n        top--;\n        return value;\n    }\n\n    // Get the top element\n    public int peek() throws Exception {\n        if (top &lt; 0) {\n            throw new Exception();\n        }\n        return arr[top];\n    }\n\n    // Return whether the stack is empty\n    public boolean isEmpty() {\n        return top &lt; 0;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-stack/#using-circular-array","title":"Using Circular Array","text":"<p>No need to use circular array to implement stack. As you see how we implement stack with array, no space is wasted after <code>pop</code> operation. While in queue(implemented with array), empty cell appears after <code>poll</code> method gets called.</p>"},{"location":"data-structure/data-structure-stack/#using-two-queues","title":"Using Two Queues","text":"<p>Time complexity: push: O(1), pop: O(n), peek: O(1)</p> <pre><code>import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class QueueStack {\n    Queue&lt;Integer&gt; queue1; // Q1 always has all of the elements\n    Queue&lt;Integer&gt; queue2; // Q2 always be empty after pop\n    int top = 0;\n\n    // Initialize your data structure here.\n    public QueueStack() {\n        queue1 = new LinkedList&lt;Integer&gt;();\n        queue2 = new LinkedList&lt;Integer&gt;();\n    }\n\n    // Push element x onto stack.\n    public void push(int x) {\n        queue1.offer(x);\n        top = x;\n    }\n\n    // Removes the element on top of the stack and returns that element.\n    public int pop() {\n        while (queue1.size() &gt; 1) {\n            top = queue1.poll();\n            queue2.offer(top);\n        }\n        int res = queue1.poll();\n        Queue&lt;Integer&gt; temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n        return res;\n    }\n\n    // Get the top element.\n    public int top() {\n        return top;\n    }\n\n    // Returns whether the stack is empty.\n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-stack/#using-one-queue","title":"Using One Queue","text":"<p>Time complexity: push: O(n), pop: O(1), peek: O(1)</p> <pre><code>import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class QueueStack {\n    private LinkedList&lt;Integer&gt; queue;\n\n    /** Initialize your data structure here. */\n    public QueueStack() {\n        queue = new LinkedList&lt;&gt;();\n    }\n\n    /** Push element x onto stack. */\n    public void push(int x) {\n        queue.add(x);\n        int sz = queue.size();\n        while (sz &gt; 1) {\n            queue.add(queue.remove());\n            sz--;\n        }\n    }\n\n    /** Removes the element on top of the stack and returns that element. */\n    public int pop() {\n        return queue.remove();\n    }\n\n    /** Get the top element. */\n    public int top() {\n        return queue.peek();\n    }\n\n    /** Returns whether the stack is empty. */\n    public boolean empty() {\n        return queue.isEmpty();\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-stack/#implementing-sorting-algorithms-with-stack","title":"Implementing Sorting Algorithms with Stack","text":""},{"location":"data-structure/data-structure-stack/#insertion-sort-with-stack","title":"Insertion Sort with Stack","text":"<p>If we call the sort method with array {2,4,5,7,1,2,3,6}, it will return a stack, which contains {1,2,2,3,4,5,6,7}, 7 is at top.</p> <pre><code>import java.util.Stack;\n\npublic class StackInsertionSort {\n    // Insertion Sort\n    public Stack&lt;Integer&gt; sort(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n\n        // initialize stack1\n        Stack&lt;Integer&gt; stack = new Stack&lt;Integer&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            stack.push(nums[i]);\n        }\n        // stack2 contains the sorted items\n        Stack&lt;Integer&gt; stack2 = new Stack&lt;Integer&gt;();\n\n        while (!stack.isEmpty()) {\n            int top = stack.pop();\n            if (stack2.isEmpty()) {\n                stack2.push(top);\n                continue;\n            }\n            while (!stack2.isEmpty() &amp;&amp; stack2.peek() &gt; top) {\n                stack.push(stack2.pop());\n            }\n            stack2.push(top);\n        }\n\n        return stack2;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-stack/#merge-sort-with-stack","title":"Merge Sort with Stack","text":"<p>If we call the sort method with array {2,4,5,7,1,2,3,6}, it will return a stack, which contains {1,2,2,3,4,5,6,7}, 7 is at top.</p> <pre><code>import java.util.Stack;\n\npublic class StackMergeSort {\n    // Merge Sort\n    public Stack&lt;Integer&gt; sort(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n\n        // initialize stack1\n        Stack&lt;int[]&gt; stack = new Stack&lt;int[]&gt;();\n        for (int i = 0; i &lt; nums.length; i++) {\n            // convert number to number array\n            stack.push(new int[]{nums[i]});\n        }\n        // stack2 contains the sorted sub arrays\n        Stack&lt;int[]&gt; stack2 = new Stack&lt;int[]&gt;();\n\n        while (stack.size() &gt; 1) {\n            while (stack.size() &gt; 1) {\n                int[] r = stack.pop();\n                int[] l = stack.pop();\n                int[] merged = merge(l, r);\n                stack2.push(merged);\n            }\n            while (stack2.size() &gt; 1) {\n                int[] r = stack2.pop();\n                int[] l = stack2.pop();\n                int[] merged = merge(l, r);\n                stack.push(merged);\n            }\n        }\n\n        // odd case\n        if (!stack.isEmpty() &amp;&amp; !stack2.isEmpty()) {\n            int[] r = stack.pop();\n            int[] l = stack2.pop();\n            int[] merged = merge(l, r);\n            stack.push(merged);\n        }\n\n        int[] sorted = stack.isEmpty() ? stack2.pop() : stack.pop();\n\n        Stack&lt;Integer&gt; finalStack = new Stack&lt;&gt;();\n        for (int i : sorted) {\n            finalStack.push(i);\n        }\n\n        return finalStack;\n    }\n\n    private int[] merge(int[] nums1, int[] nums2) {\n        if (nums1 == null || nums1.length == 0) {\n            return nums2;\n        }\n        if (nums2 == null || nums2.length == 0) {\n            return nums1;\n        }\n\n        int[] nums = new int[nums1.length + nums2.length];\n        int i = 0, j = 0;\n        for (int k = 0; k &lt; nums.length; k++) {\n            if (i &gt;= nums1.length) {\n                nums[k] = nums2[j];\n                j++;\n            } else if (j &gt;= nums2.length) {\n                nums[k] = nums1[i];\n                i++;\n            } else if (nums1[i] &lt;= nums2[j]) {\n                nums[k] = nums1[i];\n                i++;\n            } else {\n                nums[k] = nums2[j];\n                j++;\n            }\n        }\n\n        return nums;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-stack/#quick-sort-with-stack","title":"Quick Sort with Stack","text":"<p>If we call the sort method with array {2,4,5,7,1,2,3,6}, it will return a stack, which contains {1,2,2,3,4,5,6,7}, 7 is at top.</p> <pre><code>import java.util.Stack;\n\npublic class StackQuickSort {\n    public Stack&lt;Integer&gt; sort(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n        quickHelper(nums, 0, nums.length - 1);\n\n        Stack&lt;Integer&gt; finalStack = new Stack&lt;&gt;();\n        for (int i : nums) {\n            finalStack.push(i);\n        }\n\n        return finalStack;\n    }\n\n    private void quickHelper(int[] nums, int start, int end) {\n        if (start &gt;= end) {\n            return;\n        }\n\n        /*int pivot = partition(nums, start, end);\n        quickHelper(nums, start, pivot - 1);\n        quickHelper(nums, pivot + 1, end);*/\n\n        // use stack to implement the recursion(implicit stack).\n        Stack&lt;int[]&gt; stack = new Stack&lt;int[]&gt;();\n        stack.push(new int[] {0, end});\n        while (!stack.isEmpty()) {\n            while (start &lt;= end) {\n                int pivot = partition(nums, start, end);\n                stack.push(new int[] {pivot + 1, end}); // execute second recursive call\n                end = pivot - 1;  // execute first recursive call\n            }\n            int[] next = stack.pop();  // fetch next recursive call to execute\n            start = next[0];\n            end = next[1];\n        }\n    }   \n\n    // one way\n    private int partition(int[] nums, int start, int end) {\n        int pivot = start; // select the first as the pivot\n\n        for (int i = start + 1; i &lt;= end; i++) {\n            if (nums[i] &lt; nums[start]) {\n                pivot++;\n                int temp = nums[pivot];\n                nums[pivot] = nums[i];\n                nums[i] = temp;\n            }\n        }\n\n        int temp = nums[pivot];\n        nums[pivot] = nums[start];\n        nums[start] = temp;\n        return pivot;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-stack/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 155 - Min Stack</li> <li>LeetCode 232 - Implement Queue using Stacks</li> <li>LeetCode 84 - Largest Rectangle in histogram</li> <li>LintCode 367 - Expression Tree Build</li> <li>LintCode 370 - Convert Expression to Reverse Polish Notation</li> <li>LintCode 368 - Expression Evaluation</li> </ul>"},{"location":"data-structure/data-structure-stack/#source-files","title":"Source files","text":"<ul> <li>Source files for Stack on GitHub</li> <li>Stack Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-stack/#reference","title":"Reference","text":"<ul> <li>Data Structure and Algorithms - Stack</li> <li>Stacks and Queues</li> <li>Stack</li> <li>Using Stacks for a Non-Recursive MergeSort?</li> <li>Implementing Quicksort with a Stack</li> </ul>"},{"location":"data-structure/data-structure-topological-sorting/","title":"Data Structure - Topological Sorting","text":"<p>Topological Sorting and related questions.</p>"},{"location":"data-structure/data-structure-topological-sorting/#topological-sorting","title":"Topological Sorting","text":"<p>In computer science, a topological sort or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge <code>uv</code> from vertex <code>u</code> to vertex <code>v</code>, u comes before v in the ordering.</p> <ul> <li>indegree</li> <li>outdegree</li> </ul>"},{"location":"data-structure/data-structure-topological-sorting/#problem-1-description","title":"Problem 1 Description","text":"<p>Given an directed graph, a topological order of the graph nodes is defined as follow:</p> <ul> <li>For each directed edge <code>A -&gt; B</code> in graph, A must before B in the order list.</li> <li>The first node in the order can be any node in the graph with no nodes direct to it.</li> </ul> <p>Find any topological order for the given graph.</p> <p>Example: For graph as follow: </p> <p>The topological order can be:</p> <pre><code>[0, 1, 2, 3, 4, 5]\n[0, 2, 3, 1, 5, 4]\n...\n</code></pre>"},{"location":"data-structure/data-structure-topological-sorting/#solution-1","title":"Solution 1","text":"<p>Calculate InDegree, use BFS approach.</p> <pre><code>public class DirectedGraphNode {\n    int label;\n    List&lt;DirectedGraphNode&gt; neighbors;\n    public DirectedGraphNode(int x) {\n        label = x;\n        neighbors = new ArrayList&lt;&gt;();\n    }\n}\n\npublic class TopologicalSorting {\n    /*\n     * @param graph: A list of Directed graph node\n     * @return: Any topological order for the given graph.\n     */\n    public List&lt;DirectedGraphNode&gt; topSort(List&lt;DirectedGraphNode&gt; graph) {\n        if (graph == null || graph.size() == 0) {\n            return null;\n        }\n        // calculate indegree\n        Map&lt;DirectedGraphNode, Integer&gt; map = new HashMap&lt;&gt;();\n        for (DirectedGraphNode node : graph) {\n            for (DirectedGraphNode neighbor : node.neighbors) {\n                map.put(neighbor, map.getOrDefault(neighbor, 0) + 1);\n            }\n        }\n\n        List&lt;DirectedGraphNode&gt; ans = new ArrayList&lt;&gt;();\n        // queue\n        Queue&lt;DirectedGraphNode&gt; queue = new LinkedList&lt;&gt;();\n        for (DirectedGraphNode node : graph) {\n            if (!map.containsKey(node)) {\n                queue.offer(node);\n                ans.add(node);\n            }\n        }\n\n        // bfs\n        while (!queue.isEmpty()) {\n            DirectedGraphNode node = queue.poll();\n            for (DirectedGraphNode neighbor : node.neighbors) {\n                map.put(neighbor, map.get(neighbor) - 1);\n                if (map.get(neighbor) == 0) {\n                    queue.offer(neighbor);\n                    ans.add(neighbor);\n                }\n            }\n        }\n\n        return ans;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-topological-sorting/#course-schedule","title":"Course Schedule","text":""},{"location":"data-structure/data-structure-topological-sorting/#problem-2-description","title":"Problem 2 Description","text":"<p>There are a total of <code>numCourses</code> courses you have to take, labeled from <code>0</code> to <code>numCourses-1</code>.</p> <p>Some courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: <code>[0,1]</code>.</p> <p>Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?</p> <p>Example 1:</p> <pre><code>Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true\nExplanation: There are a total of 2 courses to take.\n             To take course 1 you should have finished course 0. So it is possible.\n</code></pre> <p>Example 2:</p> <pre><code>Input: numCourses = 2, prerequisites = [[1,0],[0,1]]\nOutput: false\nExplanation: There are a total of 2 courses to take.\n             To take course 1 you should have finished course 0, and to take course 0 you should\n             also have finished course 1. So it is impossible.\n</code></pre>"},{"location":"data-structure/data-structure-topological-sorting/#solution-2","title":"Solution 2","text":"<p>Topological Sorting, check if the number of visited course during BFS are same with the total number of courses.</p> <pre><code>public boolean canFinish(int numCourses, int[][] prerequisites) {\n    if (numCourses &lt;= 0) {\n        return false;\n    }\n    if (prerequisites == null || prerequisites.length == 0) {\n        return true;\n    }\n\n    Map&lt;Integer, List&lt;Integer&gt;&gt; graph = new HashMap&lt;&gt;();\n\n    int[] indegree = new int[numCourses];\n    for (int[] pre : prerequisites) {\n        indegree[pre[0]]++;\n        if (!graph.containsKey(pre[1])) {\n            graph.put(pre[1], new ArrayList&lt;&gt;());\n        }\n        graph.get(pre[1]).add(pre[0]);\n    }\n\n    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n    for (int i = 0; i &lt; numCourses; i++) {\n        if (indegree[i] == 0) {\n            queue.offer(i);\n        }\n    }\n\n    int count = 0;\n    while (!queue.isEmpty()) {\n        int course = queue.poll();\n        count++;\n        if (graph.containsKey(course)) {\n            for (Integer nextCourse : graph.get(course)) {\n                indegree[nextCourse]--;\n                if (indegree[nextCourse] == 0) {\n                    queue.offer(nextCourse);\n                }\n            }\n        }\n    }\n\n    return count == numCourses;\n}\n</code></pre>"},{"location":"data-structure/data-structure-topological-sorting/#alien-dictionary","title":"Alien Dictionary","text":""},{"location":"data-structure/data-structure-topological-sorting/#problem-3-description","title":"Problem 3 Description","text":"<p>There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.</p> <ul> <li>You may assume all letters are in lowercase.</li> <li>The dictionary is invalid, if a is prefix of b and b is appear before a.</li> <li>If the order is invalid, return an empty string.</li> <li>There may be multiple valid order of letters, return the smallest in normal lexicographical order</li> </ul> <p>Examples:</p> <p>Example 1:</p> <pre><code>Input\uff1a[\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]\nOutput\uff1a\"wertf\"\nExplanation\uff1a\nfrom \"wrt\"and\"wrf\" ,we can get 't'&lt;'f'\nfrom \"wrt\"and\"er\" ,we can get 'w'&lt;'e'\nfrom \"er\"and\"ett\" ,we can get 'r'&lt;'t'\nfrom \"ett\"and\"rftt\" ,we can get 'e'&lt;'r'\nSo return \"wertf\"\n</code></pre> <p>Example 2:</p> <pre><code>Input\uff1a[\"z\",\"x\"]\nOutput\uff1a\"zx\"\nExplanation\uff1a\nfrom \"z\" and \"x\"\uff0cwe can get 'z' &lt; 'x'\nSo return \"zx\"\n</code></pre>"},{"location":"data-structure/data-structure-topological-sorting/#solution-3","title":"Solution 3","text":"<p>Compare each word with its neighbor to calculate the indegree of each appeared character, then use topological sorting to find the letters in sequence.</p> <pre><code>/**\n * @param words: a list of words\n * @return: a string which is correct order\n */\npublic String alienOrder(String[] words) {\n    if (words == null || words.length == 0) {\n        return \"\";\n    }\n\n    // initialize degree\n    Map&lt;Character, Integer&gt; indegree = new HashMap&lt;&gt;();\n    for (String word : words) {\n        for (char c : word.toCharArray()) {\n            indegree.put(c, 0);\n        }\n    }\n\n    Map&lt;Character, List&lt;Character&gt;&gt; graph = new HashMap&lt;&gt;();\n    for (int i = 1; i &lt; words.length; i++) {\n        String word1 = words[i - 1];\n        String word2 = words[i];\n        for (int j = 0; j &lt; Math.min(word1.length(), word2.length()); j++) {\n            char c1 = word1.charAt(j);\n            char c2 = word2.charAt(j);\n            if (c1 != c2) {\n                if (!graph.containsKey(c1)) {\n                    graph.put(c1, new ArrayList&lt;&gt;());\n                }\n                graph.get(c1).add(c2);\n                indegree.put(c2, indegree.get(c2) + 1);\n                break;\n            }\n        }\n    }\n\n    // use PriorityQueue instead of LinkedList for case \"zy\",\"zx\" -&gt; \"yxz\"\n    Queue&lt;Character&gt; queue = new PriorityQueue&lt;&gt;();\n    for (char c : indegree.keySet()) {\n        if (indegree.get(c) == 0) {\n            queue.offer(c);\n        }\n    }\n\n    StringBuilder sb = new StringBuilder();\n    while (!queue.isEmpty()) {\n        char c = queue.poll();\n        sb.append(c);\n        if (graph.containsKey(c)) {\n            for (char nextchar : graph.get(c)) {\n                indegree.put(nextchar, indegree.get(nextchar) - 1);\n                if (indegree.get(nextchar) == 0) {\n                    queue.offer(nextchar);\n                }\n            }\n        }\n    }\n\n    return sb.length() == indegree.size() ? sb.toString() : \"\";\n}\n</code></pre>"},{"location":"data-structure/data-structure-topological-sorting/#classic-problems","title":"Classic Problems","text":"<ul> <li>LintCode 127 - Topological Sorting</li> <li>LeetCode 207 - Course Schedule</li> <li>LeetCode 269 - Alien Dictionary</li> </ul>"},{"location":"data-structure/data-structure-topological-sorting/#source-files","title":"Source files","text":"<ul> <li>Source files for Topological Sorting on GitHub</li> </ul>"},{"location":"data-structure/data-structure-topological-sorting/#reference","title":"Reference","text":"<ul> <li>Topological Sorting</li> </ul>"},{"location":"data-structure/data-structure-trie/","title":"Data Structure - Trie","text":"<p>A Trie (pronounced try) or Prefix Tree is an ordered tree in which characters are stored at each node. Each path down the tree may represent a word.</p>"},{"location":"data-structure/data-structure-trie/#usage-of-trie","title":"Usage of Trie","text":"<p>Very commonly, a trie is used to store the entire (English) language for quick prefix lookups. While a hash table can quickly look up whether a string is a valid word, however it cannot tell us if a string is a prefix of any valid words. A trie can do this very quickly.</p> <p>Below picture shows how words are stored in trie. This trie stores five words: dog, dot, pump, fat, fire. Each node has a hashmap and a flag to indicate whether the current node is a leaf(a complete path for a word). </p> <ul> <li>In trie, each path from root to any node represents a word.</li> <li>It is not necessary that leaf has to be the node without children. For example, suppose 'dog' and 'dot' are words in this trie. Then, node 'g' and node 't' are obviously marked as leaves. If word 'do' is also in this trie, then node 'o' is also marked as leaf, even if it has two children, 'g' and 't'.</li> </ul>"},{"location":"data-structure/data-structure-trie/#common-operations-on-trie","title":"Common Operations on Trie","text":"<ul> <li>Search</li> <li>Insertion</li> <li>Deletion</li> </ul>"},{"location":"data-structure/data-structure-trie/#search","title":"Search","text":"<p>Given a trie as follows, search word 'dot'.  There are two search approaches in trie.</p> <ul> <li>Find whether the given word exists.</li> <li>Find whether any word starts with the given prefix exists.</li> </ul> <p>Both approaches have the similar search pattern. To search a given word in Trie, we first convert the word to chars. Then start comparing each of them with trie node from root. If the current character is present in the node, move forward to its children. Recursively doing this until all of the characters are found.</p> <p>Trie is constructed with nodes recursively. The following example shows how Trie node is defined.</p> <pre><code>public class TrieNode {\n    public Map&lt;Character, TrieNode&gt; children;\n    public boolean leaf;\n\n    public TrieNode() {\n        children = new HashMap&lt;Character, TrieNode&gt;();\n        leaf = false;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-trie/#searching-prefix","title":"Searching Prefix","text":"<pre><code>// Return true if there is any word in trie that starts with the given prefix\npublic boolean startsWith(String prefix) {\n    if (searchNode(prefix) == null) {\n        return false;\n    } else {\n        return true;\n    }\n}\n\nprivate TrieNode searchNode(String str) {\n    TrieNode current = root;\n\n    for (int i = 0; i &lt; str.length(); i++) {\n        char ch = str.charAt(i);\n        if (current.children.containsKey(ch)) {\n            current = current.children.get(ch);\n        } else {\n            return null;\n        }\n    }\n\n    return current;\n}\n</code></pre>"},{"location":"data-structure/data-structure-trie/#searching-entire-word","title":"Searching Entire Word","text":"<p>Similar with prefix search, add additional check whether the node is leaf.</p> <pre><code>// Return true if the word is in trie\npublic boolean search(String word) {\n    TrieNode tn = searchNode(word);\n    if (tn != null &amp;&amp; tn.leaf) {\n        return true;\n    } else {\n        return false;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-trie/#searching-words-with-same-prefix","title":"Searching Words with Same Prefix","text":"<p>Return all words which start with the given prefix, check if the node is leaf.</p> <pre><code>// Return all words which start with the given prefix\npublic List&lt;String&gt; searchWords(String prefix) {\n    TrieNode current = root;\n    StringBuilder sb = new StringBuilder();\n\n    for (int i = 0; i &lt; prefix.length(); i++) {\n        char ch = prefix.charAt(i);\n        if (!current.children.containsKey(ch)) {\n            return null;\n        } else {\n            sb.append(ch);\n            current = current.children.get(ch);\n        }\n    }\n\n    List&lt;String&gt; list = new ArrayList&lt;&gt;();\n    dfs(current, sb.toString(), list);\n\n    return list;\n}\n\nprivate void dfs(TrieNode node, String prefix, List&lt;String&gt; list) {\n    if (node.leaf) {\n        list.add(prefix);\n    }\n    for (Map.Entry&lt;Character, TrieNode&gt; entry : node.children.entrySet()) {\n        dfs(entry.getValue(), prefix + entry.getKey(), list);\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-trie/#insertion","title":"Insertion","text":"<p>Given a trie as follows, insert new word 'firm' into this trie.  We start searching the given word from root till we cannot find one particular character. Then we construct new trie nodes recursively for the rest characters. In the end, set the leaf attribute of the last node to true.</p> <p>One case needs to be noticed here. If the new word(eg. 'do') is prefix of other words(word 'do' is prefix of word 'dot'),  we just need to mark the last node(eg. node 'o') of the new word as leaf without creating any new node. Even though node 'o' has children, it is marked as leaf since the path from root to node 'o' represents word 'do'.  Below is the implementation of the insert method.</p> <pre><code>// Insert a word into trie\npublic void insert(String word) {\n    TrieNode current = root;\n\n    for (int i = 0; i &lt; word.length(); i++) {\n        char ch = word.charAt(i);\n        if (!current.children.containsKey(ch)) {\n            current.children.put(ch, new TrieNode());\n        }\n        current = current.children.get(ch);\n    }\n\n    current.leaf = true;\n}\n</code></pre>"},{"location":"data-structure/data-structure-trie/#deletion","title":"Deletion","text":"<p>There are three cases when deleting a word from Trie.</p> <ul> <li>Word is prefix of other words.</li> <li>Word has prefix of other words.</li> <li>Word is unique, neither it is prefix of other words, nor it has prefix of other words.</li> </ul>"},{"location":"data-structure/data-structure-trie/#word-is-prefix-of-other-words","title":"Word Is Prefix of Other Words","text":"<p>Word 'do' is the prefix of word 'dot' and 'dog'.  The solution is easy, just unmark the leaf node. The leaf node for word 'do' is node 'o'.</p>"},{"location":"data-structure/data-structure-trie/#word-has-prefix-of-other-words","title":"Word Has Prefix of Other Words","text":"<p>Word 'fat' has same prefix with word 'fire'. They share the prefix 'f'.  If word has prefix of other words, then delete nodes from prefix to end of the word.</p>"},{"location":"data-structure/data-structure-trie/#word-is-unique","title":"Word Is Unique","text":"<p>Word 'pump' is a standalone word. It doesn't share any prefix with others.  If word neither is prefix of other words, nor has prefix of other words, then just delete all the nodes.</p> <p>The following implementation covers all above scenarios.</p> <pre><code>public boolean delete(String word) {\n    TrieNode current = root;\n    TrieNode lastBranchNode = null;\n    Character lastBrachChar = null;\n\n    for (int i = 0; i &lt; word.length(); i++) {\n        char ch = word.charAt(i);\n        if (current.children.containsKey(ch)) {\n            if (current.children.size() &gt; 1) {\n                lastBranchNode = current;\n                lastBrachChar = ch;\n            }\n            current = current.children.get(ch);\n        } else {\n            // word not found\n            return false;\n        }\n    }\n\n    if (current.children.size() &gt; 0) {\n        // case 1: The to-be deleted word is prefix of another long word in trie.\n        current.leaf = false;\n        return true;\n    }\n\n    if (lastBranchNode != null) {\n        // case 2: The to-be deleted word has other words as prefix\n        lastBranchNode.children.remove(lastBrachChar);\n        return true;\n    } else {\n        // case 3: The to-be deleted word present as unique word\n        root.children.remove(word.charAt(0));\n        return true;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-trie/#trie-variants","title":"Trie Variants","text":""},{"location":"data-structure/data-structure-trie/#trie-node","title":"Trie Node","text":"<p>If the words contains only lower-case letters, then we can define Trie Node with array instead of hashmap.</p> <pre><code>public class TrieNode {\n    public TrieNode[] children;\n    public boolean leaf;\n\n    public TrieNode() {\n        children = new TrieNode[26];\n        leaf = false;\n    }\n}\n</code></pre>"},{"location":"data-structure/data-structure-trie/#classic-problems","title":"Classic Problems","text":"<ul> <li>LeetCode 212 - Word Search II</li> </ul>"},{"location":"data-structure/data-structure-trie/#source-files","title":"Source files","text":"<ul> <li>Source files for Trie on GitHub</li> <li>Trie Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"data-structure/data-structure-trie/#reference","title":"Reference","text":"<ul> <li>Trie - Insert and Search</li> <li>Trie - Delete</li> <li>Trie Data Structure Video on Youtube</li> <li>The Trie Data Structure (Prefix Tree)</li> </ul>"},{"location":"design-pattern/design-pattern-adapter/","title":"Adapter","text":"<p>The Adapter pattern allows otherwise incompatible classes to work together by converting the interface of one class into an interface expected by the clients.</p>"},{"location":"design-pattern/design-pattern-adapter/#example","title":"Example","text":"<pre><code>public class Line {\n    public void draw(int x1, int y1, int x2, int y2) {\n        System.out.println(\"Line from point (\" + x1 + \",\" + y1 + \"), to point (\" + x2 + \",\" + y2 + \")\");\n    }\n}\n\npublic class Rectangle {\n    public void draw(int x, int y, int width, int height) {\n        System.out.println(\"Rectangle with coordinate left-down point (\" + x + \",\" + y + \"), width: \" + width\n                + \", height: \" + height);\n    }\n}\n\npublic class ProblematicClient {\n    public void run() {\n        Object[] shapes = {new Line(), new Rectangle()};\n        int x1 = 10, y1 = 20;\n        int x2 = 30, y2 = 60;\n        int width = 40, height = 40;\n        for (Object shape : shapes) {\n            if (shape.getClass().getSimpleName().equals(\"Line\")) {\n                ((Line)shape).draw(x1, y1, x2, y2);\n            } else if (shape.getClass().getSimpleName().equals(\"Rectangle\")) {\n                ((Rectangle)shape).draw(x2, y2, width, height);\n            }\n        }\n    }\n}\n</code></pre> <p>With Adapter.</p> <pre><code>public interface Shape {\n    void draw(int x, int y, int z, int j);\n}\n\npublic class LineAdapter implements Shape {\n    private Line adaptee;\n\n    public LineAdapter(Line line) {\n        this.adaptee = line;\n    }\n\n    @Override\n    public void draw(int x1, int y1, int x2, int y2) {\n        adaptee.draw(x1, y1, x2, y2);\n    }\n}\n\npublic class RectangleAdapter implements Shape {\n    private Rectangle adaptee;\n\n    public RectangleAdapter(Rectangle rectangle) {\n        this.adaptee = rectangle;\n    }\n\n    @Override\n    public void draw(int x1, int y1, int x2, int y2) {\n        int x = Math.min(x1, x2);\n        int y = Math.min(y1, y2);\n        int width = Math.abs(x2 - x1);\n        int height = Math.abs(y2 - y1);\n        adaptee.draw(x, y, width, height);\n    }\n}\n\npublic class Client {\n    public void run() {\n        Shape[] shapes = {new LineAdapter(new Line()),\n                new RectangleAdapter(new Rectangle())};\n        int x1 = 10, y1 = 20;\n        int x2 = 30, y2 = 60;\n        for (Shape shape : shapes) {\n            shape.draw(x1, y1, x2, y2);\n        }\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-adapter/#source-files","title":"Source files","text":"<ul> <li>Source files for Adapter Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-adapter/#references","title":"References","text":"<ul> <li>Adapter in Java: Before and after</li> </ul>"},{"location":"design-pattern/design-pattern-bridge/","title":"Bridge","text":"<p>The Bridge pattern decouples an abstraction from its implementation, so that the two can vary independently.</p>"},{"location":"design-pattern/design-pattern-bridge/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-bridge/#workshop","title":"Workshop","text":"<pre><code>public interface Workshop {\n    abstract public void work();\n}\n\npublic class Produce implements Workshop {\n    @Override\n    public void work()\n    {\n        System.out.print(\"Produced\");\n    }\n}\n\npublic class Assemble implements Workshop {\n    @Override\n    public void work()\n    {\n        System.out.print(\" And\");\n        System.out.println(\" Assembled.\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-bridge/#vehicle","title":"Vehicle","text":"<pre><code>public abstract class Vehicle {\n    protected Workshop workShop1;\n    protected Workshop workShop2;\n\n    protected Vehicle(Workshop workShop1, Workshop workShop2)\n    {\n        this.workShop1 = workShop1;\n        this.workShop2 = workShop2;\n    }\n\n    abstract public void manufacture();\n}\n\npublic class Bike extends Vehicle {\n    public Bike(Workshop workShop1, Workshop workShop2)\n    {\n        super(workShop1, workShop2);\n    }\n\n    @Override\n    public void manufacture()\n    {\n        System.out.print(\"Bike \");\n        workShop1.work();\n        workShop2.work();\n    }\n}\n\npublic class Car extends Vehicle {\n    public Car(Workshop workShop1, Workshop workShop2)\n    {\n        super(workShop1, workShop2);\n    }\n\n    @Override\n    public void manufacture()\n    {\n        System.out.print(\"Car \");\n        workShop1.work();\n        workShop2.work();\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-bridge/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        Vehicle vehicle1 = new Car(new Produce(), new Assemble());\n        vehicle1.manufacture();\n        Vehicle vehicle2 = new Bike(new Produce(), new Assemble());\n        vehicle2.manufacture();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Car Produced And Assembled.\nBike Produced And Assembled.\n</code></pre>"},{"location":"design-pattern/design-pattern-bridge/#source-files","title":"Source files","text":"<ul> <li>Source files for Bridge Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-bridge/#references","title":"References","text":"<ul> <li>Bridge Design Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-builder/","title":"Builder","text":"<p>The Builder pattern separates the construction of a complex object from its representation so that the same construction process can create different representations.</p>"},{"location":"design-pattern/design-pattern-builder/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-builder/#pizza","title":"Pizza","text":"<pre><code>public class Pizza {\n    private String dough = \"\";\n    private String sauce = \"\";\n    private String topping = \"\";\n\n    public void setDough(String dough) {\n        this.dough = dough;\n    }\n\n    public void setSauce(String sauce) {\n        this.sauce = sauce;\n    }\n\n    public void setTopping(String topping) {\n        this.topping = topping;\n    }\n\n    @Override\n    public String toString() {\n        return \"Dough: \" + dough + \",Sauce: \" + sauce + \",Topping: \" + topping;\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-builder/#pizza-builder","title":"Pizza Builder","text":"<pre><code>public abstract class PizzaBuilder {\n    protected Pizza pizza;\n\n    public Pizza getPizza() {\n        return pizza;\n    }\n\n    public void createPizza() {\n        pizza = new Pizza();\n    }\n\n    public abstract void buildDough();\n    public abstract void buildSauce();\n    public abstract void buildTopping();\n}\n\npublic class CheesePizzaBuilder extends PizzaBuilder {\n    public void buildDough() {\n        pizza.setDough(\"cross\");\n    }\n\n    public void buildSauce() {\n        pizza.setSauce(\"tomato\");\n    }\n\n    public void buildTopping() {\n        pizza.setTopping(\"cheese\");\n    }\n}\n\npublic class PepperoniPizzaBuilder extends PizzaBuilder {\n    public void buildDough() {\n        pizza.setDough(\"pan baked\");\n    }\n\n    public void buildSauce() {\n        pizza.setSauce(\"hot\");\n    }\n\n    public void buildTopping() {\n        pizza.setTopping(\"pepperoni + salami\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-builder/#waiter","title":"Waiter","text":"<pre><code>public class Waiter {\n    private PizzaBuilder pizzaBuilder;\n\n    public void setPizzaBuilder(PizzaBuilder pb) {\n        pizzaBuilder = pb;\n    }\n\n    public Pizza getPizza() {\n        return pizzaBuilder.getPizza();\n    }\n\n    public void constructPizza() {\n        pizzaBuilder.createPizza();\n        pizzaBuilder.buildDough();\n        pizzaBuilder.buildSauce();\n        pizzaBuilder.buildTopping();\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-builder/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        Waiter waiter = new Waiter();\n        PizzaBuilder cheesePizzaBuilder = new CheesePizzaBuilder();\n        PizzaBuilder pepperoniPizzaBuilder = new PepperoniPizzaBuilder();\n\n        waiter.setPizzaBuilder( pepperoniPizzaBuilder );\n        waiter.constructPizza();\n\n        Pizza pizza = waiter.getPizza();\n        System.out.println(pizza);\n    }\n}\n</code></pre> <p>Output</p> <pre><code>Dough: pan baked,Sauce: hot,Topping: pepperoni + salami\n</code></pre>"},{"location":"design-pattern/design-pattern-builder/#source-files","title":"Source files","text":"<ul> <li>Source files for Builder Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-builder/#references","title":"References","text":"<ul> <li>Builder Design Pattern</li> <li>Builder in Java</li> </ul>"},{"location":"design-pattern/design-pattern-command/","title":"Command","text":"<p>The Command pattern allows requests to be encapsulated as objects, thereby allowing clients to be parametrized with different requests. Command decouples the object that invokes the operation from the one that knows how to perform it.</p>"},{"location":"design-pattern/design-pattern-command/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-command/#command-interface","title":"Command interface","text":"<pre><code>public interface Command {\n    void execute();\n}\n\npublic class Buy implements Command {\n    public void execute() {\n        System.out.println(\"Buy stock\");\n    }\n}\n\npublic class Sell implements Command {\n    public void execute() {\n        System.out.println(\"Sell stock\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-command/#broker","title":"Broker","text":"<pre><code>public class Broker {\n    private List&lt;Command&gt; cmdList = new ArrayList&lt;&gt;();\n\n    public void acceptCommand(Command cmd){\n        cmdList.add(cmd);\n    }\n\n    public void executeCommand(){\n        for (Command cmd : cmdList) {\n            cmd.execute();\n        }\n        cmdList.clear();\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-command/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        Buy buyStock = new Buy();\n        Sell sellStock = new Sell();\n\n        Broker broker = new Broker();\n        broker.acceptCommand(buyStock);\n        broker.acceptCommand(sellStock);\n\n        broker.executeCommand();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Buy stock\nSell stock\n</code></pre>"},{"location":"design-pattern/design-pattern-command/#source-files","title":"Source Files","text":"<ul> <li>Source files for Command Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-command/#references","title":"References","text":"<ul> <li>Design Patterns - Command Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-composite/","title":"Composite","text":"<p>The Composite pattern is used where we need to treat a group of objects in similar way as a single object. Composite pattern composes objects in term of a tree structure to represent part as well as whole hierarchy.</p>"},{"location":"design-pattern/design-pattern-composite/#example","title":"Example","text":"<pre><code>public class File {\n    private String name;\n\n    public File(String name) {\n        this.name = name;\n    }\n\n    public void ls() {\n        System.out.println(\"File:\" + name);\n    }\n}\n\npublic class Directory {\n    private String name;\n    private ArrayList includedFiles = new ArrayList();\n\n    public Directory(String name) {\n        this.name = name;\n    }\n\n    public void add(Object obj) {\n        includedFiles.add(obj);\n    }\n\n    public void ls() {\n        System.out.println(\"Directory: \" + name);\n        for (Object obj : includedFiles) {\n            // Recover the type of this object\n            String name = obj.getClass().getSimpleName();\n            if (name.equals(\"Directory\")) {\n                ((Directory)obj).ls();\n            } else {\n                ((File)obj).ls();\n            }\n        }\n    }\n}\n\npublic class ProblematicClient {\n    public void run() {\n        Directory music = new Directory(\"MUSIC\");\n        Directory scorpions = new Directory(\"SCORPIONS\");\n        Directory dio = new Directory(\"DIO\");\n        File track1 = new File(\"Don't wary, be happy.mp3\");\n        File track2 = new File(\"track2.m3u\");\n        File track3 = new File(\"Wind of change.mp3\");\n        File track4 = new File(\"Big city night.mp3\");\n        File track5 = new File(\"Rainbow in the dark.mp3\");\n        music.add(track1);\n        music.add(scorpions);\n        music.add(track2);\n        scorpions.add(track3);\n        scorpions.add(track4);\n        scorpions.add(dio);\n        dio.add(track5);\n        music.ls();\n    }\n}\n</code></pre> <p>With Composite Pattern.</p> <pre><code>public interface AbstractFile {\n    void ls();\n}\n\npublic class File implements AbstractFile {\n    private String name;\n\n    public File(String name) {\n        this.name = name;\n    }\n\n    public void ls() {\n        System.out.println(\"File:\" + name);\n    }\n}\n\npublic class Directory implements AbstractFile {\n    private String name;\n    private ArrayList includedFiles = new ArrayList();\n\n    public Directory(String name) {\n        this.name = name;\n    }\n\n    public void add(Object obj) {\n        includedFiles.add(obj);\n    }\n\n    public void ls() {\n        System.out.println(\"Directory: \" + name);\n        for (Object includedFile : includedFiles) {\n            // Leverage the \"lowest common denominator\"\n            AbstractFile obj = (AbstractFile)includedFile;\n            obj.ls();\n        }\n    }\n}\n\npublic class Client {\n    public void run() {\n        Directory music = new Directory(\"MUSIC\");\n        Directory scorpions = new Directory(\"SCORPIONS\");\n        Directory dio = new Directory(\"DIO\");\n        File track1 = new File(\"Don't wary, be happy.mp3\");\n        File track2 = new File(\"track2.m3u\");\n        File track3 = new File(\"Wind of change.mp3\");\n        File track4 = new File(\"Big city night.mp3\");\n        File track5 = new File(\"Rainbow in the dark.mp3\");\n        music.add(track1);\n        music.add(scorpions);\n        music.add(track2);\n        scorpions.add(track3);\n        scorpions.add(track4);\n        scorpions.add(dio);\n        dio.add(track5);\n        music.ls();\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-composite/#source-files","title":"Source files","text":"<ul> <li>Source files for Composite Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-composite/#references","title":"References","text":"<ul> <li>Composite in Java: Before and after</li> </ul>"},{"location":"design-pattern/design-pattern-decorator/","title":"Decorator","text":"<p>The Decorator pattern allows a user to add new functionality to an existing object without altering its structure. This pattern creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact.</p>"},{"location":"design-pattern/design-pattern-decorator/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-decorator/#shapes","title":"Shapes","text":"<pre><code>public interface Shape {\n    void draw();\n}\n\npublic class Circle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Shape: Circle\");\n    }\n}\n\npublic class Rectangle implements Shape {\n    @Override\n    public void draw() {\n        System.out.println(\"Shape: Rectangle\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-decorator/#decorators","title":"Decorators","text":"<pre><code>public abstract class ShapeDecorator implements Shape {\n    protected Shape decoratedShape;\n\n    public ShapeDecorator(Shape decoratedShape){\n        this.decoratedShape = decoratedShape;\n    }\n\n    public void draw(){\n        decoratedShape.draw();\n    }\n}\n\npublic class RedShapeDecorator extends ShapeDecorator {\n\n    public RedShapeDecorator(Shape decoratedShape) {\n        super(decoratedShape);\n    }\n\n    @Override\n    public void draw() {\n        decoratedShape.draw();\n        setRedBorder(decoratedShape);\n    }\n\n    private void setRedBorder(Shape decoratedShape){\n        System.out.println(\"Border Color: Red\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-decorator/#client","title":"Client","text":"<pre><code>public class Client {\n    public void draw() {\n        Shape circle = new Circle();\n\n        Shape redCircle = new RedShapeDecorator(new Circle());\n\n        Shape redRectangle = new RedShapeDecorator(new Rectangle());\n        System.out.println(\"Circle with normal border\");\n        circle.draw();\n\n        System.out.println(\"\\nCircle of red border\");\n        redCircle.draw();\n\n        System.out.println(\"\\nRectangle of red border\");\n        redRectangle.draw();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Circle with normal border\nShape: Circle\n\nCircle of red border\nShape: Circle\nBorder Color: Red\n\nRectangle of red border\nShape: Rectangle\nBorder Color: Red\n</code></pre>"},{"location":"design-pattern/design-pattern-decorator/#source-files","title":"Source files","text":"<ul> <li>Source files for Decorator Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-decorator/#references","title":"References","text":"<ul> <li>Design Patterns - Decorator Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-dto/","title":"DTO","text":"<p>Data Transfer Object design pattern for creating objects.</p>"},{"location":"design-pattern/design-pattern-dto/#source-files","title":"Source files","text":""},{"location":"design-pattern/design-pattern-dto/#references","title":"References","text":""},{"location":"design-pattern/design-pattern-facade/","title":"Facade Pattern","text":"<p>The Facade pattern hides the complexities of the system and provides an interface to the client using which the client can access the system.</p>"},{"location":"design-pattern/design-pattern-facade/#implementation","title":"Implementation","text":""},{"location":"design-pattern/design-pattern-facade/#shape","title":"Shape","text":"<pre><code>public interface Shape {\n    void draw();\n}\n\npublic class Circle implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Circle::draw()\");\n    }\n}\n\npublic class Rectangle implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Rectangle::draw()\");\n    }\n}\n\npublic class Square implements Shape {\n\n    @Override\n    public void draw() {\n        System.out.println(\"Square::draw()\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-facade/#facade-class","title":"Facade Class","text":"<pre><code>public class ShapeMaker {\n    private Shape circle;\n    private Shape rectangle;\n    private Shape square;\n\n    public ShapeMaker() {\n        circle = new Circle();\n        rectangle = new Rectangle();\n        square = new Square();\n    }\n\n    public void drawCircle(){\n        circle.draw();\n    }\n    public void drawRectangle(){\n        rectangle.draw();\n    }\n    public void drawSquare(){\n        square.draw();\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-facade/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        ShapeMaker shapeMaker = new ShapeMaker();\n\n        shapeMaker.drawCircle();\n        shapeMaker.drawRectangle();\n        shapeMaker.drawSquare();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Circle::draw()\nRectangle::draw()\nSquare::draw()\n</code></pre>"},{"location":"design-pattern/design-pattern-facade/#source-files","title":"Source files","text":"<ul> <li>Source files for Facade Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-facade/#references","title":"References","text":"<ul> <li>Design Patterns - Facade Pattern</li> <li>Facade Pattern Tutorial with Java Examples</li> </ul>"},{"location":"design-pattern/design-pattern-factory/","title":"Factory","text":""},{"location":"design-pattern/design-pattern-factory/#types-of-factory-pattern","title":"Types of Factory Pattern","text":"<ul> <li>Simple Factory Pattern</li> <li>Abstract Factory Pattern</li> <li>Factory Method Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-factory/#simple-factory-pattern","title":"Simple Factory Pattern","text":"<p>The Simple Factory Pattern defines a technique to encapsulate the details of object creation in a single class known as a \u201cFactory\u201d class whose job it is to create concrete instances of various objects that implement a given interface. The other objects in the application that need new objects created by the factory class are known as \u201cclients\u201d of the factory. By doing this, we ensure the following:</p> <ul> <li>Object creation code appears in one place only (rather than multiple times as in our previous example)</li> <li>Changes to object creation code are limited to the factory class and do not affect the factory\u2019s clients \u2013 changes are made in one place at one time.</li> <li>Clients of the factory class need not (and will not) know the actual concrete class type of the objects that are created for it \u2013 therefore they are not coupled to any concrete classes.</li> <li>The client classes are closed for modification</li> </ul> <p>Aircraft Interface.</p> <pre><code>public interface Aircraft {\n    void load();\n    void takeoff();\n    String getType();\n}\n</code></pre> <p>Factory Class.</p> <pre><code>/*\n * Factory Pattern\n */\npublic class AircraftFactory {\n    // Declare a private constructor to prevent class instances from being created in any other places\n    private AircraftFactory() {}\n\n    // use a static method to get object with the given type\n    public static Aircraft createAircraft(String type) {\n        if (type.equals(\"TroopTransportCraft\")) {\n            return new TroopTransportCraft();\n        } else if (type.equals(\"FighterCraft\")) {\n            return new FighterCraft();\n        } else if (type.equals(\"BomberCraft\")) {\n            return new BomberCraft();\n        } else if (type.equals(\"GunshipCraft\")) {\n            return new GunshipCraft();\n        } else if (type.equals(\"MedicHelicopterCraft\")) {\n            return new MedicHelicopterCraft();\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre> <p>Caller.</p> <pre><code>public class AircraftProcessor {\n    @Deprecated\n    public void process(String type) {\n        Aircraft acft = null;\n        if (type.equals(\"PassengerCraft\")) {\n            acft = new PassengerCraft();\n        } else if (type.equals(\"CargoCraft\")) {\n            acft = new CargoCraft();\n        } else if (type.equals(\"FighterCraft\")) {\n            acft = new FighterCraft();\n        } else if (type.equals(\"BomberCraft\")) {\n            acft = new BomberCraft();\n        }\n\n        acft.load();\n        acft.takeoff();\n    }\n    public void processNew(String type) {\n        Aircraft acft = AircraftFactory.createAircraft(type);\n        acft.load();\n        acft.takeoff();\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-factory/#abstract-factory-pattern","title":"Abstract Factory Pattern","text":"<p>Create interface for factory, then create different factories with implementing the factory interface.</p> <p>AircraftFactory Interface.</p> <pre><code>public interface AircraftFactory {\n    public Aircraft createAircraft(String type);\n}\n</code></pre> <p>USAircraftFactory Class.</p> <pre><code>public class USAircraftFactory implements AircraftFactory {\n    public Aircraft createAircraft(String type) {\n        if (type.equals(\"Bomber\")) {\n            return new USBomberCraft();\n        } else if (type.equals(\"Fighter\")) {\n            return new USFighterCraft();\n        } else if (type.equals(\"Gunship\")) {\n            return new USGunshipCraft();\n        } else if (type.equals(\"Troop\")) {\n            return new USTroopTransportCraft();\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre> <p>BritishAircraftFactory Class.</p> <pre><code>public class BritishAircraftFactory implements AircraftFactory {\n    public Aircraft createAircraft(String type) {\n        if (type.equals(\"Bomber\")) {\n            return new BritishBomberCraft();\n        } else if (type.equals(\"Fighter\")) {\n            return new BritishFighterCraft();\n        } else if (type.equals(\"Gunship\")) {\n            return new BritishGunshipCraft();\n        } else if (type.equals(\"Troop\")) {\n            return new BritishTroopTransportCraft();\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre> <p>Caller.</p> <pre><code>public class AircraftProcessor {\n    private AircraftFactory aircraftFactory = null;\n\n    public AircraftProcessor(AircraftFactory af) {\n        aircraftFactory = af;\n    }\n\n    public void process(String type) {\n        Aircraft acft = aircraftFactory.createAircraft(type);\n        acft.load();\n        acft.takeoff();\n    }\n}\n</code></pre> <ul> <li>Use the given factory to create Aircraft by type.</li> </ul>"},{"location":"design-pattern/design-pattern-factory/#factory-method-pattern","title":"Factory Method Pattern","text":"<p>Create abstract class for factory, then create different factories with extending the base factory class.</p> <p>AircraftFactory abstract class.</p> <pre><code>public abstract class AircraftFactory {\n    public abstract Aircraft createAircraft(String type);\n}\n</code></pre> <p>USAircraftFactory Class.</p> <pre><code>public class USAircraftFactory extends AircraftFactory {\n    public Aircraft createAircraft(String type) {\n        if (type.equals(\"Bomber\")) {\n            return new USBomberCraft();\n        } else if (type.equals(\"Fighter\")) {\n            return new USFighterCraft();\n        } else if (type.equals(\"Gunship\")) {\n            return new USGunshipCraft();\n        } else if (type.equals(\"Troop\")) {\n            return new USTroopTransportCraft();\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre> <p>BritishAircraftFactory Class.</p> <pre><code>public class BritishAircraftFactory extends AircraftFactory {\n    public Aircraft createAircraft(String type) {\n        if (type.equals(\"Bomber\")) {\n            return new BritishBomberCraft();\n        } else if (type.equals(\"Fighter\")) {\n            return new BritishFighterCraft();\n        } else if (type.equals(\"Gunship\")) {\n            return new BritishGunshipCraft();\n        } else if (type.equals(\"Troop\")) {\n            return new BritishTroopTransportCraft();\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre> <p>Caller.</p> <pre><code>public class AircraftProcessor {\n    private AircraftFactory aircraftFactory = null;\n\n    public AircraftProcessor(AircraftFactory af) {\n        aircraftFactory = af;\n    }\n\n    public void process(String type) {\n        Aircraft acft = aircraftFactory.createAircraft(type);\n        acft.load();\n        acft.takeoff();\n    }\n}\n</code></pre> <ul> <li>Use the given factory to create Aircraft by type.</li> </ul>"},{"location":"design-pattern/design-pattern-factory/#source-files","title":"Source files","text":"<ul> <li>Source files for Factory Pattern on GitHub</li> <li>Source files for Abstract Factory Pattern on GitHub</li> <li>Source files for Factory Method Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-flyweight/","title":"Flyweight","text":"<p>The Flyweight pattern is primarily used to reduce the number of objects created and to decrease memory footprint and increase performance.</p> <p>Flyweight pattern tries to reuse already existing similar kind objects by storing them and creates new object when no matching object is found.</p>"},{"location":"design-pattern/design-pattern-flyweight/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-flyweight/#line","title":"Line","text":"<pre><code>public enum Color\n{\n    RED, GREEN, BLUE;\n}\n\npublic interface LineFlyweight {\n    Color getColor();\n    void draw(int x, int y);\n}\n\npublic class Line implements LineFlyweight {\n    private Color color;\n\n    public Line(Color c) {\n        color = c;\n    }\n    public Color getColor() {\n        return color;\n    }\n\n    @Override\n    public void draw(int x, int y) {\n        System.out.println(\"Line: Draw() [Color : \" + color + \", x : \" + x + \", y :\" + y + \"]\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-flyweight/#factory","title":"Factory","text":"<pre><code>public class LineFlyweightFactory {\n    private Map&lt;Color, LineFlyweight&gt; lineMap;\n    public LineFlyweightFactory() {\n        lineMap = new HashMap();\n    }\n    public LineFlyweight getLine(Color c) {\n        //check if we've already created a line with this color\n        if (lineMap.containsKey(c)) {\n            return lineMap.get(c);\n        }\n\n        //if not, create one and save it to the pool\n        LineFlyweight line = new Line(c);\n        lineMap.put(c, line);\n        return line;\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-flyweight/#client","title":"Client","text":"<pre><code>public class Client {\n    private LineFlyweightFactory factory ;\n\n    public Client() {\n        factory = new LineFlyweightFactory();\n    }\n\n    public void draw() {\n        LineFlyweight line1 = factory.getLine(Color.RED);\n        System.out.println(line1);\n        LineFlyweight line2 = factory.getLine(Color.RED); //can use the lines independently\n        System.out.println(line2);\n        if (line1.equals(line2)){\n            System.out.println(\"same\");\n        }\n        line1.draw(100, 100);\n        line2.draw(200, 100);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>testClient\njohnny.designpattern.common.Line@5442a311\njohnny.designpattern.common.Line@5442a311\nsame\nLine: Draw() [Color : RED, x : 100, y :100]\nLine: Draw() [Color : RED, x : 200, y :100]\n</code></pre>"},{"location":"design-pattern/design-pattern-flyweight/#source-files","title":"Source files","text":"<ul> <li>Source files for Flyweight Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-flyweight/#references","title":"References","text":"<ul> <li>Flyweight Pattern Tutorial with Java Examples</li> <li>Design Patterns - Flyweight Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-interpreter/","title":"Interpreter","text":"<p>The Interpreter pattern defines a grammatical representation for a language and an interpreter to interpret the grammar.</p>"},{"location":"design-pattern/design-pattern-interpreter/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-interpreter/#expression","title":"Expression","text":"<pre><code>public interface Expression {\n    String interpret(int num);\n}\n\npublic class IntToBinary implements Expression {\n\n    @Override\n    public String interpret(int num) {\n        String result = Integer.toBinaryString(num);\n        System.out.println(num + \" in Binary = \" + result);\n        return result;\n    }\n}\n\npublic class IntToHex implements Expression {\n\n    @Override\n    public String interpret(int num) {\n        String result = Integer.toHexString(num);\n        System.out.println(num + \" in Hexadecimal = \" + result);\n        return result;\n    }\n}\n\npublic class IntToRoman implements Expression {\n\n    @Override\n    public String interpret(int num) {\n        if (num &lt;= 0) {\n            return \"\";\n        }\n        // 1000,2000,3000\n        String M[] = {\"\", \"M\", \"MM\", \"MMM\"};\n        // 100,200,300,400,500,600,700,800,900,1000\n        String C[] = {\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"};\n        // 10,20,30,40,50,60,70,80,90\n        String X[] = {\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"};\n        // 1,2,3,4,5,6,7,8,9\n        String I[] = {\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"};\n        String result = M[num/1000] + C[(num%1000)/100] + X[(num%100)/10] + I[num%10];\n\n        System.out.println(num + \" in Roman = \" + result);\n        return result;\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-interpreter/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        List&lt;Expression&gt; list = new ArrayList&lt;&gt;();\n        list.add(new IntToBinary());\n        list.add(new IntToHex());\n        list.add(new IntToRoman());\n\n        for (Expression exp : list) {\n            exp.interpret(28);\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>28 in Binary = 11100\n28 in Hexadecimal = 1c\n28 in Roman = XXVIII\n</code></pre>"},{"location":"design-pattern/design-pattern-interpreter/#source-files","title":"Source files","text":"<ul> <li>Source files for Interpreter Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-interpreter/#references","title":"References","text":"<ul> <li>Interpreter Design Pattern in Java</li> </ul>"},{"location":"design-pattern/design-pattern-iterator/","title":"Iterator Pattern","text":"<p>The Iterator pattern is used to get a way to access the elements of a collection object in sequential manner without any need to know its underlying representation. This pattern is widely used in Java Collection Framework. <code>Iterator</code> interface provides methods for traversing through a collection.</p>"},{"location":"design-pattern/design-pattern-iterator/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-iterator/#course","title":"Course","text":"<pre><code>public class Course {\n    private String title;\n    private int credit;\n\n    public Course(String title, int credit) {\n        this.title = title;\n        this.credit = credit;\n    }\n\n    public String getTitle() {\n        return this.title;\n    }\n\n    public int getCredit() {\n        return this.credit;\n    }\n\n    @Override\n    public String toString() {\n        return \"Course {\" +\n                \"title='\" + title + '\\'' +\n                \", credit=\" + credit +\n                '}';\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-iterator/#iterator","title":"Iterator","text":"<pre><code>public interface CourseIterator {\n    public boolean hasNext();\n    public Course next();\n}\n\npublic class CourseIteratorImpl implements CourseIterator {\n\n    private List&lt;Course&gt; courses;\n    private int index;\n\n    public CourseIteratorImpl(List&lt;Course&gt; courseList) {\n        this.courses = courseList;\n    }\n\n    @Override\n    public boolean hasNext() {\n        return index &lt; courses.size();\n    }\n\n    @Override\n    public Course next() {\n        if (index &lt; 0 || index &gt;= courses.size()) {\n            return null;\n        } else {\n            Course c = courses.get(index);\n            index++;\n            return c;\n        }\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-iterator/#collection","title":"Collection","text":"<pre><code>public interface CourseCollection {\n    public void add(Course c);\n\n    public void remove(Course c);\n\n    public CourseIterator iterator();\n}\n\npublic class CourseCollectionImpl implements CourseCollection {\n\n    private List&lt;Course&gt; courses;\n\n    public CourseCollectionImpl() {\n        courses = new ArrayList&lt;&gt;();\n    }\n\n    public void add(Course c) {\n        this.courses.add(c);\n    }\n\n    public void remove(Course c) {\n        this.courses.remove(c);\n    }\n\n    @Override\n    public CourseIterator iterator() {\n        return new CourseIteratorImpl(this.courses);\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-iterator/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        CourseCollection courses = new CourseCollectionImpl();\n        courses.add(new Course(\"Algorithms and Structures\", 5));\n        courses.add(new Course(\"Database Technologies\", 4));\n        courses.add(new Course(\"Mobile App Development\", 3));\n        courses.add(new Course(\"Mining Big Data\", 5));\n        CourseIterator iterator = courses.iterator();\n        while (iterator.hasNext()) {\n            Course c = iterator.next();\n            System.out.println(c.toString());\n        }\n    }\n}\n</code></pre> <p>Output</p> <pre><code>Course {title='Algorithms and Structures', credit=5}\nCourse {title='Database Technologies', credit=4}\nCourse {title='Mobile App Development', credit=3}\nCourse {title='Mining Big Data', credit=5}\n</code></pre>"},{"location":"design-pattern/design-pattern-iterator/#source-files","title":"Source files","text":"<ul> <li>Source files for Iterator Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-iterator/#references","title":"References","text":"<ul> <li>Iterator Design Pattern in Java</li> </ul>"},{"location":"design-pattern/design-pattern-mediator/","title":"Mediator","text":"<p>The Mediator pattern is used to provide a centralized communication medium between different objects in a system.</p>"},{"location":"design-pattern/design-pattern-mediator/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-mediator/#user","title":"User","text":"<pre><code>public class User {\n    private String name;\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public User(String name){\n        this.name  = name;\n    }\n\n    public void sendMessage(String message){\n        ChatRoom.showMessage(this,message);\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-mediator/#chatroom","title":"ChatRoom","text":"<pre><code>public class ChatRoom {\n    public static void showMessage(User user, String message){\n        System.out.println(new Date().toString() + \" [\" + user.getName() + \"] : \" + message);\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-mediator/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        User robert = new User(\"Robert\");\n        User john = new User(\"John\");\n\n        robert.sendMessage(\"Hi! John!\");\n        john.sendMessage(\"Hello! Robert!\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Fri Nov 30 16:08:46 PST 2018 [Robert] : Hi! John!\nFri Nov 30 16:08:46 PST 2018 [John] : Hello! Robert!\n</code></pre>"},{"location":"design-pattern/design-pattern-mediator/#source-files","title":"Source files","text":"<ul> <li>Source files for Mediator Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-mediator/#references","title":"References","text":"<ul> <li>Design Patterns - Mediator Pattern</li> <li>Mediator Design Pattern in Java</li> </ul>"},{"location":"design-pattern/design-pattern-memento/","title":"Memento","text":"<p>The Memento pattern is used to restore state of an object to a previous state. Normally, this pattern defines three distinct roles:</p> <ul> <li>Originator - the object that knows how to save itself.</li> <li>Caretaker - the object that knows why and when the Originator needs to save and restore itself.</li> <li>Memento - the lock box that is written and read by the Originator, and shepherded by the Caretaker.</li> </ul>"},{"location":"design-pattern/design-pattern-memento/#example","title":"Example","text":"<pre><code>public class Memento {\n    private String state;\n\n    public Memento(String state) {\n        this.state = state;\n    }\n\n    public String getState() {\n        return state;\n    }\n}\n\npublic class Caretaker {\n    private ArrayList&lt;Memento&gt; mementos = new ArrayList&lt;&gt;();\n\n    public void addMemento(Memento m) {\n        mementos.add(m);\n    }\n\n    public Memento getMemento() {\n        return mementos.get(1);\n    }\n}\n\npublic class Originator {\n    private String state;\n\n    public void setState(String state) {\n        System.out.println(\"Originator: Setting state to \" + state);\n        this.state = state;\n    }\n\n    public Memento save() {\n        System.out.println(\"Originator: Saving to Memento.\");\n        return new Memento(state);\n    }\n\n    public void restore(Memento m) {\n        state = m.getState();\n        System.out.println(\"Originator: State after restoring from Memento: \" + state);\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-memento/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        Caretaker caretaker = new Caretaker();\n        Originator originator = new Originator();\n        originator.setState(\"State1\");\n        originator.setState(\"State2\");\n        caretaker.addMemento( originator.save() );\n        originator.setState(\"State3\");\n        caretaker.addMemento( originator.save() );\n        originator.setState(\"State4\");\n        originator.restore( caretaker.getMemento() );\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Originator: Setting state to State1\nOriginator: Setting state to State2\nOriginator: Saving to Memento.\nOriginator: Setting state to State3\nOriginator: Saving to Memento.\nOriginator: Setting state to State4\nOriginator: State after restoring from Memento: State3\n</code></pre>"},{"location":"design-pattern/design-pattern-memento/#source-files","title":"Source files","text":"<ul> <li>Source files for Memento Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-memento/#references","title":"References","text":"<ul> <li>Memento Design Pattern</li> <li>Memento in Java</li> </ul>"},{"location":"design-pattern/design-pattern-null-object/","title":"Null Object","text":"<p>The Null Object pattern is used to encapsulate the absence of an object by providing a substitutable alternative that offers suitable default do nothing behavior. In short, a design where \"nothing will come of nothing\".</p> <p>Use the Null Object pattern when:</p> <ul> <li>an object requires a collaborator. The Null Object pattern does not introduce this collaboration--it makes use of a collaboration that already exists</li> <li>some collaborator instances should do nothing</li> <li>you want to abstract the handling of null away from the client</li> </ul>"},{"location":"design-pattern/design-pattern-null-object/#example-of-implementation","title":"Example of Implementation","text":""},{"location":"design-pattern/design-pattern-null-object/#interface","title":"Interface","text":"<pre><code>public interface Shape {\n    double area();\n    double perimeter();\n    void draw();\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-null-object/#classes","title":"Classes","text":"<pre><code>public class Circle implements Shape {\n    private final double radius;\n\n    public Circle (double radius) {\n        this.radius = radius;\n    }\n\n    @Override\n    public double area() {\n        // Area = \u03c0r^2\n        return Math.PI * Math.pow(radius, 2);\n    }\n\n    @Override\n    public double perimeter() {\n        // Perimeter = 2\u03c0r\n        return 2 * Math.PI * radius;\n    }\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing Circle with area: \" + area() + \" and perimeter: \" + perimeter());\n    }\n}\n\npublic class Rectangle implements Shape {\n    private final double width;\n    private final double height;\n\n    public Rectangle (double width, double height) {\n        this.width = width;\n        this.height = height;\n    }\n\n    @Override\n    public double area() {\n        // A = w * h\n        return width * height;\n    }\n\n    @Override\n    public double perimeter() {\n        // P = 2(w + h)\n        return 2 * (width + height);\n    }\n\n    @Override\n    public void draw() {\n     System.out.println(\"Drawing Rectangle with area: \" + area() + \" and perimeter: \" + perimeter());\n    }\n}\n\npublic class Triangle implements Shape {\n    private final double a;\n    private final double b;\n    private final double c;\n\n    public Triangle (double a, double b, double c) {\n        this.a = a;\n        this.b = b;\n        this.c = c;\n    }\n\n    @Override\n    public double area() {\n        // Using Heron's formula:\n        // Area = SquareRoot(s * (s - a) * (s - b) * (s - c))\n        // where s = (a + b + c) / 2, or 1/2 of the perimeter of the triangle\n        double s = (a + b + c) / 2;\n        return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n    }\n\n    @Override\n    public double perimeter() {\n        // P = a + b + c\n        return a + b + c;\n    }\n\n    @Override public void draw() {\n     System.out.println(\"Drawing Triangle with area: \" + area() + \" and perimeter: \" + perimeter());\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-null-object/#problematic-usage","title":"Problematic Usage","text":"<pre><code>public class ShapeFactory {\n    public static Shape createShape(String shapeType) {\n        Shape shape = null;\n        if (\"Circle\".equalsIgnoreCase(shapeType)) {\n            shape = new Circle(3);\n        } else if (\"Rectangle\".equalsIgnoreCase(shapeType)) {\n            shape = new Rectangle(2, 4);\n        } else if (\"Triangle\".equalsIgnoreCase(shapeType)) {\n            shape = new Triangle(3, 4, 5);\n        } // else return null\n\n        return shape;\n    }\n}\n</code></pre> <p>When client using this factory to get shape instance, null-check is required if it returns null object. Otherwise, NullPointerException occurs.</p> <pre><code>public class ShapeProcessor {\n    String[] shapeTypes = new String[] { \"Circle\", \"Triangle\", \"Rectangle\", null};\n\n    public ShapeProcessor () {\n\n    }\n\n    public void process() {\n        for (String shapeType : shapeTypes) {\n            Shape shape = ShapeFactory.createShape(shapeType);\n            if (shape != null) { // null-check is required if factory returns null object\n                System.out.println(\"Shape area: \" + shape.area());\n                System.out.println(\"Shape Perimeter: \" + shape.perimeter());\n                shape.draw();\n                System.out.println();\n            }\n        }\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-null-object/#implementation-with-nullobject-pattern","title":"Implementation with NullObject Pattern","text":"<p>Create 'null' class as default shape.</p> <pre><code>public class NullShape implements Shape {\n\n    public NullShape () {}\n\n    @Override\n    public double area() {\n        return 0.0d;\n    }\n\n    @Override\n    public double perimeter() {\n        return 0.0d;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"Null object can't be drawn\");\n    }\n}\n</code></pre> <p>Factory can now return the null object.</p> <pre><code>public class ShapeFactory {\n    public static Shape createShape(String shapeType) {\n        Shape shape = null;\n        if (\"Circle\".equalsIgnoreCase(shapeType)) {\n            shape = new Circle(3);\n        } else if (\"Rectangle\".equalsIgnoreCase(shapeType)) {\n            shape = new Rectangle(2, 4);\n        } else if (\"Triangle\".equalsIgnoreCase(shapeType)) {\n            shape = new Triangle(3, 4, 5);\n        } else {\n            shape = new NullShape();\n        }\n        return shape;\n    }\n}\n</code></pre> <p>Now, client doesn't need the null check.</p> <pre><code>public class ShapeProcessor {\n    String[] shapeTypes = new String[] { \"Circle\", \"Triangle\", \"Rectangle\", null};\n\n    public ShapeProcessor () {\n\n    }\n\n    public void process() {\n        for (String shapeType : shapeTypes) {\n            Shape shape = ShapeFactory.createShape(shapeType);\n            // no null-check required since shape factory always creates shape objects\n            System.out.println(\"Shape area: \" + shape.area());\n            System.out.println(\"Shape Perimeter: \" + shape.perimeter());\n            shape.draw();\n            System.out.println();\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Shape area: 28.274333882308138\nShape Perimeter: 18.84955592153876\nDrawing Circle with area: 28.274333882308138 and perimeter: 18.84955592153876\n\nShape area: 6.0\nShape Perimeter: 12.0\nDrawing Triangle with area: 6.0 and perimeter: 12.0\n\nShape area: 8.0\nShape Perimeter: 12.0\nDrawing Rectangle with area: 8.0 and perimeter: 12.0\n\nShape area: 0.0\nShape Perimeter: 0.0\nNull object cant be drawn\n</code></pre>"},{"location":"design-pattern/design-pattern-null-object/#source-files","title":"Source files","text":"<ul> <li>Source files for Null Object Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-null-object/#references","title":"References","text":"<ul> <li>Null Object Design Pattern</li> <li>Null Object Pattern in Java</li> </ul>"},{"location":"design-pattern/design-pattern-observer/","title":"Observer","text":"<p>The Observer pattern defines a one-to-many relationship so that when one object changes state, the others are notified and updated automatically.</p>"},{"location":"design-pattern/design-pattern-observer/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-observer/#observer-interface","title":"Observer interface","text":"<pre><code>public interface Observer {\n    public void update(String message);\n}\n\npublic class User implements Observer {\n    private String name;\n    private String message;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    @Override\n    public void update(String message) {\n        this.message = message;\n        read();\n    }\n\n    public void read() {\n        System.out.println(name + \" received message from server: \" + message);\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-observer/#observerable","title":"Observerable","text":"<pre><code>public interface Observerable {\n    public void registerObserver(Observer o);\n    public void removeObserver(Observer o);\n    public void notifyObserver();\n}\n\npublic class MessageServer implements Observerable {\n    private List&lt;Observer&gt; observers;\n    private String message;\n\n    public MessageServer() {\n        observers = new ArrayList&lt;Observer&gt;();\n    }\n\n    @Override\n    public void registerObserver(Observer o) {\n        observers.add(o);\n    }\n\n    @Override\n    public void removeObserver(Observer o) {\n        if(!observers.isEmpty())\n            observers.remove(o);\n    }\n\n    @Override\n    public void notifyObserver() {\n        for(int i = 0; i &lt; observers.size(); i++) {\n            Observer oserver = observers.get(i);\n            oserver.update(message);\n        }\n    }\n\n    public void setMessage(String s) {\n        this.message = s;\n        System.out.println(\"Message Server is updating message: \" + s);\n        // Notify all observers\n        notifyObserver();\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-observer/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        MessageServer server = new MessageServer();\n\n        Observer user1 = new User(\"Johnny\");\n        Observer user2 = new User(\"George\");\n        Observer user3 = new User(\"Sean\");\n\n        server.registerObserver(user1);\n        server.registerObserver(user2);\n        server.registerObserver(user3);\n        server.setMessage(\"Hello from Rong!\");\n\n        System.out.println(\"----------------------------------------------\");\n        server.removeObserver(user3);\n        server.setMessage(\"We are using Java to send message!\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Message Server is updating message: Hello from Rong!\nJohnny received message from server: Hello from Rong!\nGeorge received message from server: Hello from Rong!\nSean received message from server: Hello from Rong!\n----------------------------------------------\nMessage Server is updating message: We are using Java to send message!\nJohnny received message from server: We are using Java to send message!\nGeorge received message from server: We are using Java to send message!\n</code></pre>"},{"location":"design-pattern/design-pattern-observer/#source-files","title":"Source files","text":"<ul> <li>Source files for Observer Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-observer/#references","title":"References","text":"<ul> <li>Design Patterns - Observer Pattern</li> <li>Observer Design Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-prototype/","title":"Prototype","text":"<p>Prototype pattern refers to creating duplicate object while keeping performance in mind. Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.</p>"},{"location":"design-pattern/design-pattern-prototype/#example-of-implementation","title":"Example of Implementation","text":""},{"location":"design-pattern/design-pattern-prototype/#base-class","title":"Base Class","text":"<pre><code>public abstract class Shape implements Cloneable {\n\n    private String id;\n    protected String type;\n\n    abstract void draw();\n\n    public String getType(){\n        return type;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public Object clone() {\n        Object clone = null;\n\n        try {\n            clone = super.clone();\n\n        } catch (CloneNotSupportedException e) {\n            e.printStackTrace();\n        }\n\n        return clone;\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-prototype/#classes","title":"Classes","text":"<pre><code>public class Circle extends Shape {\n    public Circle(){\n        type = \"Circle\";\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"Shape: Circle\");\n    }\n}\n\npublic class Rectangle extends Shape {\n\n    public Rectangle(){\n        type = \"Rectangle\";\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"Shape: Rectangle\");\n    }\n}\n\npublic class Square extends Shape {\n\n    public Square(){\n        type = \"Square\";\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"Shape: Square\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-prototype/#usage","title":"Usage","text":"<pre><code>public class ShapeCache {\n    private static Map&lt;String, Shape&gt; mapShape = new HashMap&lt;&gt;();\n\n    public static Shape getShape(String shapeId) {\n        Shape cachedShape = mapShape.get(shapeId);\n        return (Shape) cachedShape.clone();\n    }\n\n    public static void loadCache() {\n        Circle circle = new Circle();\n        circle.setId(\"1\");\n        mapShape.put(circle.getId(), circle);\n\n        Square square = new Square();\n        square.setId(\"2\");\n        mapShape.put(square.getId(), square);\n\n        Rectangle rectangle = new Rectangle();\n        rectangle.setId(\"3\");\n        mapShape.put(rectangle.getId(), rectangle);\n    }\n}\n</code></pre> <p>Get new object from cache without directly creating new instance.</p> <pre><code>public class Client {\n    public void run() {\n        ShapeCache.loadCache();\n\n        Shape clonedShape = (Shape) ShapeCache.getShape(\"1\");\n        System.out.println(\"Shape : \" + clonedShape.getType());\n\n        Shape clonedShape2 = (Shape) ShapeCache.getShape(\"2\");\n        System.out.println(\"Shape : \" + clonedShape2.getType());\n\n        Shape clonedShape3 = (Shape) ShapeCache.getShape(\"3\");\n        System.out.println(\"Shape : \" + clonedShape3.getType());\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Shape : Circle\nShape : Square\nShape : Rectangle\n</code></pre>"},{"location":"design-pattern/design-pattern-prototype/#source-files","title":"Source files","text":"<ul> <li>Source files for Prototype Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-prototype/#references","title":"References","text":"<ul> <li>Design Patterns - Prototype Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-proxy/","title":"Proxy","text":"<p>In proxy pattern, a class represents functionality of another class. The Proxy class provides a surrogate or place holder to provide access to an object.</p>"},{"location":"design-pattern/design-pattern-proxy/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-proxy/#internet","title":"Internet","text":"<pre><code>public interface Internet {\n    public void connect(String host) throws Exception;\n}\n\npublic class RealInternet implements Internet\n{\n    @Override\n    public void connect(String host)\n    {\n        System.out.println(\"Connecting to '\"+ host + \"' ...\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-proxy/#proxy_1","title":"Proxy","text":"<pre><code>public class ProxyInternet implements Internet\n{\n    private Internet internet = new RealInternet();\n    private static List&lt;String&gt; bannedSites;\n\n    static\n    {\n        bannedSites = new ArrayList&lt;String&gt;();\n        bannedSites.add(\"abc.com\");\n        bannedSites.add(\"def.com\");\n        bannedSites.add(\"ijk.com\");\n        bannedSites.add(\"lnm.com\");\n    }\n\n    @Override\n    public void connect(String host) throws Exception\n    {\n        if(bannedSites.contains(host.toLowerCase()))\n        {\n            throw new Exception(\"Access Denied: unable to connect to '\" + host + \"'\");\n        }\n\n        internet.connect(host);\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-proxy/#client","title":"Client","text":"<pre><code>public class ClientTest {\n\n    @Test\n    public void testClient() {\n        Internet internet = new ProxyInternet();\n        System.out.println(\"Internet is working now ...\");\n        try\n        {\n            internet.connect(\"jojozhuang.github.io\");\n            internet.connect(\"abc.com\");\n        }\n        catch (Exception e)\n        {\n            System.out.println(e.getMessage());\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Internet is working now ...\nConnecting to 'jojozhuang.github.io' ...\nAccess Denied: unable to connect to 'abc.com'\n</code></pre>"},{"location":"design-pattern/design-pattern-proxy/#source-files","title":"Source files","text":"<ul> <li>Source files for Proxy Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-proxy/#references","title":"References","text":"<ul> <li>Proxy Design Pattern</li> <li>Proxy Pattern Tutorial with Java Examples</li> </ul>"},{"location":"design-pattern/design-pattern-singleton/","title":"Singleton","text":"<p>The Singleton design pattern is designed to restrict instantiation of a class to one object. The singleton pattern is implemented by creating a class with a method that creates a new instance of the object only if one does not already exist. If one does exist, it returns a reference to the object that already exists. If not, a new instance is created and a reference to that new object is returned. To make sure that the object cannot be instantiated any other way the constructor is made either private or protected.</p> <p>The 2 key points that are supported in the Singleton pattern are:</p> <ul> <li>Create a class that can only have one instance and allow the class to manage the one instance</li> <li>Provide a global access point to the instance</li> </ul>"},{"location":"design-pattern/design-pattern-singleton/#implementation","title":"Implementation","text":"<pre><code>// Define class as final, so it can't be inherited\npublic final class Singleton {\n    private static Singleton instance;\n\n    // Declare a private constructor to prevent class instances from being created in any other places\n    private Singleton() {}\n\n    // Use a static method to get instance of this class\n    public static Singleton getInstance() {\n        if (instance == null) {\n            instance = new Singleton();\n        }\n\n        return instance;\n    }\n}\n</code></pre> <ul> <li>Declares class \u201cSingleton\u201d as final, so that subclasses cannot be created that could provide multiple instantiations.</li> <li>Declare a private constructor \u2013 only the Singleton class itself can instantiate a Singleton object using this constructor.</li> <li>Declares a static reference to a Singleton object and invokes the private constructor.</li> </ul>"},{"location":"design-pattern/design-pattern-singleton/#optimization-with-thread-safe","title":"Optimization with thread-safe","text":"<pre><code>// Define class as final, so it can't be inherited\npublic final class Singleton {\n    private volatile static Singleton instance;\n\n    // Declare a private constructor to prevent class instances from being created in any other places\n    private Singleton() {}\n\n    // Use a static method to get object of this class\n    public static synchronized Singleton getInstance() {\n        if (instance == null) {\n            synchronized (Singleton.class) {\n                if (instance == null) { // Double-Check!\n                    instance = new Singleton();\n                }\n            }\n        }\n\n        return instance;\n    }\n}\n</code></pre> <ul> <li>For variables marked with the \u201cvolatile\u201d keyword, threads will be required to access the value of \u201courInstance\u201d from main memory, rather than access cached variable values in local (thread) memory.</li> <li>Double check to see if instance is null or not.</li> </ul>"},{"location":"design-pattern/design-pattern-singleton/#source-files","title":"Source files","text":"<ul> <li>Source files for Singleton Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-state/","title":"Design Pattern - State","text":"<p>Behavioral Pattern: State Pattern.</p>","tags":["State Pattern"]},{"location":"design-pattern/design-pattern-state/#state","title":"State","text":"<p>The State pattern allows an object to change its behavior when its internal state changes.</p>","tags":["State Pattern"]},{"location":"design-pattern/design-pattern-state/#example","title":"Example","text":"","tags":["State Pattern"]},{"location":"design-pattern/design-pattern-state/#state_1","title":"State","text":"<pre><code>public interface State {\n    public void doAction(Context context);\n}\n\npublic class StartState implements State {\n\n    public void doAction(Context context) {\n        System.out.println(\"Player is in start state\");\n        context.setState(this);\n    }\n\n    public String toString(){\n        return \"Start State\";\n    }\n}\n\npublic class StopState implements State {\n\n    public void doAction(Context context) {\n        System.out.println(\"Player is in stop state\");\n        context.setState(this);\n    }\n\n    public String toString(){\n        return \"Stop State\";\n    }\n}\n</code></pre>","tags":["State Pattern"]},{"location":"design-pattern/design-pattern-state/#context","title":"Context","text":"<pre><code>public class Context {\n    private State state;\n\n    public Context(){\n        state = null;\n    }\n\n    public void setState(State state){\n        this.state = state;\n    }\n\n    public State getState(){\n        return state;\n    }\n}\n</code></pre> <p>Output</p> <pre><code>Player is in start state\nStart State\nPlayer is in stop state\nStop State\n</code></pre>","tags":["State Pattern"]},{"location":"design-pattern/design-pattern-state/#source-files","title":"Source files","text":"<ul> <li>Source files for State Pattern on GitHub</li> </ul>","tags":["State Pattern"]},{"location":"design-pattern/design-pattern-state/#references","title":"References","text":"<ul> <li>Design Patterns - State Pattern</li> <li>State Design Pattern</li> </ul>","tags":["State Pattern"]},{"location":"design-pattern/design-pattern-strategy/","title":"Strategy","text":"<p>A Strategy defines a set of algorithms that can be used interchangeably. Use the strategy pattern when:</p> <ul> <li>Many related classes differ only in their behavior.</li> <li>You need different variants of an algorithm.</li> <li>An algorithm uses data that client shouldn't know about.</li> <li>You need to vary a behavior\u2019s algorithm at run-time.</li> </ul>"},{"location":"design-pattern/design-pattern-strategy/#implementation","title":"Implementation","text":""},{"location":"design-pattern/design-pattern-strategy/#strategy-interface","title":"Strategy Interface","text":"<pre><code>public interface Sorting {\n    public int[] sort(int[] nums);\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-strategy/#sorting-algorithms","title":"Sorting Algorithms","text":"<pre><code>public class BubbleSort implements Sorting {\n\n    @Override\n    public int[] sort(int[] nums) {\n        System.out.println(\"Bubble sort on array:\" + Arrays.toString(nums));\n\n        if (nums == null || nums.length &lt; 2) {\n            return nums;\n        }\n\n        for (int i = 0; i &lt; nums.length; i++) {\n            for (int j = nums.length - 1; j &gt; i; j--) {\n                if (nums[j] &lt; nums[j - 1]) {\n                    int temp = nums[j];\n                    nums[j] = nums[j - 1];\n                    nums[j - 1] = temp;\n                }\n            }\n        }\n\n        return nums;\n    }\n}\n\npublic class MergeSort implements Sorting {\n\n    @Override\n    public int[] sort(int[] nums) {\n        System.out.println(\"Merge sort on array:\" + Arrays.toString(nums));\n\n        if (nums == null || nums.length &lt; 2) {\n            return nums;\n        }\n\n        helper(nums, 0, nums.length - 1);\n\n        return nums;\n    }\n\n    private void helper(int[] nums, int start, int end) {\n        if (start &gt;= end) {\n            return;\n        }\n\n        int mid = start + (end - start) / 2;\n        helper(nums, start, mid);\n        helper(nums, mid + 1, end);\n        merge(nums, start, mid, end);\n    }\n\n    private void merge(int[] nums, int start, int mid, int end) {\n        int[] copy = Arrays.copyOf(nums, nums.length);\n\n        int left = start;\n        int right = mid + 1;\n        for (int k = start; k &lt;= end; k++) {\n            if (left &gt; mid) { // no item at left\n                nums[k] = copy[right];\n                right++;\n            }\n            else if(right &gt; end) { // no item at right\n                nums[k] = copy[left];\n                left++;\n            }\n            else if (copy[left] &lt;= copy[right]) {\n                nums[k] = copy[left];\n                left++;\n            }\n            else{\n                nums[k] = copy[right];\n                right++;\n            }\n        }\n    }\n}\n\npublic class QuickSort implements Sorting {\n\n    @Override\n    public int[] sort(int[] nums) {\n        System.out.println(\"Quick sort on array:\" + Arrays.toString(nums));\n\n        if (nums == null || nums.length &lt; 2) {\n            return nums;\n        }\n\n        helper(nums, 0, nums.length - 1);\n\n        return nums;\n    }\n\n    private void helper(int[] nums, int start, int end) {\n        if (start &gt;= end) {\n            return;\n        }\n\n        int pivot = partition(nums, start, end);\n        helper(nums, start, pivot - 1);\n        helper(nums, pivot + 1, end);\n    }\n\n    // one way\n    private int partition(int[] nums, int start, int end) {\n        int pivot = start; // select the first as the pivot\n\n        for (int i = start + 1; i &lt;= end; i++) {\n            if (nums[i] &lt; nums[start]) {\n                pivot++;\n                int temp = nums[pivot];\n                nums[pivot] = nums[i];\n                nums[i] = temp;\n            }\n        }\n\n        int temp = nums[pivot];\n        nums[pivot] = nums[start];\n        nums[start] = temp;\n        return pivot;\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-strategy/#context","title":"Context","text":"<pre><code>public class Context {\n    private Sorting sorting;\n\n    public Context(Sorting sorting){\n        this.sorting = sorting;\n    }\n\n    public int[] executeStrategy(int[] nums){\n        return sorting.sort(nums);\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-strategy/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        int[] nums = new int[]{3,5,1,8,2,9,7,4};\n\n        Context context = new Context(new BubbleSort());\n        System.out.println(Arrays.toString(context.executeStrategy(nums.clone())));\n\n        context = new Context(new MergeSort());\n        System.out.println(Arrays.toString(context.executeStrategy(nums.clone())));\n\n        context = new Context(new QuickSort());\n        System.out.println(Arrays.toString(context.executeStrategy(nums.clone())));\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Bubble sort on array:[3, 5, 1, 8, 2, 9, 7, 4]\n[1, 2, 3, 4, 5, 7, 8, 9]\nMerge sort on array:[3, 5, 1, 8, 2, 9, 7, 4]\n[1, 2, 3, 4, 5, 7, 8, 9]\nQuick sort on array:[3, 5, 1, 8, 2, 9, 7, 4]\n[1, 2, 3, 4, 5, 7, 8, 9]\n</code></pre>"},{"location":"design-pattern/design-pattern-strategy/#source-files","title":"Source files","text":"<ul> <li>Source files for Strategy Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-strategy/#references","title":"References","text":"<ul> <li>Design Patterns - Strategy Pattern</li> <li>Strategy Design Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-template-method/","title":"Template Method","text":"<p>The Template Method design pattern is to define an algorithm as skeleton of operations and leave the details to be implemented by the child classes. The overall structure and sequence of the algorithm is preserved by the parent class.</p>"},{"location":"design-pattern/design-pattern-template-method/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-template-method/#template","title":"Template","text":"<pre><code>public abstract class Order {\n    abstract void doShopping();\n    abstract void doCheckout();\n    abstract void doPayment();\n\n    //template method\n    public final void processOrder(){\n\n        //add products to shopping cart\n        doShopping();\n\n        //place the order\n        doCheckout();\n\n        //pay money\n        doPayment();\n    }\n}\n\npublic class InStoreOrder extends Order {\n    @Override\n    public void doShopping()\n    {\n        System.out.println(\"Customer selects products and puts to shopping cart.\");\n    }\n\n    @Override\n    public void doCheckout()\n    {\n        System.out.println(\"Customer places the order.\");\n    }\n\n    @Override\n    public void doPayment()\n    {\n        System.out.println(\"Customer pays the money with credit card or cash.\");\n    }\n}\n\npublic class OnlineOrder extends Order {\n    @Override\n    public void doShopping()\n    {\n        System.out.println(\"Customer puts products to online shopping cart.\");\n    }\n\n    @Override\n    public void doCheckout()\n    {\n        System.out.println(\"Customer places the online order.\");\n    }\n\n    @Override\n    public void doPayment()\n    {\n        System.out.println(\"Customer pays the money through online payment methods.\");\n    }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-template-method/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        Order order = new InStoreOrder();\n        order.processOrder();\n        System.out.println();\n        order = new OnlineOrder();\n        order.processOrder();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>[In Store] Customer selects products and puts to shopping cart.\n[In Store] Customer places the order.\n[In Store] Customer pays the money with credit card or cash.\n\n[Online] Customer puts products to online shopping cart.\n[Online] Customer places the online order.\n[Online] Customer pays the money through online payment methods.\n</code></pre>"},{"location":"design-pattern/design-pattern-template-method/#source-files","title":"Source files","text":"<ul> <li>Source files for Template Method Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-template-method/#references","title":"References","text":"<ul> <li>Design Patterns - Template Method Pattern</li> <li>Template Method Design Pattern</li> </ul>"},{"location":"design-pattern/design-pattern-visitor/","title":"Visitor","text":"<p>The Visitor pattern represents an operation to be performed on the elements of an object structure without changing the classes on which it operates.</p>"},{"location":"design-pattern/design-pattern-visitor/#example","title":"Example","text":""},{"location":"design-pattern/design-pattern-visitor/#computer-part","title":"Computer Part","text":"<pre><code>public interface ComputerPart {\n   public void accept(ComputerPartVisitor computerPartVisitor);\n}\n\npublic class Keyboard implements ComputerPart {\n\n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n\npublic class Monitor implements ComputerPart {\n\n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n\npublic class Mouse implements ComputerPart {\n\n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      computerPartVisitor.visit(this);\n   }\n}\n\npublic class Computer implements ComputerPart {\n\n   ComputerPart[] parts;\n\n   public Computer(){\n      parts = new ComputerPart[] {new Mouse(), new Keyboard(), new Monitor()};  \n   }\n\n   @Override\n   public void accept(ComputerPartVisitor computerPartVisitor) {\n      for (int i = 0; i &lt; parts.length; i++) {\n         parts[i].accept(computerPartVisitor);\n      }\n      computerPartVisitor.visit(this);\n   }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-visitor/#visitor-class","title":"Visitor class","text":"<pre><code>public interface ComputerPartVisitor {\n    public void visit(Computer computer);\n    public void visit(Mouse mouse);\n    public void visit(Keyboard keyboard);\n    public void visit(Monitor monitor);\n}\n\npublic class ComputerPartDisplayVisitor implements ComputerPartVisitor {\n\n   @Override\n   public void visit(Computer computer) {\n      System.out.println(\"Displaying Computer.\");\n   }\n\n   @Override\n   public void visit(Mouse mouse) {\n      System.out.println(\"Displaying Mouse.\");\n   }\n\n   @Override\n   public void visit(Keyboard keyboard) {\n      System.out.println(\"Displaying Keyboard.\");\n   }\n\n   @Override\n   public void visit(Monitor monitor) {\n      System.out.println(\"Displaying Monitor.\");\n   }\n}\n</code></pre>"},{"location":"design-pattern/design-pattern-visitor/#client","title":"Client","text":"<pre><code>public class Client {\n    public void run() {\n        ComputerPart computer = new Computer();\n        computer.accept(new ComputerPartDisplayVisitor());\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Displaying Mouse.\nDisplaying Keyboard.\nDisplaying Monitor.\nDisplaying Computer.\n</code></pre>"},{"location":"design-pattern/design-pattern-visitor/#source-files","title":"Source files","text":"<ul> <li>Source files for Visitor Pattern on GitHub</li> </ul>"},{"location":"design-pattern/design-pattern-visitor/#references","title":"References","text":"<ul> <li>Design Patterns - Visitor Pattern</li> <li>Visitor Design Pattern</li> </ul>"},{"location":"index/algorithm/","title":"Algorithm","text":""},{"location":"index/data-structure/","title":"Data structure","text":"Data Structure Search Insertion Deletion Array O(N) O(1) O(N) Linked List O(N) O(1) O(N) Binary Tree - - - Binary Search Tree (average) O(logN) O(logN) O(logN) Binary Search Tree (worst case) O(N) O(N) O(N) Red Black Tree O(logN) O(logN) O(logN) HashMap O(1) O(1) O(1) <ul> <li>N is the number of elements.</li> <li>The time complexity of Balanced Search Tree is guaranteed, O(logN).</li> </ul>"},{"location":"index/design-pattern/","title":"Design pattern in Java","text":""},{"location":"index/design-pattern/#creational-patterns","title":"Creational Patterns","text":"<ul> <li>Singleton Pattern</li> <li>Factory Pattern</li> <li>Builder Pattern</li> <li>Prototype Pattern</li> </ul>"},{"location":"index/design-pattern/#structural-patterns","title":"Structural Patterns","text":"<ul> <li>Adapter Pattern</li> <li>Bridge Pattern</li> <li>Composite Pattern</li> <li>Decorator Pattern</li> <li>Facade Pattern</li> <li>Flyweight Pattern</li> <li>Proxy Pattern</li> </ul>"},{"location":"index/design-pattern/#behavioral-patterns","title":"Behavioral Patterns","text":"<ul> <li>Command Pattern</li> <li>Interpreter Pattern</li> <li>Iterator Pattern</li> <li>Mediator Pattern</li> <li>Memento Pattern</li> <li>Null Object Pattern</li> <li>Observer Pattern</li> <li>State Pattern</li> <li>Strategy Pattern</li> <li>Template Method Pattern</li> <li>Visitor Pattern</li> </ul>"},{"location":"index/design-pattern/#references","title":"References","text":"<ul> <li>Design Patterns</li> <li>Design Patterns in Java Tutorial</li> <li>Abstract Factory Pattern Tutorial with Java Examples</li> </ul>"},{"location":"index/dp/","title":"Dynamic Programming","text":""},{"location":"index/graph/","title":"Graph","text":""},{"location":"index/graph/#undirected-graph","title":"Undirected Graph","text":""},{"location":"index/graph/#directed-graph","title":"Directed Graph","text":""},{"location":"index/list/","title":"List","text":""},{"location":"index/list/#array-vs-list","title":"Array vs List","text":""},{"location":"index/map/","title":"Set","text":""},{"location":"index/map/#map","title":"Map","text":""},{"location":"index/sorting/","title":"Sorting","text":""},{"location":"index/tree/","title":"Tree","text":""},{"location":"java/java-core-basic/","title":"Java Core Basic","text":""},{"location":"java/java-core-formatting/","title":"Java Core Formatting","text":""},{"location":"java-concurrency/java-concurrency-blockingqueue/","title":"BlockingQueue","text":"<p>BlockingQueue interface and its implementations.</p>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#blockingqueue-interface","title":"BlockingQueue Interface","text":"<p>BlockingQueue Interface(java.util.concurrent.BlockingQueue) is a Queue that additionally supports operations that wait for the queue to become non-empty when retrieving an element, and wait for space to become available in the queue when storing an element.</p>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#operations-on-blockingqueue","title":"Operations on BlockingQueue","text":"<p>BlockingQueue methods come in four forms, with different ways of handling operations that cannot be satisfied immediately, but may be satisfied at some point in the future: one throws an exception, the second returns a special value (either null or false, depending on the operation), the third blocks the current thread indefinitely until the operation can succeed, and the fourth blocks for only a given maximum time limit before giving up. These methods are summarized in the following table:</p> Operation Throws exception Special value Blocks Times out Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() not applicable not applicable <ul> <li>BlockingQueue does not accept null elements. Implementations throw NullPointerException on attempts to add, put or offer a null.</li> </ul>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#blockingqueue-types","title":"BlockingQueue Types","text":"<ul> <li><code>Unbounded Queue</code>: The Capacity of blocking queue will be set to Integer.MAX_VALUE. Unbounded queue will never block because it could grow to a very large size. When you add elements, it\u2019s size grows.</li> </ul> <pre><code>BlockingQueue blockingQueue = new LinkedBlockingDeque();\n</code></pre> <ul> <li><code>Bounded Queue</code>: The capacity of bounded queue is fixed. You can create a bounded queue by passing the capacity of queue in constructor.</li> </ul> <pre><code>// Creates a Blocking Queue with capacity 5\nBlockingQueue blockingQueue = new LinkedBlockingDeque(5);\n</code></pre>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#classes-implements-blockingqueue-interface","title":"Classes implements BlockingQueue Interface","text":"<ul> <li>ArrayBlockingQueue</li> <li>LinkedBlockingQueue</li> <li>PriorityBlockingQueue</li> <li>SynchronousQueue</li> <li>LinkedBlockingDeque</li> </ul>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#arrayblockingqueue-vs-linkedblockingqueue","title":"ArrayBlockingQueue vs. LinkedBlockingQueue","text":"<ul> <li>ArrayBlockingQueue is always bounded.</li> <li>LinkedBlockingQueue can be unbounded.</li> <li>ArrayBlockingQueue can be created with a configurable (on/off) scheduling fairness policy. This is great if you need fairness or want to avoid producer/consumer starvation, but it will cost you in throughput.</li> <li>ArrayBlockingQueue pre-allocates its backing array, so it doesn't allocate nodes during its usage, but it immediately takes what can be a considerable chunk of memory, which can be a problem if your memory is fragmented.</li> <li>ArrayBlockingQueue should have less variability in performance, because it has less moving parts overall, it uses a simpler and less-sophisticated single-lock algorithm, it does not create nodes during usage, and its cache behavior should be fairly consistent.</li> <li>LinkedBlockingQueue should have <code>better throughput</code>, because it uses separate locks for the head and the tail.</li> <li>LinkedBlockingQueue does not pre-allocate nodes, which means that its memory footprint will roughly match its size, but it also means that it will incur some work for allocation and freeing of nodes.</li> <li>LinkedBlockingQueue will probably have <code>worse cache behavior</code>, which may affect its own performance, but also the performance of other components due to false sharing.</li> </ul>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#blockingqueue-example","title":"BlockingQueue Example","text":""},{"location":"java-concurrency/java-concurrency-blockingqueue/#message","title":"Message","text":"<p>The object will be created by producer and consumed by consumer.</p> <pre><code>public class Message {\n    private String msg;\n\n    public Message(String msg){\n        this.msg = msg;\n    }\n\n    public String getMessage() {\n        return msg;\n    }\n}\n</code></pre>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#producer","title":"Producer","text":"<p>Producer creates messages and put them into the queue.</p> <pre><code>import java.util.concurrent.BlockingQueue;\n\npublic class Producer implements Runnable {\n\n    private BlockingQueue&lt;Message&gt; bq;\n\n    public Producer(BlockingQueue&lt;Message&gt; bq){\n        this.bq = bq;\n    }\n\n    @Override\n    public void run() {\n        //produce messages\n        for (int i = 0; i &lt; 20; i++){\n            Message msg = new Message(\"Message-\" + i);\n            try {\n                Thread.sleep(i);\n                bq.put(msg);\n                System.out.println(\"Produced \" + msg.getMessage());\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n        //adding exit message\n        Message msg = new Message(\"exit\");\n        try {\n            bq.put(msg);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#consumer","title":"Consumer","text":"<p>Consumer will process on the messages from the queue and terminates when exit message is received.</p> <pre><code>import java.util.concurrent.BlockingQueue;\n\npublic class Consumer implements Runnable{\n\n    private BlockingQueue&lt;Message&gt; bq;\n\n    public Consumer(BlockingQueue&lt;Message&gt; bq){\n        this.bq = bq;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Message msg;\n            //consuming messages until exit message is received\n            while ((!(msg = bq.take()).getMessage().equals(\"exit\"))) {\n                Thread.sleep(100);\n                System.out.println(\"Consumed \" + msg.getMessage());\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#test-class","title":"Test Class","text":"<p>This test class will create the BlockingQueue with fixed size and share with both producers and consumers. It will start producer and consumer threads and exit.</p> <pre><code>public class BlockingQueueExample {\n    public static void main(String[] args) {\n\n        //Creating BlockingQueue of size 10\n        BlockingQueue&lt;Message&gt; queue = new ArrayBlockingQueue&lt;&gt;(5);\n\n        Producer producer = new Producer(queue);\n        Consumer consumer = new Consumer(queue);\n\n        //starting producer to produce messages in queue\n        new Thread(producer).start();\n\n        //starting consumer to consume messages from queue\n        new Thread(consumer).start();\n\n        System.out.println(\"Producer and Consumer has been started\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Producer and Consumer has been started\nProduced Message-0\nProduced Message-1\nProduced Message-2\nProduced Message-3\nProduced Message-4\nProduced Message-5\nConsumed Message-0\nProduced Message-6\nConsumed Message-1\nProduced Message-7\nConsumed Message-2\nProduced Message-8\nConsumed Message-3\nProduced Message-9\nConsumed Message-4\nProduced Message-10\nConsumed Message-5\nProduced Message-11\nConsumed Message-6\nProduced Message-12\nConsumed Message-7\nProduced Message-13\nConsumed Message-8\nProduced Message-14\nConsumed Message-9\nProduced Message-15\nConsumed Message-10\nProduced Message-16\nConsumed Message-11\nProduced Message-17\nConsumed Message-12\nProduced Message-18\nConsumed Message-13\nProduced Message-19\nConsumed Message-14\nConsumed Message-15\nConsumed Message-16\nConsumed Message-17\nConsumed Message-18\nConsumed Message-19\n\nProcess finished with exit code 0\n</code></pre>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java BlockingQueue on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-blockingqueue/#references","title":"References","text":"<ul> <li>Java Doc - Interface BlockingQueue</li> <li>Java BlockingQueue Example</li> <li>BlockingQueue Interface in Java</li> <li>Java BlockingQueue examples</li> <li>When to prefer LinkedBlockingQueue over ArrayBlockingQueue?</li> </ul>"},{"location":"java-concurrency/java-concurrency-callables-and-futures/","title":"Callables and Futures","text":""},{"location":"java-concurrency/java-concurrency-callables-and-futures/#runnable-vs-callable","title":"Runnable vs Callable","text":"<p>A <code>Runnable</code> encapsulates a task that runs asynchronously; you can think of it as an asynchronous method with no parameters and no return value. A <code>Callable</code> is similar to a Runnable, but it returns a value. The Callable interface is a parameterized type, with a single method <code>call</code>.</p> <pre><code>public interface Callable&lt;V&gt;\n{\n    V call() throws Exception; // V is the type of the returned value.\n}\n</code></pre> <p>A <code>Future</code> holds the result of an asynchronous computation. The Future interface has the following methods:</p> <pre><code>public interface Future&lt;V&gt;\n{\n    V get() throws . . .;\n    V get(long timeout, TimeUnit unit) throws . . .;\n    void cancel(boolean mayInterrupt);\n    boolean isCancelled();\n    boolean isDone();\n}\n</code></pre> <p>The <code>FutureTask</code> wrapper is a convenient mechanism for turning a Callable into both a Future and a Runnable\u2014it implements both interfaces. For example:</p> <pre><code>Callable&lt;Integer&gt; myComputation = . . .;\nFutureTask&lt;Integer&gt; task = new FutureTask&lt;Integer&gt;(myComputation);\nThread t = new Thread(task); // it's a Runnable\nt.start();\n...\nInteger result = task.get(); // it's a Future\n</code></pre>"},{"location":"java-concurrency/java-concurrency-callables-and-futures/#example","title":"Example","text":"<p>The following two examples show how get to get result from from thread.</p>"},{"location":"java-concurrency/java-concurrency-callables-and-futures/#runnable-only","title":"Runnable Only","text":"<p>Create a work thread with <code>Runnable</code> get generate random number.</p> <pre><code>public class RunnableWorker implements Runnable {\n    // Shared object to store result\n    private Object result = null;\n\n    public void run() {\n        Random random = new Random();\n        Integer randomNumber = random.nextInt(5);\n\n        // As run cannot throw any Exception\n        try {\n            Thread.sleep(randomNumber * 1000);\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // Store the return value in result when done\n        result = randomNumber;\n\n        // Wake up threads blocked on the get() method\n        synchronized(this) {\n            notifyAll();\n        }\n    }\n\n    public synchronized Object get() throws InterruptedException {\n        while (result == null) {\n            wait();\n        }\n        return result;\n    }\n}\n</code></pre> <ul> <li>Use <code>notifyAll()</code> method to notify other threads that the result is ready.</li> <li>Use <code>wait()</code> method to let the caller keep waiting until the result is ready.</li> </ul> <p>Create a main thread with 5 tasks. Call the <code>get()</code> method to receive the result for each task.</p> <pre><code>public class RunnableExample {\n    public static void main(String[] args) throws Exception {\n        RunnableWorker[] tasks = new RunnableWorker[5];\n\n        System.out.println(\"Creating tasks...\");\n        for (int i = 0; i &lt; 5; i++) {\n            tasks[i] = new RunnableWorker();\n            Thread t = new Thread(tasks[i]);\n            t.start();\n        }\n\n        System.out.println(\"Waiting results...\");\n        for (int i = 0; i &lt; 5; i++) {\n            System.out.println(tasks[i].get());\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Creating tasks...\nWaiting results...\n3\n1\n0\n3\n2\n</code></pre>"},{"location":"java-concurrency/java-concurrency-callables-and-futures/#callable-furturetask","title":"Callable + FurtureTask","text":"<p>Create a work thread with <code>Callable</code> get generate random number.</p> <pre><code>public class CallableWorker implements Callable {\n    public Object call() throws Exception {\n        Random random = new Random();\n        Integer randomNumber = random.nextInt(5);\n\n        Thread.sleep(randomNumber * 1000);\n\n        return randomNumber;\n    }\n}\n</code></pre> <p>Create a main thread to use <code>Future</code> to get result from Callable.</p> <pre><code>import java.util.concurrent.Callable;\nimport java.util.concurrent.FutureTask;\n\npublic class CallableExample {\n    public static void main(String[] args) throws Exception {\n        // FutureTask is a concrete class that implements both Runnable and Future\n        FutureTask[] tasks = new FutureTask[5];\n\n        System.out.println(\"Creating tasks...\");\n        for (int i = 0; i &lt; 5; i++) {\n            Callable callable = new CallableWorker();\n\n            // Create the FutureTask with Callable\n            tasks[i] = new FutureTask(callable);\n\n            // As it implements Runnable, create Thread with FutureTask\n            Thread t = new Thread(tasks[i]);\n            t.start();\n        }\n\n        System.out.println(\"Waiting results...\");\n        for (int i = 0; i &lt; 5; i++) {\n            // As it implements Future, we can call get()\n            System.out.println(tasks[i].get());\n\n            // This method blocks till the result is obtained\n            // The get method can throw checked exceptions\n            // like when it is interrupted. This is the reason\n            // for adding the throws clause to main\n        }\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>Creating tasks...\nWaiting results...\n2\n4\n0\n0\n3\n</code></pre>"},{"location":"java-concurrency/java-concurrency-callables-and-futures/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Callable on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-callables-and-futures/#references","title":"References","text":"<ul> <li>Callable and Future in Java</li> </ul>"},{"location":"java-concurrency/java-concurrency-concurrentskiplistmap/","title":"ConcurrentSkipListMap","text":"<p><code>ConcurrentSkipListMap</code> allows us to create thread-safe logic in a lock-free way. It\u2019s ideal for problems when we want to make an immutable snapshot of the data while other threads are still inserting data into the map.</p>"},{"location":"java-concurrency/java-concurrency-concurrentskiplistmap/#last-one-minute-problem","title":"Last One Minute Problem","text":"<p>We will be solving a problem of sorting a stream of events and getting a snapshot of the events that arrived in the last 60 seconds using that construct.</p> <p>First, create Event class, which is used to store the event time and its content.</p> <pre><code>import java.time.ZonedDateTime;\n\npublic class Event {\n    private final ZonedDateTime eventTime;\n    private final String content;\n\n    public Event(ZonedDateTime eventTime, String content) {\n        this.eventTime = eventTime;\n        this.content = content;\n    }\n\n    public ZonedDateTime getEventTime() {\n        return eventTime;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}\n</code></pre> <p>Secondly, create a <code>sorted window structure</code> with ConcurrentSkipListMap to store the events sorted by <code>time</code>.</p> <pre><code>import java.time.ZonedDateTime;\nimport java.util.Comparator;\nimport java.util.concurrent.ConcurrentNavigableMap;\nimport java.util.concurrent.ConcurrentSkipListMap;\n\npublic class SortedEventWindow {\n    private final ConcurrentSkipListMap&lt;ZonedDateTime, String&gt; events;\n\n    public SortedEventWindow() {\n        events = new ConcurrentSkipListMap&lt;&gt;(\n                Comparator.comparingLong(value -&gt; value.toInstant().toEpochMilli()));\n    }\n\n    public void acceptEvent(Event event) {\n        events.put(event.getEventTime(), event.getContent());\n    }\n\n    public ConcurrentNavigableMap&lt;ZonedDateTime, String&gt; getAll() {\n        return events;\n    }\n\n    public ConcurrentNavigableMap&lt;ZonedDateTime, String&gt; getLastOneMinute() {\n        return events.tailMap(ZonedDateTime\n                .now()\n                .minusMinutes(1));\n    }\n\n    public ConcurrentNavigableMap&lt;ZonedDateTime, String&gt; getFirstOneMinute() {\n        return events.headMap(ZonedDateTime\n                .now()\n                .minusMinutes(1));\n    }\n}\n</code></pre> <ul> <li>getLastOneMinute - call ConcurrentSkipListMap.tailMap() to get the latest one minute events.</li> <li>getFirstOneMinute - call ConcurrentSkipListMap.headMap() to get the first one minute events.</li> </ul> <p>Thirdly, create Runnable task, which generate 50 events. To avoid generating same key event in the circumstance that two threads run simultaneously, we use <code>odd</code> flag to control the generated time objects.</p> <pre><code>import java.time.ZonedDateTime;\nimport java.util.stream.IntStream;\n\npublic class Task implements Runnable {\n    private String name;\n    private boolean odd;\n    private SortedEventWindow sew;\n\n    public Task(String name, boolean odd, SortedEventWindow sew) {\n        this.name = name;\n        this.odd = odd;\n        this.sew = sew;\n    }\n\n    public void run() {\n        if (this.odd) {\n            IntStream\n                .rangeClosed(1, 100)\n                .filter(i-&gt;i % 2 == 1)\n                .forEach(index -&gt; sew.acceptEvent(new Event(ZonedDateTime\n                        .now()\n                        .minusSeconds(index), name)));\n        } else {\n            IntStream\n                .rangeClosed(1, 100)\n                .filter(i-&gt;i % 2 == 0)\n                .forEach(index -&gt; sew.acceptEvent(new Event(ZonedDateTime\n                        .now()\n                        .minusSeconds(index), name)));\n        }\n    }\n}\n</code></pre> <p>Finally, create a test class to run test the sorted event window and ConcurrentNavigableMap.</p> <pre><code>import java.time.ZonedDateTime;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentNavigableMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeUnit;\n\npublic class ConcurrentSkipListMapExample {\n    public static void main(String[] args) throws Exception {\n        // Create thread pool\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        SortedEventWindow sew = new SortedEventWindow();\n\n        executorService.execute(new Task(\"task1\", true, sew));\n        executorService.execute(new Task(\"task2\", false, sew));\n\n        Thread.sleep(500);\n\n        // get all events\n        System.out.println(\"All events:\");\n        Set&lt;Map.Entry&lt;ZonedDateTime, String&gt;&gt; eventSet = sew.getAll().entrySet();\n        eventSet.forEach((m)-&gt;System.out.println(\"key=\" + m.getKey()\n                + \" value=\" + m.getValue()));\n\n        // get latest one minute events\n        ConcurrentNavigableMap&lt;ZonedDateTime, String&gt; events = sew.getLastOneMinute();\n\n        System.out.println(\"Latest one minute events:\");\n        eventSet = events.entrySet();\n        eventSet.forEach((m)-&gt;System.out.println(\"key=\" + m.getKey()\n                + \" value=\" + m.getValue()));\n\n        long eventsLatestOneMinute = events\n                .entrySet()\n                .stream()\n                .filter(e -&gt; e\n                        .getKey()\n                        .isAfter(ZonedDateTime\n                                .now()\n                                .minusMinutes(1)))\n                .count();\n        System.out.println(\"Count=\" + eventsLatestOneMinute);\n\n        // get first one minute events\n        events = sew.getFirstOneMinute();\n\n        System.out.println(\"First one minute events:\");\n        eventSet = events.entrySet();\n        eventSet.forEach((m)-&gt;System.out.println(\"key=\" + m.getKey()\n                + \" value=\" + m.getValue()));\n\n        long eventsFirstOneMinute = events\n                .entrySet()\n                .stream()\n                .filter(e -&gt; e\n                        .getKey()\n                        .isBefore(ZonedDateTime\n                                .now()\n                                .minusMinutes(1)))\n                .count();\n        System.out.println(\"Count=\" + eventsFirstOneMinute);\n\n        executorService.awaitTermination(1, TimeUnit.SECONDS);\n        executorService.shutdown();\n    }\n}\n</code></pre> <ul> <li>Create two threads with thread pool to generate 100 events.</li> <li>Print all events, latest one minute events and first one minute events.</li> </ul> <p>Output.</p> <pre><code>All events:\nkey=2019-08-11T16:49:11.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:12.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:13.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:14.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:15.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:16.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:17.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:18.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:19.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:20.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:21.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:22.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:23.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:24.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:25.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:26.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:27.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:28.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:29.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:30.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:31.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:32.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:33.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:34.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:35.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:36.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:37.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:38.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:39.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:40.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:41.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:42.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:43.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:44.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:45.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:46.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:47.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:48.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:49.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:50.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:51.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:52.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:53.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:54.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:55.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:56.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:57.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:58.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:59.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:00.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:01.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:02.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:03.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:04.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:05.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:06.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:07.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:08.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:09.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:10.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:11.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:12.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:13.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:14.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:15.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:16.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:17.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:18.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:19.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:20.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:21.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:22.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:23.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:24.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:25.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:26.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:27.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:28.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:29.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:30.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:31.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:32.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:33.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:34.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:35.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:36.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:37.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:38.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:39.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:40.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:41.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:42.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:43.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:44.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:45.849-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:46.849-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:47.849-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:48.849-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:49.844-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:50.844-07:00[America/Los_Angeles] value=task1\nLatest one minute events:\nkey=2019-08-11T16:49:52.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:53.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:54.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:55.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:56.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:57.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:58.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:59.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:00.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:01.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:02.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:03.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:04.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:05.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:06.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:07.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:08.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:09.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:10.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:11.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:12.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:13.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:14.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:15.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:16.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:17.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:18.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:19.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:20.851-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:21.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:22.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:23.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:24.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:25.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:26.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:27.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:28.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:29.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:30.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:31.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:32.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:33.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:34.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:35.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:36.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:37.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:38.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:39.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:40.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:41.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:42.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:43.850-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:44.850-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:45.849-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:46.849-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:47.849-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:48.849-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:50:49.844-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:50:50.844-07:00[America/Los_Angeles] value=task1\nCount=59\nFirst one minute events:\nkey=2019-08-11T16:49:11.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:12.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:13.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:14.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:15.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:16.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:17.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:18.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:19.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:20.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:21.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:22.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:23.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:24.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:25.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:26.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:27.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:28.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:29.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:30.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:31.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:32.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:33.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:34.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:35.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:36.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:37.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:38.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:39.852-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:40.853-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:41.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:42.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:43.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:44.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:45.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:46.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:47.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:48.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:49.851-07:00[America/Los_Angeles] value=task2\nkey=2019-08-11T16:49:50.852-07:00[America/Los_Angeles] value=task1\nkey=2019-08-11T16:49:51.851-07:00[America/Los_Angeles] value=task2\nCount=41\n</code></pre>"},{"location":"java-concurrency/java-concurrency-concurrentskiplistmap/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java ConcurrentSkipListMap on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-concurrentskiplistmap/#references","title":"References","text":"<ul> <li>Guide to the ConcurrentSkipListMap</li> </ul>"},{"location":"java-concurrency/java-concurrency-dead-lock/","title":"Dead lock","text":"<p>Understand what is dead lock, how to avoid, how to detect.</p>"},{"location":"java-concurrency/java-concurrency-dead-lock/#concurrency-issue","title":"Concurrency Issue","text":""},{"location":"java-concurrency/java-concurrency-dead-lock/#synchronized","title":"synchronized","text":"<p><code>synchronized</code> keyword is used to make the class or method thread-safe which means only one thread can have lock of synchronized method and use it, other threads have to wait till the lock releases. It is important if our program is running in multi-threaded environment where two or more threads execute simultaneously. But sometimes it also causes a problem which is called Deadlock.</p>"},{"location":"java-concurrency/java-concurrency-dead-lock/#deadlock","title":"Deadlock","text":"<p><code>Deadlock</code> describes a situation where two or more threads are blocked forever, waiting for each other. Deadlock occurs when multiple threads need the same locks but obtain them in different order. A Java multithreaded program may suffer from the deadlock condition because the synchronized keyword causes the executing thread to block while waiting for the lock, or monitor, associated with the specified object. </p>"},{"location":"java-concurrency/java-concurrency-dead-lock/#deadlock-example","title":"Deadlock Example","text":"<p>Below is a simple example of Deadlock condition. Each thread acquires two locks in different order.</p> <pre><code>public class DeadlockExample {\n    public static Object Lock1 = new Object();\n    public static Object Lock2 = new Object();\n\n    public static void main(String args[]) {\n        WorkerThread1 t1 = new WorkerThread1();\n        WorkerThread2 t2 = new WorkerThread2();\n        t1.start();\n        t2.start();\n    }\n\n    private static class WorkerThread1 extends Thread {\n        public void run() {\n            synchronized (Lock1) {\n                System.out.println(\"Thread 1: Holding lock 1...\");\n\n                try {\n                    Thread.sleep(10);\n                }\n                catch (InterruptedException e) {\n                    System.out.println(e.getStackTrace());\n                }\n                System.out.println(\"Thread 1: Waiting for lock 2...\");\n\n                synchronized (Lock2) {\n                    System.out.println(\"Thread 1: Holding lock 1 &amp; 2...\");\n                }\n            }\n        }\n    }\n\n    private static class WorkerThread2 extends Thread {\n        public void run() {\n            synchronized (Lock2) {\n                System.out.println(\"Thread 2: Holding lock 2...\");\n\n                try {\n                    Thread.sleep(10);\n                }\n                catch (InterruptedException e) {\n                    System.out.println(e.getStackTrace());\n                }\n                System.out.println(\"Thread 2: Waiting for lock 1...\");\n\n                synchronized (Lock1) {\n                    System.out.println(\"Thread 2: Holding lock 1 &amp; 2...\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Thread 1: Holding lock 1...\nThread 2: Holding lock 2...\nThread 1: Waiting for lock 2...\nThread 2: Waiting for lock 1...\n</code></pre> <ul> <li>Notice that the main program is hanged on, never stops or quits.</li> </ul>"},{"location":"java-concurrency/java-concurrency-dead-lock/#deadlock-solution","title":"Deadlock Solution","text":"<p>To solve the above issue, we can make the second thread to acquire lock1 first, then lock2.</p> <pre><code>public class AvoidDeadlockExample {\n    public static Object Lock1 = new Object();\n    public static Object Lock2 = new Object();\n\n    public static void main(String args[]) {\n        WorkerThread1 t1 = new WorkerThread1();\n        WorkerThread2 t2 = new WorkerThread2();\n        t1.start();\n        t2.start();\n    }\n\n    private static class WorkerThread1 extends Thread {\n        public void run() {\n            synchronized (Lock1) {\n                System.out.println(\"Thread 1: Holding lock 1...\");\n\n                try {\n                    Thread.sleep(10);\n                }\n                catch (InterruptedException e) {\n                    System.out.println(e.getStackTrace());\n                }\n                System.out.println(\"Thread 1: Waiting for lock 2...\");\n\n                synchronized (Lock2) {\n                    System.out.println(\"Thread 1: Holding lock 1 &amp; 2...\");\n                }\n            }\n        }\n    }\n\n    private static class WorkerThread2 extends Thread {\n        public void run() {\n            synchronized (Lock1) {\n                System.out.println(\"Thread 2: Holding lock 1...\");\n\n                try {\n                    Thread.sleep(10);\n                }\n                catch (InterruptedException e) {\n                    System.out.println(e.getStackTrace());\n                }\n                System.out.println(\"Thread 2: Waiting for lock 2...\");\n\n                synchronized (Lock2) {\n                    System.out.println(\"Thread 2: Holding lock 1 &amp; 2...\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Thread 1: Holding lock 1...\nThread 1: Waiting for lock 2...\nThread 1: Holding lock 1 &amp; 2...\nThread 2: Holding lock 1...\nThread 2: Waiting for lock 2...\nThread 2: Holding lock 1 &amp; 2...\n</code></pre> <ul> <li>Notice that the first thread gets both two locks, then the second thread gets them, no deadlock.</li> </ul> <p>In the reality, multithreading programming is not such simple. And deadlock is not such easy to be avoided.</p>"},{"location":"java-concurrency/java-concurrency-dead-lock/#deadlock-detection","title":"Deadlock Detection","text":"<p>Deadlock can be very hard to detect during development, and you may have to restart the application in order to recover. It also happens in production environment, which causes severe consequences. Such issue is very hard to spot during testing, and is very difficult to reproduce it locally.</p>"},{"location":"java-concurrency/java-concurrency-dead-lock/#detect-deadlock-programmatically","title":"Detect Deadlock Programmatically","text":"<p>Java 5 introduced ThreadMXBean - an interface that provides various monitoring methods for threads. There are many useful methods for monitoring the application performance. The method of our interest is <code>findMonitorDeadlockedThreads</code>, or, if you are using Java 6,<code>findDeadlockedThreads</code>. The difference is that findDeadlockedThreads can also detect deadlocks caused by owner locks (java.util.concurrent), while findMonitorDeadlockedThreads can only detect monitor locks (i.e. synchronized blocks).</p> <p>Our idea is to encapsulate periodical checking for deadlocks into a reusable component so we can just fire and forget about it.</p>"},{"location":"java-concurrency/java-concurrency-dead-lock/#example","title":"Example","text":"<p>One way to implement scheduling is through executors framework - a set of well abstracted and very easy to use multithreading classes. The best choice is <code>ScheduledExecutorService</code>.</p> <pre><code>ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\nthis.scheduler.scheduleAtFixedRate(deadlockCheck, period, period, unit);\n</code></pre> <p>Simple as that, we have a runnable called periodically after a certain amount of time determined by period and time unit. Next, we want to make our utility is extensive and allow clients to supply the behavior that gets triggered after a deadlock is detected. We need a method that receives a list of objects describing threads that are in a deadlock. Create such interface as follows.</p> <pre><code>public interface DetectionHandler {\n    void handleDeadlock(final ThreadInfo[] deadlockedThreads);\n}\n</code></pre> <p>Our implementation.</p> <pre><code>public class DetectionConsoleHandler implements DetectionHandler {\n\n    @Override\n    public void handleDeadlock(final ThreadInfo[] deadlockedThreads) {\n        if (deadlockedThreads != null) {\n            System.err.println(LocalDateTime.now() + \": Deadlock detected!\");\n\n            Map&lt;Thread, StackTraceElement[]&gt; stackTraceMap = Thread.getAllStackTraces();\n            for (ThreadInfo threadInfo : deadlockedThreads) {\n                if (threadInfo != null) {\n                    for (Thread thread : stackTraceMap.keySet()) {\n                        if (thread.getId() == threadInfo.getThreadId()) {\n                            System.err.println(threadInfo.toString().trim());\n\n                            for (StackTraceElement ste : thread.getStackTrace()) {\n                                System.err.println(\"\\t\" + ste.toString().trim());\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n}\n</code></pre> <ul> <li>If deadlock is detected, it will print the thread information as well as the relevant stack trace.</li> <li>In the reality, we can make it to send out email to notify dev or ops.</li> </ul> <p>The Detector. Use ScheduledExecutorService to periodically check if deadlock occurs.</p> <pre><code>public class DeadlockDetector {\n    private final DetectionHandler deadlockHandler;\n    private final long period;\n    private final TimeUnit unit;\n    private final ThreadMXBean mbean = ManagementFactory.getThreadMXBean();\n    private final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(1);\n\n    final Runnable deadlockCheck = new Runnable() {\n        @Override\n        public void run() {\n            long[] deadlockedThreadIds = DeadlockDetector.this.mbean.findDeadlockedThreads();\n\n            if (deadlockedThreadIds != null) {\n                ThreadInfo[] threadInfos =\n                        DeadlockDetector.this.mbean.getThreadInfo(deadlockedThreadIds);\n\n                DeadlockDetector.this.deadlockHandler.handleDeadlock(threadInfos);\n            }\n        }\n    };\n\n    public DeadlockDetector(final DetectionHandler deadlockHandler,\n                            final long period,\n                            final TimeUnit unit) {\n        this.deadlockHandler = deadlockHandler;\n        this.period = period;\n        this.unit = unit;\n    }\n\n    public void start() {\n        this.scheduler.scheduleAtFixedRate(\n                this.deadlockCheck, this.period, this.period, this.unit);\n    }\n}\n</code></pre> <p>Create deadlock example to test the detector. The DeadlockDetector is configured to detect deadlock in every 5 seconds.</p> <pre><code>public class DetectionExample {\n\n    public static Object Lock1 = new Object();\n    public static Object Lock2 = new Object();\n\n    public static void main(String args[]) {\n        DeadlockDetector deadlockDetector = new DeadlockDetector(new DetectionHandlerImp(),\n                       5, TimeUnit.SECONDS);\n        deadlockDetector.start();\n\n        WorkerThread1 t1 = new WorkerThread1();\n        WorkerThread2 t2 = new WorkerThread2();\n        t1.start();\n        t2.start();\n    }\n\n    private static class WorkerThread1 extends Thread {\n        public void run() {\n            synchronized (Lock1) {\n                System.out.println(\"Thread 1: Holding lock 1...\");\n\n                try {\n                    Thread.sleep(10);\n                }\n                catch (InterruptedException e) {\n                    System.out.println(e.getStackTrace());\n                }\n                System.out.println(\"Thread 1: Waiting for lock 2...\");\n\n                synchronized (Lock2) {\n                    System.out.println(\"Thread 1: Holding lock 1 &amp; 2...\");\n                }\n            }\n        }\n    }\n\n    private static class WorkerThread2 extends Thread {\n        public void run() {\n            synchronized (Lock2) {\n                System.out.println(\"Thread 2: Holding lock 2...\");\n\n                try {\n                    Thread.sleep(10);\n                }\n                catch (InterruptedException e) {\n                    System.out.println(e.getStackTrace());\n                }\n                System.out.println(\"Thread 2: Waiting for lock 1...\");\n\n                synchronized (Lock1) {\n                    System.out.println(\"Thread 2: Holding lock 1 &amp; 2...\");\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Thread 1: Holding lock 1...\nThread 2: Holding lock 2...\nThread 2: Waiting for lock 1...\nThread 1: Waiting for lock 2...\n2019-08-02T21:32:33.856: Deadlock detected!\n\"Thread-1\" Id=13 BLOCKED on java.lang.Object@10e3c837 owned by \"Thread-0\" Id=12\n johnny.java.concurrency.deadlock.detection.DetectionExample$WorkerThread2.run(DetectionExample.java:54)\n\"Thread-0\" Id=12 BLOCKED on java.lang.Object@14dc4ef3 owned by \"Thread-1\" Id=13\n johnny.java.concurrency.deadlock.detection.DetectionExample$WorkerThread1.run(DetectionExample.java:34)\n2019-08-02T21:32:38.832: Deadlock detected!\n\"Thread-1\" Id=13 BLOCKED on java.lang.Object@10e3c837 owned by \"Thread-0\" Id=12\n johnny.java.concurrency.deadlock.detection.DetectionExample$WorkerThread2.run(DetectionExample.java:54)\n\"Thread-0\" Id=12 BLOCKED on java.lang.Object@14dc4ef3 owned by \"Thread-1\" Id=13\n johnny.java.concurrency.deadlock.detection.DetectionExample$WorkerThread1.run(DetectionExample.java:34)\n2019-08-02T21:32:43.835: Deadlock detected!\n</code></pre> <ul> <li>Notice the interval of detection is 5 seconds.</li> </ul>"},{"location":"java-concurrency/java-concurrency-dead-lock/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Dead Lock on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-dead-lock/#references","title":"References","text":"<ul> <li>Java - Thread Deadlock</li> <li>Deadlock in Java Multithreading</li> <li>How to Detect Java Deadlocks Programmatically</li> </ul>"},{"location":"java-concurrency/java-concurrency-fork-join/","title":"Fork-join","text":"<p>The <code>fork-join</code> framework allows to break a certain task on several workers and then wait for the result to combine them. It leverages multi-processor machine's capacity to great extent.</p> <ul> <li><code>Fork</code> - A process in which a task splits itself into smaller and independent sub-tasks which can be executed concurrently.</li> <li><code>Join</code> - A process in which a task join all the results of sub-tasks once the subtasks have finished executing, otherwise it keeps waiting.</li> </ul> <p>Classes:</p> <ul> <li><code>ForkJoinPool</code> - A special thread pool designed to work with fork-and-join task splitting.</li> <li><code>RecursiveTask&lt;V&gt;</code> - RecursiveTask represents a task which returns a value.</li> <li><code>RecursiveAction</code> - Just like RecursiveTask except it does not return a result</li> <li><code>ForkJoinTask&lt;V&gt;</code> - Superclass of <code>RecursiveTask&lt;V&gt;</code> and RecursiveAction. fork() and join() are methods defined in this class.</li> </ul>"},{"location":"java-concurrency/java-concurrency-fork-join/#example","title":"Example","text":"<p>Create an array with random numbers, then count how many numbers are larger than 0.5.</p>"},{"location":"java-concurrency/java-concurrency-fork-join/#counter","title":"Counter","text":"<pre><code>import java.util.concurrent.RecursiveTask;\nimport java.util.function.Predicate;\n\npublic class Counter extends RecursiveTask&lt;Integer&gt; {\n    static final int THRESHOLD = 100;\n    private double[] numbers;\n    private int from;\n    private int to;\n    private Predicate&lt;Double&gt; filter;\n\n    public Counter(double[] numbers, int from, int to, Predicate&lt;Double&gt; filter) {\n        this.numbers = numbers;\n        this.from = from;\n        this.to = to;\n        this.filter = filter;\n    }\n\n    @Override\n    protected Integer compute() {\n        if (to - from &lt; THRESHOLD) { // no need to split, calculate the result\n            int count = 0;\n            for (int i = from; i &lt; to; i++) {\n                if (filter.test(numbers[i])) {\n                    count++;\n                }\n            }\n            return count;\n        } else { // split to smaller tasks\n            int mid = (to - from ) / 2 + from;\n            Counter first = new Counter(numbers, from, mid, filter);\n            Counter second = new Counter(numbers, mid, to, filter);\n            invokeAll(first, second); //\n            return first.join() + second.join();\n        }\n    }\n}\n</code></pre> <ul> <li>Override the <code>compute()</code> method to generate and invoke subtasks, and to combine their results.</li> <li><code>THRESHOLD</code> is used to determine whether to execute the calculation or continue splitting.</li> <li>The <code>invokeAll</code> method receives a number of tasks and blocks until all of them have completed.</li> <li>The <code>join</code> method yields the result.</li> </ul> <pre><code>public class ForkJoinExample {\n    static final int size = 10000;\n    public static void main(String[] args) {\n        double[] numbers = new double[size];\n        // generate random numbers\n        for (int i = 0; i &lt; size; i++) {\n            numbers[i] = Math.random();\n        }\n        Counter counter = new Counter(numbers, 0, numbers.length, x-&gt;x &gt; 0.5);\n        ForkJoinPool pool = new ForkJoinPool();\n        pool.invoke(counter); // Performs the given task, returning its result upon completion.\n        System.out.println(counter.join()); // output: 500305\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>5036\n</code></pre>"},{"location":"java-concurrency/java-concurrency-fork-join/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Fork-Join on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-fork-join/#references","title":"References","text":"<ul> <li>Java Concurrency - Fork-Join framework</li> </ul>"},{"location":"java-concurrency/java-concurrency-multithreading/","title":"MultiThreading","text":""},{"location":"java-concurrency/java-concurrency-multithreading/#how-to-create-a-thread-with-java","title":"How to Create a Thread with Java?","text":"<p>Java lets you create thread in following two ways:</p> <ul> <li>By implementing the <code>Runnable</code> interface.</li> <li>By extending the <code>Thread</code> class.</li> </ul>"},{"location":"java-concurrency/java-concurrency-multithreading/#runnable-interface","title":"Runnable Interface","text":"<pre><code>public interface Runnable {\n    void run();\n}\n</code></pre> <p>Create a new class to implement Runnable interface.</p> <pre><code>public class MyRunnable implements Runnable {\n    public void run(){\n        System.out.println(\"MyRunnable is running ...\");\n    }\n}\n</code></pre> <p>Then, create thread with the instance of MyRunnable as input parameter.</p> <pre><code>Thread thread = new Thread(new MyRunnable());\nthread.start();\n</code></pre> <p>Output.</p> <pre><code>MyRunnable is running ...\n</code></pre>"},{"location":"java-concurrency/java-concurrency-multithreading/#thread-class","title":"Thread Class","text":"<p>Create a new class to extend Thread class.</p> <pre><code>public class MyThread extends Thread {\n    public void run() {\n        System.out.println(\"MyThread is running ...\");\n    }\n}\n</code></pre> <p>Then, create an instance for this MyThread class and run it.</p> <pre><code>MyThread myThread = new MyThread();\nmyThread.start();\n</code></pre> <p>Output.</p> <pre><code>MyThread is running ...\n</code></pre>"},{"location":"java-concurrency/java-concurrency-multithreading/#methods-in-thread-class","title":"Methods in Thread class","text":"<ul> <li>getName() - Obtain thread\u2019s name</li> <li>getPriority() - Obtain thread\u2019s priority</li> <li>isAlive() - Determine if a thread is still running</li> <li>join() - Wait for a thread to terminate</li> <li>run() - Entry point for the thread</li> <li>sleep() - Suspend a thread for a period of time</li> <li>start() - Start a thread by calling its run method</li> </ul>"},{"location":"java-concurrency/java-concurrency-multithreading/#daemon-threads","title":"Daemon Threads","text":"<p>A daemon is simply a thread that has no other role in life than to serve others. Examples are timer threads that send regular 'timer ticks' to other threads or threads that clean up stale cache entries.</p> <pre><code>t.setDaemon(true);\n</code></pre>"},{"location":"java-concurrency/java-concurrency-multithreading/#thread-states","title":"Thread States","text":"<ul> <li><code>New</code> - When a new thread is created, it is in the new state. (new Thread();)</li> <li><code>Runnable</code> - A thread that is ready to run is moved to runnable state. (t1.run();)</li> <li><code>Blocked</code> - When a thread is temporarily inactive, e.g. (require a lock)</li> <li><code>Waiting</code> - When a thread is temporarily inactive, e.g. (wait on a condition);</li> <li><code>Timed Waiting</code> - A thread lies in timed waiting state when it calls a method with a time out parameter. (Thread.sleep(1000);)</li> <li><code>Terminated</code> -  A thread terminates because of either of the following reasons: Normally exits or interrupted.</li> </ul>"},{"location":"java-concurrency/java-concurrency-multithreading/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Thread on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-multithreading/#references","title":"References","text":"<ul> <li>Creating and Starting Java Threads</li> <li>Java Concurrency Tutorial</li> </ul>"},{"location":"java-concurrency/java-concurrency-overview/","title":"Concurrency overview","text":""},{"location":"java-concurrency/java-concurrency-overview/#how-to-create-a-java-thread","title":"How to Create a Java Thread?","text":"<p>Java lets you create thread in following two ways:</p> <ul> <li>By implementing the <code>Runnable</code> interface.</li> <li>By extending the <code>Thread</code></li> </ul>"},{"location":"java-concurrency/java-concurrency-overview/#runnable-interface","title":"Runnable Interface","text":"<pre><code>public interface Runnable {\n    void run();\n}\n</code></pre> <p>Create a class to implement the interface.</p> <pre><code>public class MyClass implements Runnable {\n    public void run(){\n        System.out.println(\"MyClass running\");\n    }\n}\n</code></pre> <p>Create thread and run it.</p> <pre><code>Thread t1 = new Thread(new MyClass ());\nt1.start();\n</code></pre>"},{"location":"java-concurrency/java-concurrency-overview/#thread-class","title":"Thread Class","text":"<p>Create a class to extend the Thread class.</p> <pre><code>public class MyClass extends Thread {\n    public void run(){\n        System.out.println(\"MyClass running\");\n    }\n}\n</code></pre> <p>Create thread and run it.</p> <pre><code>MyClass t2 = new MyClass();\nt2.start();\n</code></pre>"},{"location":"java-concurrency/java-concurrency-overview/#thread-states","title":"Thread States","text":"<ul> <li><code>New</code> - When a new thread is created, it is in the new state. (new Thread();)</li> <li><code>Runnable</code> - A thread that is ready to run is moved to runnable state. (t1.run();)</li> <li><code>Blocked</code> - When a thread is temporarily inactive, e.g. (require a lock)</li> <li><code>Waiting</code> - When a thread is temporarily inactive, e.g. (wait on a condition);</li> <li><code>Timed Waiting</code> - A thread lies in timed waiting state when it calls a method with a time out parameter. (Thread.sleep(1000);)</li> <li><code>Terminated</code> -  A thread terminates because of either of the following reasons: Normally exits or interrupted.</li> </ul>"},{"location":"java-concurrency/java-concurrency-overview/#synchronization","title":"Synchronization","text":"<p>Monitor, lock, race condition.Reentrant Lock, Intrinsic Lock</p>"},{"location":"java-concurrency/java-concurrency-overview/#thread-pool","title":"Thread Pool","text":""},{"location":"java-concurrency/java-concurrency-overview/#synchronizers","title":"Synchronizers","text":"<p>The java.util.concurrent package contains several classes that help manage a set of collaborating threads. These mechanisms have \u201ccanned functionality\u201d for common rendezvous patterns between threads. If you have a set of collaborating threads that follow one of these behavior patterns, you should simply reuse the appropriate library class instead of trying to come up with a handcrafted collection of locks and conditions.</p> Class What It Does Notes <code>CyclicBarrier</code> Allows a set of threads to wait until a predefined count of them has reached a common barrier, and then optionally executes a barrier action. Use when a number of threads need to complete before their results can be used. The barrier can be reused after the waiting threads have been released. <code>Phaser</code> Like a cyclic barrier, but with a mutable party count. Introduced in Java SE 7. <code>CountDownLatch</code> Allows a set of threads to wait until a count has been decremented to 0. Use when one or more threads need to wait until a specified number of events have occurred. <code>Exchanger</code> Allows two threads to exchange objects when both are ready for the exchange. Use when two threads work on two instances of the same data structure, with the first thread filling one instance and the second thread emptying the other. <code>Semaphore</code> Allows a set of threads to wait until permits are available for proceeding. Use to restrict the total number of threads that can access a resource. If the permit count is one, use to block threads until another thread gives permission. <code>SynchronousQueue</code> Allows a thread to hand off an object to another thread. Use to send an object from one thread to another when both are ready, without explicit synchronization."},{"location":"java-concurrency/java-concurrency-overview/#references","title":"References","text":"<ul> <li>Java Concurrency and Multithreading Tutorial</li> <li>Lifecycle and States of a Thread in Java</li> <li>Synchronized in Java</li> <li>Remember the types of intrinsic lock</li> <li>Java - Thread Deadlock</li> <li>Java ThreadLocal</li> <li>Reentrant Lock in Java</li> <li>Thread Pools in Java</li> <li>Callable and Future in Java</li> <li>Semaphore in Java</li> <li>CountDownLatch in Java</li> </ul>"},{"location":"java-concurrency/java-concurrency-reading-files-in-parallel/","title":"Reading Files in Parallel","text":"<p>Use different approaches to read files in parallel, and combine the results.</p>"},{"location":"java-concurrency/java-concurrency-reading-files-in-parallel/#naive-with-runnable","title":"Naive with Runnable","text":"<p>RunnableTask.</p> <pre><code>public class RunnableTask implements Runnable {\n    private String filename;\n    private String content;\n\n    public RunnableTask(String filename) {\n        this.filename = filename;\n        this.content = \"\";\n        System.out.println(\"Create Task to get content from \" + filename);\n    }\n\n    public String getFileName() {\n        return filename;\n    }\n\n    public void run() {\n        try {\n            String currentDir = System.getProperty(\"user.dir\");\n            Path path = Paths.get(currentDir, \"java-concurrency-readfiles\", \"files\", filename);\n            File file = path.toFile();\n\n            BufferedReader br = new BufferedReader(new FileReader(file));\n\n            String line;\n            while ((line = br.readLine()) != null) {\n                content += line;\n            }\n\n        } catch (FileNotFoundException e1) {\n            e1.printStackTrace();\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        }\n    }\n\n    public String getContent() { return content; }\n}\n</code></pre> <p>Test class.</p> <pre><code>public class RunnableExample {\n    public static void main(String[] args) {\n        // create tasks\n        List&lt;RunnableTask&gt; tasks = new ArrayList&lt;&gt;();\n        List&lt;Thread&gt; threads = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 5; i++) {\n            RunnableTask task = new RunnableTask(\"test\" + (i + 1) + \".txt\");\n            Thread t = new Thread(task);\n            t.start();\n            tasks.add(task);\n            threads.add(t);\n        }\n\n        // wait for threads to finish\n        try {\n            for (int i = 0; i &lt; 5; i++) {\n                threads.get(i).join();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // collect results\n        String content = \"\";\n        for (int i = 0; i&lt; 5; i++) {\n            content += tasks.get(i).getContent() + System.lineSeparator();\n        }\n\n        System.out.println(\"Result:\");\n        System.out.println(content);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Create Task to get content from test1.txt\nCreate Task to get content from test2.txt\nCreate Task to get content from test3.txt\nCreate Task to get content from test4.txt\nCreate Task to get content from test5.txt\nResult:\nHello world!\nYou're awesome!\nToo young, too simple!\nHave a nice day!\nLook forward to talking with you.\n</code></pre>"},{"location":"java-concurrency/java-concurrency-reading-files-in-parallel/#callable-future","title":"Callable + Future","text":"<p>CallableTask.</p> <pre><code>public class CallableTask implements Callable&lt;String&gt; {\n    private String filename;\n\n    public CallableTask(String filename) {\n        this.filename = filename;\n        System.out.println(\"Create Callable task to get content from \" + filename);\n    }\n\n    public String getFileName() {\n        return filename;\n    }\n\n    public String call() {\n        String content = \"\";\n        try {\n            String currentDir = System.getProperty(\"user.dir\");\n            Path path = Paths.get(currentDir, \"java-concurrency-readfiles\", \"files\", filename);\n            File file = path.toFile();\n\n            BufferedReader br = new BufferedReader(new FileReader(file));\n\n            String line;\n            while ((line = br.readLine()) != null) {\n                content += line;\n            }\n\n        } catch (FileNotFoundException e1) {\n            e1.printStackTrace();\n        } catch (IOException e1) {\n            e1.printStackTrace();\n        } finally {\n            return content;\n        }\n    }\n}\n</code></pre> <p>Test class.</p> <pre><code>public class CallableExample {\n    public static void main(String[] args) throws Exception {\n        // create tasks\n        List&lt;Callable&lt;String&gt;&gt; tasks = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 5; i++) {\n            tasks.add(new CallableTask(\"test\" + (i + 1) + \".txt\"));\n        }\n\n        // create threads for each task\n        ExecutorService exec = Executors.newFixedThreadPool(2);\n        List&lt;Future&lt;String&gt;&gt; results = exec.invokeAll(tasks);\n        exec.shutdown();\n\n        // collect results\n        System.out.println(\"Result:\");\n        String content = \"\";\n        try {\n            for (Future&lt;String&gt; future : results) {\n                content += future.get() + System.lineSeparator();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(content);\n    }\n\n    public static void main2(String[] args) {\n        List&lt;Future&lt;String&gt;&gt; list = new ArrayList&lt;Future&lt;String&gt;&gt;();\n\n        // create threads for each task\n        ThreadPoolExecutor executor = (ThreadPoolExecutor) Executors.newFixedThreadPool(2);\n\n        for (int i = 1; i &lt;= 5; i++) {\n            CallableTask task = new CallableTask(\"test\" + i + \".txt\");\n\n            Future&lt;String&gt; future = executor.submit(task);\n            list.add(future);\n        }\n        executor.shutdown();\n\n        // collect results\n        System.out.println(\"Result:\");\n        String content = \"\";\n        try {\n            for (Future&lt;String&gt; future : list) {\n                content += future.get() + System.lineSeparator();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        } catch (ExecutionException e) {\n            e.printStackTrace();\n        }\n        System.out.println(content);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Create Callable task to get content from test1.txt\nCreate Callable task to get content from test2.txt\nCreate Callable task to get content from test3.txt\nCreate Callable task to get content from test4.txt\nCreate Callable task to get content from test5.txt\nResult:\nHello world!\nYou're awesome!\nToo young, too simple!\nHave a nice day!\nLook forward to talking with you.\n</code></pre>"},{"location":"java-concurrency/java-concurrency-reading-files-in-parallel/#cyclicbarrier","title":"CyclicBarrier","text":"<p>CyclicBarrierTask.</p> <pre><code>public class CyclicBarrierTask implements Runnable {\n    private String filename;\n    private String content;\n    private final CyclicBarrier cyclicBarrier;\n\n    public CyclicBarrierTask(String filename, CyclicBarrier cyclicBarrier) {\n        this.filename = filename;\n        this.content = \"\";\n        this.cyclicBarrier = cyclicBarrier;\n        System.out.println(\"Create Task to get content from \" + filename);\n    }\n\n    public void run() {\n        try {\n            String currentDir = System.getProperty(\"user.dir\");\n            Path path = Paths.get(currentDir, \"java-concurrency-readfiles\", \"files\", filename);\n            File file = path.toFile();\n\n            BufferedReader br = new BufferedReader(new FileReader(file));\n\n            String line;\n            while ((line = br.readLine()) != null) {\n                content += line;\n            }\n            cyclicBarrier.await();\n        } catch (FileNotFoundException nfe) {\n            nfe.printStackTrace();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        } catch (InterruptedException | BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String getContent() { return content; }\n}\n</code></pre> <p>Test class.</p> <pre><code>public class CyclicBarrierExample {\n    public static void main(String[] args) {\n        CyclicBarrier barrier = new CyclicBarrier(6);\n        System.out.println(\"Number of parties required to trip the barrier = \" +\n                barrier.getParties());\n\n        // create tasks\n        List&lt;CyclicBarrierTask&gt; tasks = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 5; i++) {\n            CyclicBarrierTask task = new CyclicBarrierTask(\"test\" + (i + 1) + \".txt\", barrier);\n            Thread t = new Thread(task);\n            t.start();\n            tasks.add(task);\n        }\n\n        try {\n            barrier.await();\n        }\n        catch (InterruptedException | BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n\n        // number of parties waiting at the barrier\n        System.out.println(\"Number of parties waiting at the barrier \"+\n                \"at this point = \" + barrier.getNumberWaiting());\n        // barrier breaks as the number of thread waiting for the barrier at this point = 0\n\n        // collect results\n        String content = \"\";\n        for (int i = 0; i&lt; 5; i++) {\n            content += tasks.get(i).getContent() + System.lineSeparator();\n        }\n\n        System.out.println(\"Result:\");\n        System.out.println(content);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Number of parties required to trip the barrier = 6\nCreate Task to get content from test1.txt\nCreate Task to get content from test2.txt\nCreate Task to get content from test3.txt\nCreate Task to get content from test4.txt\nCreate Task to get content from test5.txt\nNumber of parties waiting at the barrier at this point = 0\nResult:\nHello world!\nYou're awesome!\nToo young, too simple!\nHave a nice day!\nLook forward to talking with you.\n</code></pre>"},{"location":"java-concurrency/java-concurrency-reading-files-in-parallel/#countdownlatch","title":"CountDownLatch","text":"<p>CountDownLatchTask.</p> <pre><code>public class CountDownLatchTask extends Thread {\n    private String filename;\n    private String content;\n    private CountDownLatch latch;\n\n    public CountDownLatchTask(String filename, CountDownLatch latch) {\n        this.filename = filename;\n        this.content = \"\";\n        this.latch = latch;\n        System.out.println(\"Create Task to get content from \" + filename);\n    }\n\n    @Override\n    public void run() {\n        try {\n            String currentDir = System.getProperty(\"user.dir\");\n            Path path = Paths.get(currentDir, \"java-concurrency-readfiles\", \"files\", filename);\n            File file = path.toFile();\n\n            BufferedReader br = new BufferedReader(new FileReader(file));\n\n            String line;\n            while ((line = br.readLine()) != null) {\n                content += line;\n            }\n            latch.countDown();\n\n        } catch (FileNotFoundException nfe) {\n            nfe.printStackTrace();\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n        }\n    }\n\n    public String getContent() { return content; }\n}\n</code></pre> <p>Test class.</p> <pre><code>public class CountDownLatchExample {\n    public static void main(String args[]) throws InterruptedException {\n        // Create task that is going to wait for five threads before it starts\n        CountDownLatch latch = new CountDownLatch(5);\n\n        // create tasks\n        List&lt;CountDownLatchTask&gt; tasks = new ArrayList&lt;&gt;();\n        for (int i = 0; i &lt; 5; i++) {\n            CountDownLatchTask task = new CountDownLatchTask(\"test\" + (i + 1) + \".txt\", latch);\n            Thread t = new Thread(task);\n            t.start();\n            tasks.add(task);\n        }\n\n        // The main task waits for four threads\n        latch.await();\n\n        // collect results\n        String content = \"\";\n        for (int i = 0; i&lt; 5; i++) {\n            content += tasks.get(i).getContent() + System.lineSeparator();\n        }\n\n        System.out.println(\"Result:\");\n        System.out.println(content);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Create Task to get content from test1.txt\nCreate Task to get content from test2.txt\nCreate Task to get content from test3.txt\nCreate Task to get content from test4.txt\nCreate Task to get content from test5.txt\nResult:\nHello world!\nYou're awesome!\nToo young, too simple!\nHave a nice day!\nLook forward to talking with you.\n</code></pre>"},{"location":"java-concurrency/java-concurrency-reading-files-in-parallel/#source-files","title":"Source Files","text":"<ul> <li>Source files for Reading Files in Parallel on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-reading-files-in-parallel/#references","title":"References","text":"<ul> <li>Java Thread Pool \u2013 ThreadPoolExecutor Example</li> <li>Multithreading a massive file read</li> <li>Java Callable Future Example</li> <li>Different ways of Reading a text file in Java</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronization/","title":"Synchronization","text":"<p>Synchronization in Java is the capability to control the access of multiple threads to any shared resource. Java Synchronization is better option where we want to allow only one thread to access the shared resource.</p> <p>The synchronization is mainly used to</p> <ul> <li>Prevent thread interference.</li> <li>Prevent consistency problem.</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronization/#concurrency-issues","title":"Concurrency Issues","text":"<p>Example of Race Condition.</p> <p>Consider the following <code>Counter</code> class which contains an increment() method that increments the count by one, each time it is invoked.</p> <pre><code>public class Counter {\n    private int count = 0;\n\n    public void increment() { // method not synchronized\n        count = count +  1;\n        System.out.println(count);\n    }\n}\n</code></pre> <p>Let\u2019s assume that two threads try to increment the count by calling the increment() method simultaneously.</p> <pre><code>public class RaceConditionExample {\n    public static void main(String[] args) {\n        Counter counter = new Counter();\n        WorkerThread1 t1 = new WorkerThread1(counter);\n        WorkerThread2 t2 = new WorkerThread2(counter);\n        t1.start();\n        t2.start();\n    }\n}\npublic class WorkerThread1 extends Thread {\n    private Counter counter;\n    public WorkerThread1(Counter counter) {\n        this.counter = counter;\n    }\n    public void run(){\n        for (int i = 0; i &lt; 10; i++) {\n            this.counter.increment();\n        }\n    }\n}\npublic class WorkerThread2 extends Thread {\n    private Counter counter;\n    public WorkerThread1(Counter counter) {\n        this.counter = counter;\n    }\n    public void run(){\n        for (int i = 0; i &lt; 10; i++) {\n            this.counter.increment();\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>1\n3\n2\n5\n6\n7\n8\n9\n10\n11\n12\n13\n4\n14\n15\n16\n17\n18\n19\n20\n</code></pre> <ul> <li>Notice that the number is not in sequence.</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronization/#solution-for-concurrency-issues","title":"Solution for Concurrency Issues","text":"<p>To solve the problem, we need to declare the increment() method as <code>synchronized</code>.</p> <pre><code>public class Counter {\n    private int count = 0;\n\n    public synchronized void increment() { //synchronized method  \n        count = count +  1;\n        System.out.println(count);\n    }\n}\n</code></pre> <p>Run again, we will get the following sequential numbers.</p> <pre><code>1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n</code></pre>"},{"location":"java-concurrency/java-concurrency-synchronization/#synchronized-keyword-and-intrinsic-lock","title":"synchronized Keyword and Intrinsic Lock","text":"<p>Following is the general form of a synchronized block:</p> <pre><code>// Only one thread can execute at a time.\n// 'sync_object' is a reference to an object whose lock associates with the monitor.\n// The code is said to be synchronized on the monitor object.\nsynchronized(sync_object)\n{\n   // Access shared variables and other\n   // shared resources\n}\n</code></pre>"},{"location":"java-concurrency/java-concurrency-synchronization/#synchronized-method-and-synchronized-block","title":"Synchronized Method and Synchronized Block","text":"<p>Example1: synchronize on method.</p> <pre><code>public class Sender {\n    public synchronized void send(String msg) {\n        System.out.println(\"Sending: \" + msg);\n        try\n        {\n            Thread.sleep(1000);\n        }\n        catch (Exception e)\n        {\n            System.out.println(\"Thread interrupted.\");\n        }\n        System.out.println(msg + \" is sent.\");\n    }\n}\n</code></pre> <p>Example2: synchronize on code block(synchronize only part of a method.).</p> <pre><code>public class Sender {\n    public void send(String msg) {\n        synchronized(this)\n        {\n            System.out.println(\"Sending: \" + msg);\n            try\n            {\n                Thread.sleep(1000);\n            }\n            catch (Exception e)\n            {\n                System.out.println(\"Thread interrupted.\");\n            }\n            System.out.println(msg + \" is sent.\");\n        }\n    }\n}\n</code></pre>"},{"location":"java-concurrency/java-concurrency-synchronization/#intrinsiclock","title":"intrinsicLock","text":"<p>Each we use synchronized keyword, actually we are creating intrinsic lock.</p> <p>Synchronize method.</p> <pre><code>public synchronized void method()\n{\n    //method body\n}\n</code></pre> <p>The above code is equivalent to:</p> <pre><code>public void method() {\n    this.intrinsicLock.lock();\n    try\n    {\n        //method body\n    }\n    finally\n    {\n        this.intrinsicLock.unlock();\n    }\n}\n</code></pre>"},{"location":"java-concurrency/java-concurrency-synchronization/#types-of-intrinsic-lock","title":"Types of Intrinsic Lock","text":"<p>In Java, an <code>intrinsic lock</code> is implied by each use of the synchronized keyword. In this case, the locking is performed by Java behind the scenes. (This is distinct from the programmer using or defining an explicit lock object themselves.) Each use of the synchronized keyword is associated with one of the two types of intrinsic lock:</p> <ul> <li>an \"instance lock\", attached to a single object</li> <li>a \"static lock\", attached to a class</li> </ul> <p>Here is a synchronized instance method:</p> <pre><code>public synchronized void add(int value){\n    this.count += value;\n}\n</code></pre> <p>Here is a synchronized static method:</p> <pre><code>public static synchronized void add(int value){\n    count += value;\n}\n</code></pre> <p>If a method is declared as synchronized, then it will acquire either the instance lock or the static lock when it is invoked, according to whether it is an instance method or a static method.</p> <p>The two types of lock have similar behavior, but are completely independent of each other.</p> <ul> <li>Acquiring the instance lock only blocks other threads from invoking a synchronized instance method; it does not block other threads from invoking an un-synchronized method, nor does it block them from invoking a static synchronized method.</li> <li>Similarly, acquiring the static lock only blocks other threads from invoking a static synchronized method; it does not block other threads from invoking an un-synchronized method, nor does it block them from invoking a synchronized instance method.</li> </ul> <p>Outside of a method header, synchronized(this) acquires the instance lock.</p> <p>The static lock can be acquired outside of a method header in two ways:</p> <ul> <li>synchronized(Blah.class), using the class literal</li> <li>synchronized(this.getClass()), if an object is available</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronization/#monitor","title":"Monitor","text":"<p>In Java, the synchronization is implemented with a concept called <code>monitors</code>. Only one thread can own a monitor at a given time. When a thread acquires a lock, it is said to have entered the monitor. All other threads attempting to enter the locked monitor will be suspended until the first thread exits the monitor.</p>"},{"location":"java-concurrency/java-concurrency-synchronization/#the-monitor-concept","title":"The Monitor Concept","text":"<p>In the terminology of Java, a monitor has these properties:</p> <ul> <li>A monitor is a class with only private fields.</li> <li>Each object of that class has an associated lock.</li> <li>All methods are locked by that lock. In other words, if a client calls obj.method(), then the lock for obj is automatically acquired at the beginning of the method call and relinquished when the method returns. Since all fields are private, this arrangement ensures that no thread can access the fields while another thread manipulates them.</li> <li>The lock can have any number of associated conditions.</li> </ul> <p>Every object in Java has an intrinsic lock and an intrinsic condition. If a method is declared with the synchronized keyword, it acts like a monitor method. The condition variable is accessed by calling 'wait/notifyAll/notify'.</p>"},{"location":"java-concurrency/java-concurrency-synchronization/#reentrant-lock","title":"Reentrant Lock","text":"<p>The <code>ReentrantLock</code> class implements the <code>Lock</code> interface and provides synchronization to methods while accessing shared resources. The code which manipulates the shared resource is surrounded by calls to lock and unlock method. Reentrant Locks are provided in Java to provide synchronization with greater <code>flexibility</code>.</p> <pre><code>Lock reentrantlock = new ReentrantLock();\n\npublic void some_method()\n{\n    reentrantlock.lock();\n    try\n    {\n        //Do some work\n    }\n    catch(Exception e)\n    {\n        e.printStackTrace();\n    }\n    finally\n    {\n        reentrantlock.unlock();\n    }\n}\n</code></pre> <ul> <li>The <code>unlock</code> statement is always called in the finally block to ensure that the lock is released even if an exception is thrown in the method body(try block).</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronization/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Synchronization on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronization/#references","title":"References","text":"<ul> <li>Synchronization in Java</li> <li>Race Conditions and Critical Sections</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronizers/","title":"Synchronizers","text":""},{"location":"java-concurrency/java-concurrency-synchronizers/#types-of-synchronizers","title":"Types of Synchronizers","text":"<p>The java.util.concurrent package contains several classes that help manage a set of collaborating threads. These mechanisms have \u201ccanned functionality\u201d for common rendezvous patterns between threads. If you have a set of collaborating threads that follow one of these behavior patterns, you should simply reuse the appropriate library class instead of trying to come up with a handcrafted collection of locks and conditions.</p> Class What It Does Notes <code>CyclicBarrier</code> Allows a set of threads to wait until a predefined count of them has reached a common barrier, and then optionally executes a barrier action. Use when a number of threads need to complete before their results can be used. The barrier can be reused after the waiting threads have been released. <code>Phaser</code> Like a cyclic barrier, but with a mutable party count. Introduced in Java SE 7. <code>CountDownLatch</code> Allows a set of threads to wait until a count has been decremented to 0. Use when one or more threads need to wait until a specified number of events have occurred. <code>Exchanger</code> Allows two threads to exchange objects when both are ready for the exchange. Use when two threads work on two instances of the same data structure, with the first thread filling one instance and the second thread emptying the other. <code>Semaphore</code> Allows a set of threads to wait until permits are available for proceeding. Use to restrict the total number of threads that can access a resource. If the permit count is one, use to block threads until another thread gives permission. <code>SynchronousQueue</code> Allows a thread to hand off an object to another thread. Use to send an object from one thread to another when both are ready, without explicit synchronization."},{"location":"java-concurrency/java-concurrency-synchronizers/#cyclicbarrier","title":"CyclicBarrier","text":"<p>CyclicBarrier is used to make threads wait for each other. It is used when different threads process a part of computation and when all threads have completed the execution, the result needs to be combined in the parent thread. In other words, a CyclicBarrier is used when multiple thread carry out different sub tasks and the output of these sub tasks need to be combined to form the final output.</p> <p>The following example is to calculate the result of (2 3) + (10 20), which is 206.</p> <p>Create two sub task threads.</p> <pre><code>public class Computation1 implements Runnable {\n    public static int product = 0;\n    private final CyclicBarrier cyclicBarrier;\n\n    public Computation1(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n\n    public void run() {\n        product = 2 * 3;\n        try {\n            Thread.sleep(1000);\n            // number of parties waiting at the barrier\n            System.out.println(\"Number of parties waiting at the barrier \"+\n                    \"at this point = \" + cyclicBarrier.getNumberWaiting());\n            cyclicBarrier.await();\n        }\n        catch (InterruptedException | BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\npublic class Computation2 implements Runnable {\n    public static int product = 0;\n    private final CyclicBarrier cyclicBarrier;\n\n    public Computation2(CyclicBarrier cyclicBarrier) {\n        this.cyclicBarrier = cyclicBarrier;\n    }\n\n    public void run() {\n        product = 10 * 20;\n        try {\n            Thread.sleep(2000);\n            // number of parties waiting at the barrier\n            System.out.println(\"Number of parties waiting at the barrier \"+\n                    \"at this point = \" + cyclicBarrier.getNumberWaiting());\n            cyclicBarrier.await();\n        }\n        catch (InterruptedException | BrokenBarrierException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>The main thread creates two sub threads and will wait them to finish their execution.</p> <pre><code>/*\n    Calculate result of (2*3) + (10*20) = 206\n */\npublic class CyclicBarrierExample {\n    public static void main(String[] args) {\n        final CyclicBarrier barrier = new CyclicBarrier(3);\n        System.out.println(\"Number of parties required to trip the barrier = \" +\n                barrier.getParties());\n        System.out.println(\"Product of Computation1 = \" + Computation1.product);\n        System.out.println(\"Product of Computation2 = \" + Computation2.product);\n\n        Thread t1 = new Thread(new Computation1(barrier));\n        Thread t2 = new Thread(new Computation2(barrier));\n        t1.start();\n        t2.start();\n\n        try {\n            barrier.await();\n        }\n        catch (InterruptedException | BrokenBarrierException e)\n        {\n            e.printStackTrace();\n        }\n\n        // number of parties waiting at the barrier\n        System.out.println(\"Number of parties waiting at the barrier \"+\n                \"at this point = \" + barrier.getNumberWaiting());\n        // barrier breaks as the number of thread waiting for the barrier at this point = 0\n        System.out.println(\"Product of Computation1 = \" + Computation1.product);\n        System.out.println(\"Product of Computation2 = \" + Computation2.product);\n\n        System.out.println(\"Final result = \" + (Computation1.product + Computation2.product));\n\n        // Resetting the newBarrier\n        barrier.reset();\n        System.out.println(\"Barrier reset successful\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Number of parties required to trip the barrier = 3\nProduct of Computation1 = 0\nProduct of Computation2 = 0\nNumber of parties waiting at the barrier at this point = 1\nNumber of parties waiting at the barrier at this point = 2\nNumber of parties waiting at the barrier at this point = 0\nProduct of Computation1 = 6\nProduct of Computation2 = 200\nFinal result = 206\nBarrier reset successful\n</code></pre>"},{"location":"java-concurrency/java-concurrency-synchronizers/#countdownlatch","title":"CountDownLatch","text":"<p>CountDownLatch is used to make sure that a task waits for other threads before it starts.</p> <p>Create a worker thread. It accepts a CountDownLatch object passed from the main thread.</p> <pre><code>public class Worker extends Thread {\n    private int delay;\n    private CountDownLatch latch;\n\n    public Worker(String name, int delay, CountDownLatch latch) {\n        super(name);\n        this.delay = delay;\n        this.latch = latch;\n    }\n\n    @Override\n    public void run() {\n        try {\n            Thread.sleep(delay);\n            latch.countDown();\n\n            System.out.println(Thread.currentThread().getName() +\n                    \" finished, remaining count = \" + latch.getCount());\n        }\n        catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <ul> <li><code>countDown()</code> method decrements the count.</li> </ul> <p>Then, create the main thread with four workers. Create an object of CountDownLatch by passing an int to its constructor (the count), which is actually the number of invited parties (threads) for an event. The main thread is dependent on other threads to start processing, waits on until every other thread has called count down.</p> <pre><code>public class CountDownLatchExample {\n    public static void main(String args[]) throws InterruptedException {\n        // Create task that is going to wait for four threads before it starts\n        CountDownLatch latch = new CountDownLatch(4);\n\n        // Create four worker threads and start them\n        Worker first = new Worker(\"Worker1\", 1000, latch);\n        Worker second = new Worker(\"Worker2\", 2000, latch);\n        Worker third = new Worker(\"Worker3\", 3000, latch);\n        Worker fourth = new Worker(\"Worker4\", 4000, latch);\n        first.start();\n        second.start();\n        third.start();\n        fourth.start();\n\n        // The main task waits for four threads\n        latch.await();\n\n        // Main thread has started\n        System.out.println(Thread.currentThread().getName() + \" has finished\");\n    }\n}\n</code></pre> <ul> <li><code>await()</code> method blocks until count == 0.</li> </ul> <p>Output.</p> <pre><code>Worker1 finished, remaining count = 3\nWorker2 finished, remaining count = 2\nWorker3 finished, remaining count = 1\nWorker4 finished, remaining count = 0\nmain has finished\n</code></pre>"},{"location":"java-concurrency/java-concurrency-synchronizers/#semaphore","title":"Semaphore","text":"<p>Semaphore is a class in java.util.concurrent package introduced in JDK 5. Semaphore basically maintains a set of permits, so there are two methods which are mainly used for semaphore.</p> <ul> <li>acquire</li> <li>release</li> </ul> <p><code>acquire()</code> method is used to get a permit and if no. of permits reaches max allowed permits then thread has to wait to get permit which will be released by some other thread by calling <code>release()</code> method.</p> <p>Semaphores are generally used to restrict the number of threads to access resources. Real time examples:</p> <ul> <li>Semaphores can be used to restrict number of database connections at a time</li> <li>Semaphores can also be used to bound any collection.</li> </ul> <p>Create a worker thread. It accepts a Semaphore object passed from the main thread.</p> <pre><code>public class Worker extends Thread {\n    private String name;\n    private Semaphore semaphore;\n    public Worker(String name, Semaphore semaphore) {\n        super(name);\n        this.name = name;\n        this.semaphore = semaphore;\n    }\n\n    @Override\n    public void run() {\n        System.out.println(\"Starting \" + name + \"...\");\n        try {\n            System.out.println(name + \": acquiring a permit, available Semaphore permits: \"\n                    + semaphore.availablePermits());\n\n            // Acquiring the permit\n            semaphore.acquire();\n\n            System.out.println(name + \" gets a permit.\");\n\n            for (int i=0; i &lt; 3; i++) {\n                System.out.println(name + \": is performing operation \" + (i + 1)\n                        + \", available Semaphore permits: \"\n                        + semaphore.availablePermits());\n                Thread.sleep( (long) (Math.random() * 2000));\n            }\n        } catch (InterruptedException exc) {\n            System.out.println(exc);\n        }\n\n        // Release the permit\n        semaphore.release();\n        System.out.println(name + \" releases the permit, available Semaphore permits: \"\n                + semaphore.availablePermits());\n    }\n}\n</code></pre> <p>Then, create the main thread with four workers. Create an object of Semaphore with 2 permits.</p> <pre><code>public class SemaphoreExample {\n    public static void main(String args[]) throws InterruptedException\n    {\n        // Create a Semaphore object with number of permits 2\n        Semaphore semaphore = new Semaphore(2);\n\n        // Create 4 worker threads\n        Worker worker1 = new Worker(\"Work1\", semaphore);\n        Worker worker2 = new Worker(\"Work2\", semaphore);\n        Worker worker3 = new Worker(\"Work3\", semaphore);\n        Worker worker4 = new Worker(\"Work4\", semaphore);\n        worker1.start();\n        worker2.start();\n        worker3.start();\n        worker4.start();\n\n        // Wait until all workers are completed\n        worker1.join();\n        worker2.join();\n        worker3.join();\n        worker4.join();\n\n        // Check the final permits\n        System.out.println(\"All tasks are completed. Available Semaphore permits: \"\n                + semaphore.availablePermits());\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Starting Work2...\nStarting Work4...\nWork4: acquiring a permit, available Semaphore permits: 2\nStarting Work3...\nStarting Work1...\nWork3: acquiring a permit, available Semaphore permits: 1\nWork4 gets a permit.\nWork2: acquiring a permit, available Semaphore permits: 2\nWork4: is performing operation 1, available Semaphore permits: 0\nWork3 gets a permit.\nWork1: acquiring a permit, available Semaphore permits: 1\nWork3: is performing operation 1, available Semaphore permits: 0\nWork4: is performing operation 2, available Semaphore permits: 0\nWork3: is performing operation 2, available Semaphore permits: 0\nWork4: is performing operation 3, available Semaphore permits: 0\nWork3: is performing operation 3, available Semaphore permits: 0\nWork4 releases the permit, available Semaphore permits: 1\nWork2 gets a permit.\nWork2: is performing operation 1, available Semaphore permits: 0\nWork2: is performing operation 2, available Semaphore permits: 0\nWork3 releases the permit, available Semaphore permits: 1\nWork1 gets a permit.\nWork1: is performing operation 1, available Semaphore permits: 0\nWork2: is performing operation 3, available Semaphore permits: 0\nWork2 releases the permit, available Semaphore permits: 1\nWork1: is performing operation 2, available Semaphore permits: 1\nWork1: is performing operation 3, available Semaphore permits: 1\nWork1 releases the permit, available Semaphore permits: 2\nAll tasks are completed. Available Semaphore permits: 2\n</code></pre>"},{"location":"java-concurrency/java-concurrency-synchronizers/#difference-between-a-cyclicbarrier-and-a-countdownlatch","title":"Difference between a CyclicBarrier and a CountDownLatch","text":"<ul> <li>A <code>CountDownLatch</code> can be used only once in a program(until it\u2019s count reaches 0).</li> <li>A <code>CyclicBarrier</code> can be used again and again once all the threads in a barriers is released.</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronizers/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Synchronizers on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-synchronizers/#references","title":"References","text":"<ul> <li>Java Concurrency and Multithreading Tutorial</li> <li>Lifecycle and States of a Thread in Java</li> <li>Synchronized in Java</li> <li>Remember the types of intrinsic lock</li> <li>Java - Thread Deadlock</li> <li>Java ThreadLocal</li> <li>Reentrant Lock in Java</li> <li>Thread Pools in Java</li> <li>Callable and Future in Java</li> <li>Semaphore in Java</li> <li>CountDownLatch in Java</li> <li>Java.util.concurrent.CyclicBarrier Example</li> </ul>"},{"location":"java-concurrency/java-concurrency-thread-pool/","title":"Thread Pool","text":"<p>Create fixed thread pool and scheduled thread pool.</p>"},{"location":"java-concurrency/java-concurrency-thread-pool/#what-is-thread-pool","title":"What is Thread Pool?","text":"<p>Thread Pools are useful when you need to limit the number of threads running in your application at the same time. There is a performance overhead associated with starting a new thread, and each thread is also allocated some memory for its stack etc.</p> <p>Instead of starting a new thread for every task to execute concurrently, the task can be passed to a thread pool. As soon as the pool has any idle threads the task is assigned to one of them and executed. Internally the tasks are inserted into a <code>Blocking Queue</code> which the threads in the pool are dequeuing from. When a new task is inserted into the queue one of the idle threads will dequeue it successfully and execute it. The rest of the idle threads in the pool will be blocked waiting to dequeue tasks.</p>"},{"location":"java-concurrency/java-concurrency-thread-pool/#interface-and-class","title":"Interface and Class","text":"<p>Java 5 comes with built in thread pools in the <code>java.util.concurrent</code> package, so you don't have to implement your own thread pool. Below are the important interfaces and classes for using thread pool.</p> <ul> <li>Interface <code>Executor</code></li> <li>Interface <code>ExecutorService</code></li> <li>Class <code>Executors</code></li> <li>Class <code>ThreadPoolExecutor</code></li> </ul>"},{"location":"java-concurrency/java-concurrency-thread-pool/#types-of-thread-pool","title":"Types of Thread Pool","text":"<p>Class <code>Executors</code> supports to create five types of thread pool with corresponding factory methods. You can choose any of them based to your requirement.</p> Method Description newCachedThreadPool New threads are created as needed; idle threads are kept for 60 seconds. newFixedThreadPool The pool contains a fixed set of threads; idle threads are kept indefinitely. newSingleThreadExecutor A \u201cpool\u201d with a single thread that executes the submitted tasks sequentially (similar to the Swing event dispatch thread). newScheduledThreadPool A fixed-thread pool for scheduled execution; a replacement for java.util.Timer. newSingleThreadScheduledExecutor A single-thread \u201cpool\u201d for scheduled execution."},{"location":"java-concurrency/java-concurrency-thread-pool/#examples","title":"Examples","text":""},{"location":"java-concurrency/java-concurrency-thread-pool/#fixed-thread-pool","title":"Fixed Thread Pool","text":"<p>Create task thread by implementing Runnable interface. It takes random seconds to run the task.</p> <pre><code>public class FixedTask implements Runnable {\n    private String name;\n\n    public FixedTask(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void run() {\n        try {\n            Long duration = (long) (Math.random() * 10);\n            System.out.println(\"Executing: \" + name + \" at \" + LocalDateTime.now().toString());\n            TimeUnit.SECONDS.sleep(duration);\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>Create a fixed thread pool which has two numbers of thread in the pool. We can use it as either <code>ExecutorService</code> interface or <code>ThreadPoolExecutor</code> class. Then, we create 5 tasks and submit them to thread pool.</p> <pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ThreadPoolExecutor;\n\npublic class ThreadPoolExample {\n    public static void main(String[] args)\n    {\n        //ExecutorService executor = Executors.newFixedThreadPool(2);\n        ThreadPoolExecutor executor = (ThreadPoolExecutor)Executors.newFixedThreadPool(2);\n\n        for (int i = 1; i &lt;= 5; i++)\n        {\n            Task task = new Task(\"Task \" + i);\n            System.out.println(\"Created : \" + task.getName());\n\n            executor.submit(task);\n        }\n        executor.shutdown();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Created: Task 1\nCreated: Task 2\nCreated: Task 3\nCreated: Task 4\nCreated: Task 5\nExecuting: Task 2 at 2019-03-27T10:02:32.272\nExecuting: Task 1 at 2019-03-27T10:02:32.272\nExecuting: Task 3 at 2019-03-27T10:02:33.324\nExecuting: Task 4 at 2019-03-27T10:02:38.321\nExecuting: Task 5 at 2019-03-27T10:02:39.327\n</code></pre>"},{"location":"java-concurrency/java-concurrency-thread-pool/#scheduled-thread-pool","title":"Scheduled Thread Pool","text":"<p>We can create scheduled thread pool to run a task periodically.</p> <p>Create task thread by implementing Runnable interface.</p> <pre><code>public class ScheduledTask implements Runnable {\n    private String name;\n\n    public ScheduledTask(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void run() {\n        System.out.println(\"Executing: \" + name + \" at \" + LocalDateTime.now().toString());\n    }\n}\n</code></pre> <p>Create a scheduled thread pool which has only one thread in the pool. The task is scheduled to run every 3 seconds.</p> <pre><code>import java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\npublic class ScheduledThreadPoolExample {\n    public static void main(String[] args)\n    {\n        ScheduledExecutorService ses = Executors.newScheduledThreadPool(1);\n\n        ScheduledTask task = new ScheduledTask(\"Scheduled Task\");\n\n        ses.scheduleAtFixedRate(task, 0, 3, TimeUnit.SECONDS);\n\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Executing: Scheduled Task at 2019-03-28T09:23:58.476\nExecuting: Scheduled Task at 2019-03-28T09:24:01.444\nExecuting: Scheduled Task at 2019-03-28T09:24:04.445\nExecuting: Scheduled Task at 2019-03-28T09:24:07.441\nExecuting: Scheduled Task at 2019-03-28T09:24:10.442\nExecuting: Scheduled Task at 2019-03-28T09:24:13.445\nExecuting: Scheduled Task at 2019-03-28T09:24:16.444\n...\n</code></pre>"},{"location":"java-concurrency/java-concurrency-thread-pool/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java ThreadPool on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-thread-pool/#references","title":"References","text":"<ul> <li>Java Thread Pool \u2013 ThreadPoolExecutor Example</li> <li>Thread Pools</li> <li>Example of newSingleThreadExecutor in Java</li> </ul>"},{"location":"java-concurrency/java-concurrency-thread-signaling/","title":"Thread Signaling","text":"<p>The purpose of thread signaling is to enable threads to send signals to each other. Additionally, thread signaling enables threads to wait for signals from other threads. For instance, a thread B might wait for a signal from thread A indicating that data is ready to be processed.</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#signaling-via-shared-objects","title":"Signaling via Shared Objects","text":"<p>A simple way for threads to send signals to each other is by setting the signal values in some shared object variable. Thread A may set the boolean member variable hasDataToProcess to true from inside a synchronized block, and thread B may read the hasDataToProcess member variable, also inside a synchronized block. Here is a simple example of an object that can hold such a signal, and provide methods to set and check it:</p> <pre><code>public class MySignal{\n\n  protected boolean hasDataToProcess = false;\n\n  public synchronized boolean hasDataToProcess(){\n    return this.hasDataToProcess;\n  }\n\n  public synchronized void setHasDataToProcess(boolean hasData){\n    this.hasDataToProcess = hasData;  \n  }\n\n}\n</code></pre> <p>Thread A and B must have a reference to a shared MySignal instance for the signaling to work. If thread A and B has references to different MySignal instance, they will not detect each others signals. The data to be processed can be located in a shared buffer separate from the MySignal instance.</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#busy-wait","title":"Busy Wait","text":"<p>Thread B which is to process the data is waiting for data to become available for processing. In other words, it is waiting for a signal from thread A which causes hasDataToProcess() to return true. Here is the loop that thread B is running in, while waiting for this signal:</p> <pre><code>protected MySignal sharedSignal = ...\n\n...\n\nwhile(!sharedSignal.hasDataToProcess()){\n  //do nothing... busy waiting\n}\n</code></pre> <p>Notice how the while loop keeps executing until hasDataToProcess() returns true. This is called busy waiting. The thread is busy while waiting.</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#wait-notify-and-notifyall","title":"wait(), notify() and notifyAll()","text":"<p>Busy waiting is not a very efficient utilization of the CPU in the computer running the waiting thread, except if the average waiting time is very small. Else, it would be smarter if the waiting thread could somehow sleep or become inactive until it receives the signal it is waiting for.</p> <p>Java has a builtin wait mechanism that enable threads to become inactive while waiting for signals. The class java.lang.Object defines three methods, wait(), notify(), and notifyAll(), to facilitate this.</p> <p>A thread that calls wait() on any object becomes inactive until another thread calls notify() on that object. In order to call either wait() or notify the calling thread must first obtain the lock on that object. In other words, the calling thread must call wait() or notify() from inside a synchronized block. Here is a modified version of MySignal called MyWaitNotify that uses wait() and notify().</p> <pre><code>public class MonitorObject{\n}\n\npublic class MyWaitNotify{\n\n  MonitorObject myMonitorObject = new MonitorObject();\n\n  public void doWait(){\n    synchronized(myMonitorObject){\n      try{\n        myMonitorObject.wait();\n      } catch(InterruptedException e){...}\n    }\n  }\n\n  public void doNotify(){\n    synchronized(myMonitorObject){\n      myMonitorObject.notify();\n    }\n  }\n}\n</code></pre> <p>The waiting thread would call doWait(), and the notifying thread would call doNotify(). When a thread calls notify() on an object, one of the threads waiting on that object are awakened and allowed to execute. There is also a notifyAll() method that will wake all threads waiting on a given object.</p> <p>As you can see both the waiting and notifying thread calls wait() and notify() from within a synchronized block. This is mandatory! A thread cannot call wait(), notify() or notifyAll() without holding the lock on the object the method is called on. If it does, an IllegalMonitorStateException is thrown.</p> <p>But, how is this possible? Wouldn't the waiting thread keep the lock on the monitor object (myMonitorObject) as long as it is executing inside a synchronized block? Will the waiting thread not block the notifying thread from ever entering the synchronized block in doNotify()? The answer is no. Once a thread calls wait() it releases the lock it holds on the monitor object. This allows other threads to call wait() or notify() too, since these methods must be called from inside a synchronized block.</p> <p>Once a thread is awakened it cannot exit the wait() call until the thread calling notify() has left its synchronized block. In other words: The awakened thread must reobtain the lock on the monitor object before it can exit the wait() call, because the wait call is nested inside a synchronized block. If multiple threads are awakened using notifyAll() only one awakened thread at a time can exit the wait() method, since each thread must obtain the lock on the monitor object in turn before exiting wait().</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#missed-signals","title":"Missed Signals","text":"<p>The methods notify() and notifyAll() do not save the method calls to them in case no threads are waiting when they are called. The notify signal is then just lost. Therefore, if a thread calls notify() before the thread to signal has called wait(), the signal will be missed by the waiting thread. This may or may not be a problem, but in some cases this may result in the waiting thread waiting forever, never waking up, because the signal to wake up was missed.</p> <p>To avoid losing signals they should be stored inside the signal class. In the MyWaitNotify example the notify signal should be stored in a member variable inside the MyWaitNotify instance. Here is a modified version of MyWaitNotify that does this:</p> <pre><code>public class MyWaitNotify2{\n\n  MonitorObject myMonitorObject = new MonitorObject();\n  boolean wasSignalled = false;\n\n  public void doWait(){\n    synchronized(myMonitorObject){\n      if(!wasSignalled){\n        try{\n          myMonitorObject.wait();\n         } catch(InterruptedException e){...}\n      }\n      //clear signal and continue running.\n      wasSignalled = false;\n    }\n  }\n\n  public void doNotify(){\n    synchronized(myMonitorObject){\n      wasSignalled = true;\n      myMonitorObject.notify();\n    }\n  }\n}\n</code></pre> <p>Notice how the doNotify() method now sets the wasSignalled variable to true before calling notify(). Also, notice how the doWait() method now checks the wasSignalled variable before calling wait(). In fact it only calls wait() if no signal was received in between the previous doWait() call and this.</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#spurious-wakeups","title":"Spurious Wakeups","text":"<p>For inexplicable reasons it is possible for threads to wake up even if notify() and notifyAll() has not been called. This is known as spurious wakeups. Wakeups without any reason.</p> <p>If a spurious wakeup occurs in the MyWaitNofity2 class's doWait() method the waiting thread may continue processing without having received a proper signal to do so! This could cause serious problems in your application.</p> <p>To guard against spurious wakeups the signal member variable is checked inside a while loop instead of inside an if-statement. Such a while loop is also called a spin lock. The thread awakened spins around until the condition in the spin lock (while loop) becomes false. Here is a modified version of MyWaitNotify2 that shows this:</p> <pre><code>public class MyWaitNotify3{\n\n  MonitorObject myMonitorObject = new MonitorObject();\n  boolean wasSignalled = false;\n\n  public void doWait(){\n    synchronized(myMonitorObject){\n      while(!wasSignalled){\n        try{\n          myMonitorObject.wait();\n         } catch(InterruptedException e){...}\n      }\n      //clear signal and continue running.\n      wasSignalled = false;\n    }\n  }\n\n  public void doNotify(){\n    synchronized(myMonitorObject){\n      wasSignalled = true;\n      myMonitorObject.notify();\n    }\n  }\n}\n</code></pre> <p>Notice how the wait() call is now nested inside a while loop instead of an if-statement. If the waiting thread wakes up without having received a signal, the wasSignalled member will still be false, and the while loop will execute once more, causing the awakened thread to go back to waiting.</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#multiple-threads-waiting-for-the-same-signals","title":"Multiple Threads Waiting for the Same Signals","text":"<p>The while loop is also a nice solution if you have multiple threads waiting, which are all awakened using notifyAll(), but only one of them should be allowed to continue. Only one thread at a time will be able to obtain the lock on the monitor object, meaning only one thread can exit the wait() call and clear the wasSignalled flag. Once this thread then exits the synchronized block in the doWait() method, the other threads can exit the wait() call and check the wasSignalled member variable inside the while loop. However, this flag was cleared by the first thread waking up, so the rest of the awakened threads go back to waiting, until the next signal arrives.</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#dont-call-wait-on-constant-strings-or-global-objects","title":"Don't call wait() on constant String's or global objects","text":"<p>An earlier version of this text had an edition of the MyWaitNotify example class which used a constant string ( \"\" ) as monitor object. Here is how that example looked:</p> <pre><code>public class MyWaitNotify{\n\n  String myMonitorObject = \"\";\n  boolean wasSignalled = false;\n\n  public void doWait(){\n    synchronized(myMonitorObject){\n      while(!wasSignalled){\n        try{\n          myMonitorObject.wait();\n         } catch(InterruptedException e){...}\n      }\n      //clear signal and continue running.\n      wasSignalled = false;\n    }\n  }\n\n  public void doNotify(){\n    synchronized(myMonitorObject){\n      wasSignalled = true;\n      myMonitorObject.notify();\n    }\n  }\n}\n</code></pre> <p>The problem with calling wait() and notify() on the empty string, or any other constant string is, that the JVM/Compiler internally translates constant strings into the same object. That means, that even if you have two different MyWaitNotify instances, they both reference the same empty string instance. This also means that threads calling doWait() on the first MyWaitNotify instance risk being awakened by doNotify() calls on the second MyWaitNotify instance.</p> <p>The situation is sketched in the diagram below:</p> <p></p> <p>Remember, that even if the 4 threads call wait() and notify() on the same shared string instance, the signals from the doWait() and doNotify() calls are stored individually in the two MyWaitNotify instances. A doNotify() call on the MyWaitNotify 1 may wake threads waiting in MyWaitNotify 2, but the signal will only be stored in MyWaitNotify 1.</p> <p>At first this may not seem like a big problem. After all, if doNotify() is called on the second MyWaitNotify instance all that can really happen is that Thread A and B are awakened by mistake. This awakened thread (A or B) will check its signal in the while loop, and go back to waiting because doNotify() was not called on the first MyWaitNotify instance, in which they are waiting. This situation is equal to a provoked spurious wakeup. Thread A or B awakens without having been signaled. But the code can handle this, so the threads go back to waiting.</p> <p>The problem is, that since the doNotify() call only calls notify() and not notifyAll(), only one thread is awakened even if 4 threads are waiting on the same string instance (the empty string). So, if one of the threads A or B is awakened when really the signal was for C or D, the awakened thread (A or B) will check its signal, see that no signal was received, and go back to waiting. Neither C or D wakes up to check the signal they had actually received, so the signal is missed. This situation is equal to the missed signals problem described earlier. C and D were sent a signal but fail to respond to it.</p> <p>If the doNotify() method had called notifyAll() instead of notify(), all waiting threads had been awakened and checked for signals in turn. Thread A and B would have gone back to waiting, but one of either C or D would have noticed the signal and left the doWait() method call. The other of C and D would go back to waiting, because the thread discovering the signal clears it on the way out of doWait().</p> <p>You may be tempted then to always call notifyAll() instead notify(), but this is a bad idea performance wise. There is no reason to wake up all threads waiting when only one of them can respond to the signal.</p> <p>So: Don't use global objects, string constants etc. for wait() / notify() mechanisms. Use an object that is unique to the construct using it. For instance, each MyWaitNotify3 (example from earlier sections) instance has its own MonitorObject instance rather than using the empty string for wait() / notify() calls.</p>"},{"location":"java-concurrency/java-concurrency-thread-signaling/#references","title":"References","text":"<ul> <li>Thread Signaling</li> </ul>"},{"location":"java-concurrency/java-concurrency-threadlocal/","title":"ThreadLocal","text":"<p>The <code>ThreadLocal</code> class in Java enables you to create variables that can only be read and written by the same thread. Thus, even if two threads are executing the same code, and the code has a reference to a ThreadLocal variable, then the two threads cannot see each other's ThreadLocal variables.</p>"},{"location":"java-concurrency/java-concurrency-threadlocal/#creating-a-threadlocal","title":"Creating a ThreadLocal","text":"<p>Here is a code example that shows how to create a ThreadLocal variable:</p> <pre><code>private ThreadLocal myThreadLocal = new ThreadLocal();\n</code></pre> <p>As you can see, you instantiate a new ThreadLocal object. This only needs to be done once per thread. Even if different threads execute the same code which accesses a ThreadLococal, each thread will see only its own ThreadLocal instance. Even if two different threads set different values on the same ThreadLocal object, they cannot see each other's values.</p>"},{"location":"java-concurrency/java-concurrency-threadlocal/#accessing-a-threadlocal","title":"Accessing a ThreadLocal","text":"<p>Once a ThreadLocal has been created you can set the value to be stored in it like this:</p> <pre><code>myThreadLocal.set(\"A thread local value\");\n</code></pre> <p>You read the value stored in a ThreadLocal like this:</p> <pre><code>String threadLocalValue = (String) myThreadLocal.get();\n</code></pre> <p>The get() method returns an Object and the set() method takes an Object as parameter.</p>"},{"location":"java-concurrency/java-concurrency-threadlocal/#generic-threadlocal","title":"Generic ThreadLocal","text":"<p>You can create a generic ThreadLocal so that you do not have to typecast the value returned by get(). Here is a generic ThreadLocal example:</p> <pre><code>private ThreadLocal&lt;String&gt; myThreadLocal = new ThreadLocal&lt;String&gt;();\n</code></pre> <p>Now you can only store strings in the ThreadLocal instance. Additionally, you do not need to typecast the value obtained from the ThreadLocal:</p> <pre><code>myThreadLocal.set(\"Hello ThreadLocal\");\n\nString threadLocalValue = myThreadLocal.get();\n</code></pre>"},{"location":"java-concurrency/java-concurrency-threadlocal/#initial-threadlocal-value","title":"Initial ThreadLocal Value","text":"<p>Since values set on a ThreadLocal object only are visible to the thread who set the value, no thread can set an initial value on a ThreadLocal using set() which is visible to all threads.</p> <p>Instead you can specify an initial value for a ThreadLocal object by subclassing ThreadLocal and overriding the initialValue() method. Here is how that looks:</p> <pre><code>private ThreadLocal myThreadLocal = new ThreadLocal&lt;String&gt;() {\n    @Override protected String initialValue() {\n        return \"This is the initial value\";\n    }\n};\n</code></pre> <p>Now all threads will see the same initial value when calling get() before having called set() .</p>"},{"location":"java-concurrency/java-concurrency-threadlocal/#full-threadlocal-example","title":"Full ThreadLocal Example","text":""},{"location":"java-concurrency/java-concurrency-threadlocal/#problematic-variable-issue-in-multi-threading","title":"Problematic Variable Issue in Multi-threading","text":"<p>First, create class named NumberGenerator, which is used to return a random number when <code>random()</code> gets called.</p> <pre><code>import java.util.Random;\n\npublic class NumberGenerator {\n    private Random random;\n\n    public NumberGenerator() {\n        random = new Random();\n    }\n\n    public int random(int i){\n        return random.nextInt(i);\n    }\n}\n</code></pre> <p>Create a task to generate random number and print it. Then create a single Task instance which is passed to two different threads. Both threads execute the run() method.</p> <pre><code>public class IntegerExample {\n    public static void main(String[] args) {\n        NumberGenerator generator = new NumberGenerator();\n        Task task = new Task(generator);\n\n        Thread thread1 = new Thread(task);\n        Thread thread2 = new Thread(task);\n\n        thread1.start();\n        thread2.start();\n    }\n\n    public static class Task implements Runnable {\n        private Integer number = new Integer(0);\n        private NumberGenerator generator;\n\n        public Task(NumberGenerator generator) {\n            this.generator = generator;\n        }\n\n        @Override\n        public void run() {\n            number = generator.random(100);\n            System.out.println(number);\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n            }\n\n            System.out.println(number);\n        }\n    }\n}\n</code></pre> <p>Output. Notice, when the second time the number is printed for thread one, the value is incorrect. The variable <code>number</code> is messed.</p> <pre><code>52 # thread 1\n91 # thread 2\n91 # thread 1\n91 # thread 2\n</code></pre>"},{"location":"java-concurrency/java-concurrency-threadlocal/#solution-with-threadlocal","title":"Solution with ThreadLocal","text":"<p>The below implementation is almost same with the previous one, the only difference is that we use <code>ThreadLocal</code> to store the random number.</p> <pre><code>public class ThreadLocalExample {\n    public static void main(String[] args) {\n        NumberGenerator generator = new NumberGenerator();\n        Task task = new Task(generator);\n\n        Thread thread1 = new Thread(task);\n        Thread thread2 = new Thread(task);\n\n        thread1.start();\n        thread2.start();\n    }\n\n    public static class Task implements Runnable {\n        private ThreadLocal&lt;Integer&gt; threadLocal = new ThreadLocal&lt;&gt;();\n        private NumberGenerator generator;\n\n        public Task(NumberGenerator generator) {\n            this.generator = generator;\n        }\n\n        @Override\n        public void run() {\n            threadLocal.set(generator.random(100));\n            System.out.println(Thread.currentThread() + \":\"+ threadLocal.get());\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n            }\n\n            System.out.println(Thread.currentThread() + \":\"+ threadLocal.get());\n        }\n    }\n}\n</code></pre> <p>Output. Notice, each thread has its own random number.</p> <pre><code>Thread[Thread-1,5,main]:96\nThread[Thread-0,5,main]:68\nThread[Thread-1,5,main]:96\nThread[Thread-0,5,main]:68\n</code></pre>"},{"location":"java-concurrency/java-concurrency-threadlocal/#custom-threadlocal","title":"Custom ThreadLocal","text":"<p>Internally, ThreadLocal is implement with a <code>WeakMap</code>, which has the pairs of thread ID and variable. The below example demonstrates how it works.</p> <pre><code>public class CustomThreadLocalExample {\n    public static void main(String[] args) {\n        Map&lt;String, Integer&gt; map = new WeakHashMap&lt;&gt;();\n        NumberGenerator generator = new NumberGenerator();\n        Task task = new Task(map, generator);\n\n        Thread thread1 = new Thread(task);\n        Thread thread2 = new Thread(task);\n\n        thread1.start();\n        thread2.start();\n    }\n\n    public static class Task implements Runnable {\n        Map&lt;String, Integer&gt; map;\n        private NumberGenerator generator;\n\n        public Task(Map&lt;String, Integer&gt; map, NumberGenerator generator) {\n            this.map = map;\n            this.generator = generator;\n        }\n\n        @Override\n        public void run() {\n            String threadId = Thread.currentThread().toString();\n            map.put(threadId, generator.random(100));\n            System.out.println(threadId + \":\"+ map.get(threadId));\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n            }\n\n            System.out.println(threadId + \":\"+ map.get(threadId));\n        }\n    }\n}\n</code></pre> <p>Output. Notice, each thread also has its own random number.</p> <pre><code>Thread[Thread-0,5,main]:87\nThread[Thread-1,5,main]:28\nThread[Thread-1,5,main]:28\nThread[Thread-0,5,main]:87\n</code></pre>"},{"location":"java-concurrency/java-concurrency-threadlocal/#inheritablethreadlocal","title":"InheritableThreadLocal","text":"<p>The <code>InheritableThreadLocal</code> class extends ThreadLocal to provide inheritance of values from parent thread to child thread: when a child thread is created, the child receives initial values for all inheritable thread-local variables for which the parent has values.</p>"},{"location":"java-concurrency/java-concurrency-threadlocal/#example-with-threadlocal-only","title":"Example with ThreadLocal Only","text":"<p>First, create a ParentThread, which has an instance of ThreadLocal and starts a child thread.</p> <pre><code>public class ParentThread extends Thread {\n    public static ThreadLocal&lt;String&gt; tl_p = new ThreadLocal();\n    public void run() {\n        // setting the new value\n        tl_p.set(\"parent data\");\n\n        // returns the ThreadLocal value associated with current thread\n        System.out.println(\"Parent Thread Value: \" + tl_p.get());\n\n        ChildThread thread_c = new ChildThread();\n        thread_c.start();\n    }\n}\n</code></pre> <p>Second, create a ChildThread, which tries to get value from parent's thread local variable.</p> <pre><code>public class ChildThread extends Thread {\n    public void run(){\n        // returns the ThreadLocal value associated with current thread\n        System.out.println(\"Child Thread Value: \" + ParentThread.tl_p.get());\n        /* null (thread local in parent thread is not available to child thread ) */\n    }\n}\n</code></pre> <p>Finally, create a main class the test this.</p> <pre><code>public class InheritanceExample {\n    public static void main(String[] args) {\n        ParentThread thread_p = new ParentThread();\n        thread_p.start();\n    }\n}\n</code></pre> <p>Output. The child thread is not able to get the thread local from its parent.</p> <pre><code>Parent Thread Value: parent data\nChild Thread Value: null\n</code></pre>"},{"location":"java-concurrency/java-concurrency-threadlocal/#example-with-inheritablethreadlocal","title":"Example with InheritableThreadLocal","text":"<p>This time, we create parent thread with InheritableThreadLocal and override the <code>childValue()</code> method.</p> <pre><code>public class ParentThread extends Thread {\n    public static InheritableThreadLocal itl_p = new InheritableThreadLocal() {\n        @Override\n        public Object childValue(Object parentValue) {\n            return \"child data\";\n        }\n    };\n\n    public void run() {\n        // setting the new value\n        itl_p.set(\"parent data\");\n\n        // returns the ThreadLocal value associated with current thread\n        System.out.println(\"Parent Thread Value: \" + itl_p.get());\n\n        ChildThread thread_c = new ChildThread();\n        thread_c.start();\n    }\n}\n</code></pre> <p>Same change with the child thread, just read value from its parent.</p> <pre><code>public class ChildThread extends Thread {\n    public void run(){\n        // child data\n        System.out.println(\"Child Thread Value: \" + ParentThread.itl_p.get());\n    }\n}\n</code></pre> <p>No change in the main class.</p> <pre><code>public class InheritanceExample {\n    public static void main(String[] args) {\n        ParentThread thread_p = new ParentThread();\n        thread_p.start();\n    }\n}\n</code></pre> <p>Output. This time, the child thread is able to get data from parent.</p> <pre><code>Parent Thread Value: parent data\nChild Thread Value: child data\n</code></pre> <p>If we don't override the <code>childValue()</code> method, we will get the following output.</p> <pre><code>Parent Thread Value: parent data\nChild Thread Value: parent data\n</code></pre>"},{"location":"java-concurrency/java-concurrency-threadlocal/#threadlocalrandom","title":"ThreadLocalRandom","text":""},{"location":"java-concurrency/java-concurrency-threadlocal/#why-we-need-threadlocalrandom","title":"Why We Need ThreadLocalRandom?","text":"<p><code>java.util.concurrent.ThreadLocalRandom</code> has been introduced in JDK 7. Like java.util.Random, ThreadLocalRandom is also a random number generator. But ThreadLocalRandom is used in concurrent environment and isolated to current thread. ThreadLocalRandom provide more good performance and less overhead in in concurrent programs than the shared Random object. So, the usage of ThreadLocalRandom is particularly appropriate when multiple tasks (for example, each a ForkJoinTask) use random numbers in parallel in thread pools.</p> <p>ThreadLocalRandom does not support the explicit setting of seed for more true randomness. Also, If we try to override <code>setSeed(long)</code> method, an UnsupportedOperationException will be thrown because the ThreadLocalRandom prohibits explicit setting of its seed by overriding Random\u2019s setSeed(long) method and automatically throwing an UnsupportedOperationException if called.</p>"},{"location":"java-concurrency/java-concurrency-threadlocal/#example","title":"Example","text":"<p>In the example there is a <code>ForkJoinTask</code> implementation and inside <code>exec()</code> method of ForkJoinTask, we obtained the random number by ThreadLocalRandom. We have run two ForkJoinTask to test the random number generation.</p> <pre><code>import java.util.concurrent.ForkJoinPool;\nimport java.util.concurrent.ForkJoinTask;\nimport java.util.concurrent.ThreadLocalRandom;\n\npublic class ThreadLocalRandomExample {\n    public static void main(String[] args) {\n        ForkJoinPool pool = new ForkJoinPool();\n        Task task1 = new Task(\"Task one\");\n        Task task2 = new Task(\"Task two\");\n        pool.invoke(task1);\n        pool.invoke(task2);\n    }\n\n    public static class Task extends ForkJoinTask&lt;String&gt; {\n        private String taskName;\n\n        public Task(String name){\n            this.taskName = name;\n        }\n\n        @Override\n        protected boolean exec() {\n            int i = ThreadLocalRandom.current().nextInt(1, 10);\n            System.out.println(\"ThreadLocalRandom for \" + taskName + \": \" + i);\n            return true;\n        }\n\n        @Override\n        public String getRawResult() {\n            return null;\n        }\n\n        @Override\n        protected void setRawResult(String value) {\n        }\n    }\n}\n</code></pre> <p>Run the example many time and every time you will get random numbers. Sample output is as below.</p> <pre><code>ThreadLocalRandom for Task one: 6\nThreadLocalRandom for Task two: 9\n</code></pre>"},{"location":"java-concurrency/java-concurrency-threadlocal/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java ThreadLocal on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-threadlocal/#references","title":"References","text":"<ul> <li>Java ThreadLocal</li> <li>How is Java's ThreadLocal implemented under the hood?</li> <li>Java.lang.InheritableThreadLocal Class with Examples</li> <li>ThreadLocalRandom Java Example</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/","title":"Volatile, Final and Atomics","text":""},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#volatile-fields","title":"Volatile Fields","text":"<pre><code>private volatile boolean done;\npublic boolean isDone() { return done; }\npublic void setDone() { done = true; }\n</code></pre> <ul> <li>The compiler will insert the appropriate code to ensure that a change to the done variable in one thread is visible from any other thread that reads the variable.</li> </ul> <p>CAUTION: Volatile variables <code>do not</code> provide any atomicity. For example, the method is not guaranteed to flip the value of the field. There is no guarantee that the reading, flipping, and writing is uninterrupted.</p> <pre><code>public void flipDone() { done = !done; } // not atomic\n</code></pre> <p>When is volatile Enough?</p> <ul> <li>If two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough. You need to use a synchronized in that case to guarantee that the reading and writing of the variable is atomic.</li> <li>In case only one thread reads and writes the value of a volatile variable and other threads only read the variable, then the reading threads are guaranteed to see the latest value written to the volatile variable.</li> <li>As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package. For instance, the <code>AtomicLong</code> or <code>AtomicReference</code> or one of the others.</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#final-variables","title":"Final Variables","text":"<pre><code>final Map&lt;String, Double&gt; accounts = new HashMap&lt;&gt;();\n</code></pre> <ul> <li>With final, other threads get to see the accounts variable after the constructor has finished.</li> <li>Without using final, there would be no guarantee that other threads would see the updated value of accounts\u2014they might all see null, not the constructed HashMap.</li> <li>Of course, the operations on the map are not thread safe. If multiple threads mutate and read the map, you still need synchronization.</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#atomics","title":"Atomics","text":"<p>There are a number of classes in the java.util.concurrent.atomic package that use efficient machine-level instructions to guarantee atomicity of other operations without using locks.</p> <ul> <li>AtomicInteger</li> <li>AtomicLong</li> <li>LongAdder</li> <li>LongAccumulator</li> <li>DoubleAdder</li> <li>DoubleAccumulator</li> </ul> <pre><code>public static AtomicLong nextNumber = new AtomicLong(); // In some thread...\nlong id = nextNumber.incrementAndGet();\n</code></pre> <ul> <li>The 'incrementAndGet' method atomically increments the AtomicLong and returns the post- increment value. That is, the operations of getting the value, adding 1, setting it, and producing the new value cannot be interrupted. It is guaranteed that the correct value is computed and returned, even if multiple threads access the same instance concurrently.</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#threadlocal","title":"ThreadLocal","text":"<p>The <code>ThreadLocal</code> class in Java enables you to create variables that can only be read and written by the same thread. Thus, even if two threads are executing the same code, and the code has a reference to a ThreadLocal variable, then the two threads cannot see each other's ThreadLocal variables.</p> <pre><code>public class ThreadLocalExample {\n    public static class MyRunnable implements Runnable {\n\n        private ThreadLocal&lt;Integer&gt; threadLocal =\n               new ThreadLocal&lt;Integer&gt;();\n\n        @Override\n        public void run() {\n            threadLocal.set( (int) (Math.random() * 100D) );\n\n            try {\n                Thread.sleep(2000);\n            } catch (InterruptedException e) {\n            }\n\n            System.out.println(threadLocal.get());\n        }\n    }\n\n    public static void main(String[] args) {\n        MyRunnable sharedRunnableInstance = new MyRunnable();\n\n        Thread thread1 = new Thread(sharedRunnableInstance);\n        Thread thread2 = new Thread(sharedRunnableInstance);\n\n        thread1.start();\n        thread2.start();\n\n        try\n        {\n            thread1.join(); //wait for thread 1 to terminate\n            thread2.join(); //wait for thread 2 to terminate\n        }\n        catch (InterruptedException e)\n        {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>The two output numbers will probably be different.</p> <pre><code>68\n72\n</code></pre> <p>If we define the local variable in MyRunnable class as follows, we always get two identical numbers.</p> <pre><code>public static class MyRunnable implements Runnable {\n    private Integer num = 0;\n\n    @Override\n    public void run() {\n        Random random = new Random();\n        num = random.nextInt(100);\n\n        try {\n            Thread.sleep(2000);\n        } catch (InterruptedException e) {\n        }\n\n        System.out.println(num);\n    }\n}\n</code></pre>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#blocking-queues","title":"Blocking Queues","text":"<ul> <li>LinkedBlockingQueue</li> <li>ArrayBlockingQueue</li> <li>DelayQueue</li> <li>PriorityBlockingQueue</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#thread-safe-collections","title":"Thread-Safe Collections","text":"<ul> <li>ConcurrentHashMap</li> <li>ConcurrentLinkedQueue</li> <li>ConcurrentSkipListMap</li> <li>ConcurrentSkipListSet</li> </ul> <p>There is no ConcurrentHashSet class. Instead, you can create concurrent set with map.</p> <pre><code>// Prior to Java 8\nSet&lt;String&gt; mySet = Collections.newSetFromMap(new ConcurrentHashMap&lt;String, Boolean&gt;());\n// In Java 8\nSet&lt;String&gt; myConcurrentSet = ConcurrentHashMap.&lt;String&gt;newKeySet();\n</code></pre>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Synchronization on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile-final-atomics/#references","title":"References","text":"<ul> <li>Synchronization in Java</li> <li>Race Conditions and Critical Sections</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile/","title":"Volatile","text":"<p>Use volatile keyword to guarantee threads read variable value directly from main memory.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#volatile-keyword","title":"Volatile keyword","text":"<p>The Java <code>volatile</code> keyword is used to mark a Java variable as being stored in main memory. More precisely that means, that every read of a volatile variable will be read from the computer's main memory, and not from the CPU cache, and that every write to a volatile variable will be written to main memory, and not just to the CPU cache.</p> <p>Actually, since Java 5 the volatile keyword guarantees more than just that volatile variables are written to and read from main memory.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#variable-visibility-problems","title":"Variable Visibility Problems","text":"<p>The Java volatile keyword guarantees visibility of changes to variables across threads. In a multithreaded application where the threads operate on non-volatile variables, each thread may copy variables from main memory into a CPU cache while working on them, for performance reasons. If the computer contains more than one CPU, each thread may run on a different CPU. That means, each thread may copy the variables into the CPU cache of different CPUs. This is illustrated here:  Threads may hold copies of variables from main memory in CPU caches. With non-volatile variables there are no guarantees about when the Java Virtual Machine (JVM) reads data from main memory into CPU caches, or writes data from CPU caches to main memory. This can cause several problems.</p> <p>Imagine a situation in which two or more threads have access to a shared object which contains a counter variable declared like this:</p> <pre><code>public class SharedObject {\n    public int counter = 0;\n}\n</code></pre> <p>Imagine too, that only Thread 1 increments the counter variable, but both Thread 1 and Thread 2 may read the counter variable from time to time.</p> <p>If the counter variable is not declared volatile there is no guarantee about when the value of the counter variable is written from the CPU cache back to main memory. This means, that the counter variable value in the CPU cache may not be the same as in main memory. This situation is illustrated here:  The CPU cache used by Thread 1 and main memory contains different values for the counter variable. The problem with threads not seeing the latest value of a variable because it has not yet been written back to main memory by another thread, is called a <code>visibility problem</code>. The updates of one thread are not visible to other threads.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#the-java-volatile-visibility-guarantee","title":"The Java volatile Visibility Guarantee","text":"<p>The Java volatile keyword is intended to address variable visibility problems. By declaring the counter variable volatile all writes to the counter variable will be written back to main memory immediately. Also, all reads of the counter variable will be read directly from main memory.</p> <p>Here is how the volatile declaration of the counter variable looks:</p> <pre><code>public class SharedObject {\n    public volatile int counter = 0;\n}\n</code></pre> <p>Declaring a variable volatile thus guarantees the visibility for other threads of writes to that variable.</p> <p>In the scenario given above, where one thread (T1) modifies the counter, and another thread (T2) reads the counter (but never modifies it), declaring the counter variable volatile is enough to guarantee visibility for T2 of writes to the counter variable.</p> <p>If, however, both T1 and T2 were incrementing the counter variable, then declaring the counter variable volatile would not have been enough. More on that later.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#full-volatile-visibility-guarantee","title":"Full volatile Visibility Guarantee","text":"<p>Actually, the visibility guarantee of Java volatile goes beyond the volatile variable itself. The visibility guarantee is as follows:</p> <p>If Thread A writes to a volatile variable and Thread B subsequently reads the same volatile variable, then all variables visible to Thread A before writing the volatile variable, will also be visible to Thread B after it has read the volatile variable. If Thread A reads a volatile variable, then all all variables visible to Thread A when reading the volatile variable will also be re-read from main memory.</p> <p>Use the following code example to illustrate that.</p> <pre><code>public class MyClass {\n    private int years;\n    private int months\n    private volatile int days;\n\n\n    public void update(int years, int months, int days){\n        this.years  = years;\n        this.months = months;\n        this.days   = days;\n    }\n}\n</code></pre> <p>The udpate() method writes three variables, of which only days is volatile.</p> <p>The full volatile visibility guarantee means, that when a value is written to days, then all variables visible to the thread are also written to main memory. That means, that when a value is written to days, the values of years and months are also written to main memory.</p> <p>When reading the values of years, months and days you could do it like this:</p> <pre><code>public class MyClass {\n    private int years;\n    private int months\n    private volatile int days;\n\n    public int totalDays() {\n        int total = this.days;\n        total += months * 30;\n        total += years * 365;\n        return total;\n    }\n\n    public void update(int years, int months, int days){\n        this.years  = years;\n        this.months = months;\n        this.days   = days;\n    }\n}\n</code></pre> <p>Notice the totalDays() method starts by reading the value of days into the total variable. When reading the value of days, the values of months and years are also read into main memory. Therefore you are guaranteed to see the latest values of days, months and years with the above read sequence.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#instruction-reordering-challenges","title":"Instruction Reordering Challenges","text":"<p>The Java VM and the CPU are allowed to reorder instructions in the program for performance reasons, as long as the semantic meaning of the instructions remain the same. For instance, look at the following instructions:</p> <pre><code>int a = 1;\nint b = 2;\n\na++;\nb++;\n</code></pre> <p>These instructions could be reordered to the following sequence without losing the semantic meaning of the program:</p> <pre><code>int a = 1;\na++;\n\nint b = 2;\nb++;\n</code></pre> <p>However, instruction reordering present a challenge when one of the variables is a volatile variable. Let us look at the MyClass class from the example earlier.</p> <pre><code>public class MyClass {\n    private int years;\n    private int months\n    private volatile int days;\n\n    public void update(int years, int months, int days){\n        this.years  = years;\n        this.months = months;\n        this.days   = days;\n    }\n}\n</code></pre> <p>Once the update() method writes a value to days, the newly written values to years and months are also written to main memory. But, what if the Java VM reordered the instructions, like this:</p> <pre><code>public void update(int years, int months, int days){\n    this.days   = days;\n    this.months = months;\n    this.years  = years;\n}\n</code></pre> <p>The values of months and years are still written to main memory when the days variable is modified, but this time it happens before the new values have been written to months and years. The new values are thus not properly made visible to other threads. The semantic meaning of the reordered instructions has changed.</p> <p>Java has a solution for this problem, as we will see in the next section.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#the-java-volatile-happens-before-guarantee","title":"The Java volatile Happens-Before Guarantee","text":"<p>To address the instruction reordering challenge, the Java volatile keyword gives a \"happens-before\" guarantee, in addition to the visibility guarantee. The happens-before guarantee guarantees that:</p> <ul> <li>Reads from and writes to other variables cannot be reordered to occur after a write to a volatile variable, if the reads / writes originally occurred before the write to the volatile variable. The reads / writes before a write to a volatile variable are guaranteed to \"happen before\" the write to the volatile variable. Notice that it is still possible for e.g. reads / writes of other variables located after a write to a volatile to be reordered to occur before that write to the volatile. Just not the other way around. From after to before is allowed, but from before to after is not allowed.</li> <li>Reads from and writes to other variables cannot be reordered to occur before a read of a volatile variable, if the reads / writes originally occurred after the read of the volatile variable. Notice that it is possible for reads of other variables that occur before the read of a volatile variable can be reordered to occur after the read of the volatile. Just not the other way around. From before to after is allowed, but from after to before is not allowed. The above happens-before guarantee assures that the visibility guarantee of the volatile keyword are being enforced.</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile/#volatile-is-not-always-enough","title":"volatile is Not Always Enough","text":"<p>Even if the volatile keyword guarantees that all reads of a volatile variable are read directly from <code>main memory</code>, and all writes to a volatile variable are written directly to main memory, there are still situations where it is not enough to declare a variable volatile.</p> <p>In the situation explained earlier where only Thread 1 writes to the shared counter variable, declaring the counter variable volatile is enough to make sure that Thread 2 always sees the latest written value.</p> <p>In fact, multiple threads could even be writing to a shared volatile variable, and still have the correct value stored in main memory, if the new value written to the variable does not depend on its previous value. In other words, if a thread writing a value to the shared volatile variable does not first need to read its value to figure out its next value.</p> <p>As soon as a thread needs to first read the value of a volatile variable, and based on that value generate a new value for the shared volatile variable, a volatile variable is no longer enough to guarantee correct visibility. The short time gap in between the reading of the volatile variable and the writing of its new value, creates a <code>race condition</code> where multiple threads might read the same value of the volatile variable, generate a new value for the variable, and when writing the value back to main memory - overwrite each other's values.</p> <p>The situation where multiple threads are incrementing the same counter is exactly such a situation where a volatile variable is not enough. The following sections explain this case in more detail.</p> <p>Imagine if Thread 1 reads a shared counter variable with the value 0 into its CPU cache, increment it to 1 and not write the changed value back into main memory. Thread 2 could then read the same counter variable from main memory where the value of the variable is still 0, into its own CPU cache. Thread 2 could then also increment the counter to 1, and also not write it back to main memory. This situation is illustrated in the diagram below:  Two threads have read a shared counter variable into their local CPU caches and incremented it. Thread 1 and Thread 2 are now practically out of sync. The real value of the shared counter variable should have been 2, but each of the threads has the value 1 for the variable in their CPU caches, and in main memory the value is still 0. It is a mess! Even if the threads eventually write their value for the shared counter variable back to main memory, the value will be wrong.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#when-is-volatile-enough","title":"When is volatile Enough?","text":"<p>As I have mentioned earlier, if two threads are both reading and writing to a shared variable, then using the volatile keyword for that is not enough. You need to use a synchronized in that case to guarantee that the reading and writing of the variable is atomic. Reading or writing a volatile variable does not block threads reading or writing. For this to happen you must use the synchronized keyword around critical sections.</p> <p>As an alternative to a synchronized block you could also use one of the many atomic data types found in the java.util.concurrent package. For instance, the AtomicLong or AtomicReference or one of the others.</p> <p>In case only one thread reads and writes the value of a volatile variable and other threads only read the variable, then the reading threads are guaranteed to see the latest value written to the volatile variable. Without making the variable volatile, this would not be guaranteed.</p> <p>The volatile keyword is guaranteed to work on 32 bit and 64 variables.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#summary","title":"Summary","text":"<ul> <li>Only one thread reads and writes the value of a volatile variable and <code>other threads only read</code> the variable, volatile is enough.</li> <li>Suppose there are multiple threads write the value of a volatile variable, if the new value written to the variable <code>does not depend on its previous value</code>, volatile is enough.</li> <li>If two threads are <code>both</code> reading and writing to a shared variable, volatile is not enough.</li> </ul>"},{"location":"java-concurrency/java-concurrency-volatile/#performance-considerations-of-volatile","title":"Performance Considerations of volatile","text":"<p>Reading and writing of volatile variables causes the variable to be read or written to main memory. Reading from and writing to main memory is more expensive than accessing the CPU cache. Accessing volatile variables also prevent instruction reordering which is a normal performance enhancement technique. Thus, you should only use volatile variables when you really need to enforce visibility of variables.</p>"},{"location":"java-concurrency/java-concurrency-volatile/#references","title":"References","text":"<ul> <li>Java Volatile Keyword</li> </ul>"},{"location":"java-concurrency/java-concurrency-wait-notify-notifyall/","title":"wait, notify and notifyAll","text":"<p>The Object class in java contains three final methods that allows threads to communicate about the lock status of a resource. These methods are wait(), notify() and notifyAll().</p> <ul> <li><code>wait</code> - Wait indefinitely or for specific amount of time for any other thread to call notify or notifyAll method on the object to wake up the current thread.</li> <li><code>notify</code> - Wake up <code>only one</code> thread waiting on the object and that thread starts execution. So if there are multiple threads waiting for an object, this method will wake up only one of them. The choice of the thread to wake depends on the OS implementation of thread management.</li> <li><code>notifyAll</code> - Wake up all the threads waiting on the object, although which one will process first depends on the OS implementation.</li> </ul> <p>These methods can be used to implement producer consumer problem where consumer threads are waiting for the objects in Queue and producer threads put object in queue and notify the waiting threads.</p>"},{"location":"java-concurrency/java-concurrency-wait-notify-notifyall/#example","title":"Example","text":"<p>Message bean class.</p> <pre><code>public class Message {\n    private String msg;\n\n    public Message(String msg){\n        this.msg = msg;\n    }\n\n    public String getMsg() {\n        return msg;\n    }\n\n    public void setMsg(String msg) {\n        this.msg = msg;\n    }\n}\n</code></pre> <p>Producer.</p> <pre><code>public class Producer implements Runnable {\n\n    private Message msg;\n\n    public Producer(Message msg) {\n        this.msg = msg;\n    }\n\n    @Override\n    public void run() {\n        String name = Thread.currentThread().getName();\n        System.out.println(name + \": started\");\n        try {\n            Thread.sleep(1000);\n            synchronized (msg) {\n                msg.setMsg(\"hello world!\");\n                System.out.println(name+\": message is updated at: \" + LocalDateTime.now().toString());\n\n                msg.notify();\n                //msg.notifyAll();\n            }\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n    }\n}\n</code></pre> <p>Consumer.</p> <pre><code>public class Consumer implements Runnable{\n\n    private Message msg;\n\n    public Consumer(Message msg){\n        this.msg = msg;\n    }\n\n    @Override\n    public void run() {\n        String name = Thread.currentThread().getName();\n        synchronized (msg) {\n            try{\n                System.out.println(name+\": waiting to get notified at: \" + LocalDateTime.now().toString());\n                msg.wait();\n            }\n            catch(InterruptedException e){\n                e.printStackTrace();\n            }\n            System.out.println(name+\": got notified at: \" + LocalDateTime.now().toString());\n            //process the message now\n            System.out.println(name+\": message[\" + msg.getMsg() + \"] is processed.\");\n        }\n    }\n}\n</code></pre> <p>Test class.</p> <pre><code>public class NotifyExample {\n    public static void main(String[] args) throws Exception {\n        Message msg = new Message(\"process it\");\n\n        Consumer consumer1 = new Consumer(msg);\n        new Thread(consumer1,\"Consumer1\").start();\n\n        Consumer consumer2 = new Consumer(msg);\n        new Thread(consumer2,\"Consumer2\").start();\n\n        Producer producer = new Producer(msg);\n        new Thread(producer, \"Producer\").start();\n\n        Thread.sleep(1000);\n        System.out.println(\"main: All the threads are started\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Producer: started\nConsumer1: waiting to get notified at: 2019-08-04T16:06:33.348\nConsumer2: waiting to get notified at: 2019-08-04T16:06:33.397\nmain: All the threads are started\nProducer: message is updated at: 2019-08-04T16:06:34.331\nConsumer1: got notified at: 2019-08-04T16:06:34.331\nConsumer1: message[hello world!] is processed.\n</code></pre> <p>If we comment the notify() call and uncomment the <code>notifyAll()</code> call in Producer class, both two consumer threads will be notified.</p> <pre><code>Producer: started\nConsumer1: waiting to get notified at: 2019-08-04T16:07:08.594\nConsumer2: waiting to get notified at: 2019-08-04T16:07:08.645\nmain: All the threads are started\nProducer: message is updated at: 2019-08-04T16:07:09.566\nConsumer2: got notified at: 2019-08-04T16:07:09.566\nConsumer2: message[hello world!] is processed.\nConsumer1: got notified at: 2019-08-04T16:07:09.566\nConsumer1: message[hello world!] is processed.\n</code></pre>"},{"location":"java-concurrency/java-concurrency-wait-notify-notifyall/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Wait and Notify on GitHub</li> </ul>"},{"location":"java-concurrency/java-concurrency-wait-notify-notifyall/#references","title":"References","text":"<ul> <li>Java Thread wait, notify and notifyAll Example</li> </ul>"},{"location":"java-core/java-core-array-and-list/","title":"Array and List","text":"<p>Array, ArrayList and their conversion.</p>"},{"location":"java-core/java-core-array-and-list/#array","title":"Array","text":""},{"location":"java-core/java-core-array-and-list/#initializing-array","title":"Initializing Array","text":"<p>An array in java is a container that can hold a <code>fixed</code> number of values of the same type. The values can be of the primitive type like int, short, byte or it can be an object like String, Integer etc.</p> <p>How to initialize an Array in Java?</p> <ul> <li>Initializing an array in java \u2013 primitive type</li> <li>Initializing an array in java \u2013 object type</li> <li>Initializing a multidimensional array in java</li> <li>Initializing an array in java using shortcut syntax</li> <li>Invalid ways to initialize an array in java</li> </ul> <p>Valid Examples.</p> <pre><code>private static void initializeArray() {\n    //initialize primitive one dimensional array\n    int[] nums = new int[5];\n\n    //initialize Object one dimensional array\n    String[] strings; //declaration\n\n    strings = new String[4]; //initialization\n\n    //initialize multidimensional array\n    int[][] matrix = new int[4][5];\n\n    //multidimensional array initialization with only leftmost dimension\n    int[][] array = new int[2][];\n    array[0] = new int[2];\n    array[1] = new int[3]; //complete initialization is required before we use the array\n\n    //array initialization using shortcut syntax\n    int[] nums1 = {1,2,3};\n    int[][] nums2 = { {1,2}, {1,2,3} };\n}\n</code></pre> <p>Some invalid examples.</p> <pre><code>    //invalid because dimension is not provided\n    int[] a = new int[];\n\n    //invalid because leftmost dimension value is not provided\n    int[][] aa = new int[][5];\n</code></pre>"},{"location":"java-core/java-core-array-and-list/#array-of-list","title":"Array of List","text":"<p>We can create a Java array of list, each element in the array is a list.</p> <pre><code>private static void arrayOfList() {\n    List&lt;String&gt; list1 = new ArrayList&lt;&gt;();\n    list1.add(\"1\");\n    list1.add(\"2\");\n\n    List&lt;String&gt; list2 = new ArrayList&lt;&gt;();\n    list2.add(\"3\");\n    list2.add(\"4\");\n    list2.add(\"5\");\n\n    //List&lt;String&gt;[] arrayOfList = new List&lt;String&gt;[2]; // Can\u2019t use generics while creating the array because java doesn\u2019t support generic array\n    List&lt;String&gt;[] arrayOfList = new List[2];\n\n    arrayOfList[0] = list1;\n    arrayOfList[1] = list2;\n\n    for (int i = 0; i &lt; arrayOfList.length; i++) {\n        List&lt;String&gt; list = arrayOfList[i];\n        System.out.println(list);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>[1, 2]\n[3, 4, 5]\n</code></pre>"},{"location":"java-core/java-core-array-and-list/#list-of-array","title":"List of Array","text":"<p>We can also create a Java list of array, each element in the list is an array.</p> <pre><code>private static void listOfArray() {\n    // List of String arrays\n    List&lt;String[]&gt; list = new ArrayList&lt;&gt;();\n\n    String[] arr1 = { \"a\", \"b\", \"c\" };\n    String[] arr2 = { \"1\", \"2\", \"3\", \"4\" };\n    list.add(arr1);\n    list.add(arr2);\n    // printing list of String arrays in the ArrayList\n    for (String[] strArr : list) {\n        System.out.println(Arrays.toString(strArr));\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>[a, b, c]\n[1, 2, 3, 4]\n</code></pre>"},{"location":"java-core/java-core-array-and-list/#conversion","title":"Conversion","text":""},{"location":"java-core/java-core-array-and-list/#array-to-list","title":"Array to List","text":"<p>There are two built-in ways to convert Array to List in Java.</p> <ul> <li><code>Arrays.asList(T\u2026 a)</code>: This is the simplest way to convert Array to ArrayList in java but this method returns the underlying representation of the array in the form of ArrayList. The returned ArrayList is <code>fixed-sized</code> and any attempt to modify that will result in <code>UnsupportedOperationException</code> at runtime. Also, any change in the array will change the elements in ArrayList also.</li> <li><code>Collections.addAll(ArrayList&lt;T&gt; strList, T[] strArr)</code>: This is the best way to convert array to ArrayList because the array data is copied to the list and both are independent object - <code>deep copy</code>. Once the array is copied, you can modify both the objects independently. Collections is a very useful class in Java Collections Framework that provides a lot of utility methods.</li> </ul> <p>Examples for converting array to list.</p> <pre><code>public class ArrayToList {\n    public static void main(String[] args) {\n        // approach one\n        convertByArrays();\n\n        System.out.println();\n\n        // approach two\n        convertByCollections();\n    }\n\n    private static void convertByArrays() {\n        System.out.println(\"Convert array to list with Arrays.asList()\");\n\n        String[] strArr = {\"a\", \"b\", \"c\", \"d\"};\n        System.out.println(\"Original array: \" + Arrays.toString(strArr));\n\n        // convert\n        List&lt;String&gt; strList = Arrays.asList(strArr);\n        System.out.println(\"Converted ArrayList: \" + strList.toString());\n\n        // change the array element\n        strArr[0] = \"z\";\n        System.out.println(\"Changed array: \" + Arrays.toString(strArr));\n        System.out.println(\"ArrayList after array is changed: \" + strList.toString() + \", list is impacted.\");\n        // below code will throw java.lang.UnsupportedOperationException because\n        // Arrays.asList() returns a fixed-size list backed by the specified array.\n        //strList.add(\"5\");\n    }\n\n    private static void convertByCollections() {\n        System.out.println(\"Convert array to list with Collections.addAll()\");\n\n        String[] strArr = {\"a\", \"b\", \"c\", \"d\"};\n        System.out.println(\"Original Array: \" + Arrays.toString(strArr));\n\n        // convert\n        List&lt;String&gt; strList = new ArrayList&lt;&gt;();\n        Collections.addAll(strList, strArr);\n        System.out.println(\"Converted ArrayList: \" + strList);\n\n        // change the array element\n        strArr[0] = \"z\";\n        System.out.println(\"Changed array: \" + Arrays.toString(strArr));\n        System.out.println(\"ArrayList after array is changed: \" + strList.toString() + \", list is not impacted.\");\n\n        // add new element to list\n        strList.add(\"e\");\n        System.out.println(\"ArrayList after new element is added: \" + strList.toString());\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Convert array to list with Arrays.asList()\nOriginal array: [a, b, c, d]\nConverted ArrayList: [a, b, c, d]\nChanged array: [z, b, c, d]\nArrayList after array is changed: [z, b, c, d], list is impacted.\n\nConvert array to list with Collections.addAll()\nOriginal Array: [a, b, c, d]\nConverted ArrayList: [a, b, c, d]\nChanged array: [z, b, c, d]\nArrayList after array is changed: [a, b, c, d], list is not impacted.\nArrayList after new element is added: [a, b, c, d, e]\n</code></pre>"},{"location":"java-core/java-core-array-and-list/#list-to-array","title":"List to Array","text":"<p>There is three built-in ways to convert List to Array in Java. All utilize the <code>toArray()</code> method.</p> <ul> <li>Using Object Array: <code>Object[] List.toArray()</code> - This is the simplest way to convert List to Array in java but this method returns the array with Object type.</li> <li>Using Generic Type: <code>T[] List.toArray(T[] array)</code> - This is the best way to convert List to Array because it supports generic types.</li> <li>Using Stream: <code>stream.toArray()</code> - We can use stream in Java 8.</li> </ul>"},{"location":"java-core/java-core-array-and-list/#using-object-array","title":"Using Object Array","text":"<pre><code>private static void usingObject() {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n\n    Object[] arr1 = list.toArray(); //returns an array of Object\n    System.out.println(\"Object: arr1 = \" + Arrays.toString(arr1));\n}\n</code></pre> <p>Output.</p> <pre><code>Object: arr1 = [1, 2, 3]\n</code></pre>"},{"location":"java-core/java-core-array-and-list/#using-generic-type","title":"Using Generic Type","text":"<pre><code>private static void usingGeneric() {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n\n    // 1. Create same type array with same size\n    Integer[] arr2 = new Integer[list.size()];\n    arr2 = list.toArray(arr2);\n    System.out.println(\"Generic Type: arr2 = \" + Arrays.toString(arr2));\n\n    // Shortcut for above approach\n    Integer[] arr3 = list.toArray(new Integer[list.size()]);\n    System.out.println(\"Generic Type: arr3 = \" + Arrays.toString(arr3));\n\n    // 2. The given array has no enough space, a new array is created\n    Integer[] arr4 = list.toArray(new Integer[0]);\n    System.out.println(\"Generic Type: arr4 = \" + Arrays.toString(arr4));\n\n    // 3. The given array has more space, the right part are filled with null\n    Integer[] arr5 = list.toArray(new Integer[10]);\n    System.out.println(\"Generic Type: arr5 = \" + Arrays.toString(arr5));\n}\n</code></pre> <p>Output.</p> <pre><code>Generic Type: arr2 = [1, 2, 3]\nGeneric Type: arr3 = [1, 2, 3]\nGeneric Type: arr4 = [1, 2, 3]\nGeneric Type: arr5 = [1, 2, 3, null, null, null, null, null, null, null]\n</code></pre> <p>Note: toArray() method returns an array of type Object(Object[]). We need to <code>typecast</code> it to Integer before using as Integer objects. If we do not typecast, we get compilation error. Consider the following example:</p> <pre><code>// Error: incompatible types: Object[], cannot be converted to Integer[]\nInteger[] arr1 = list.toArray();\nSystem.out.println(\"arr1 = \" + Arrays.toString(arr1));\n</code></pre>"},{"location":"java-core/java-core-array-and-list/#using-stream","title":"Using Stream","text":"<pre><code>private static void usingStream() {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(3);\n\n    // Use stream in Java 8\n    Integer[] arr6 = list.stream().toArray(Integer[]::new);\n    System.out.println(\"Stream: arr6 = \" + Arrays.toString(arr6));\n}\n</code></pre> <p>Output.</p> <pre><code>Stream: arr6 = [1, 2, 3]\n</code></pre>"},{"location":"java-core/java-core-array-and-list/#copy-array","title":"Copy Array","text":"<p>There are four built-in approaches to copy array.</p> <ul> <li><code>Arrays.copyOf()</code>: If you want to copy first few elements of an array or full copy of array, you can use this method. This method internally use System.arraycopy() method.</li> <li><code>Arrays.copyOfRange()</code>: If you want few elements of an array to be copied, where starting index is not 0, you can use this method to copy partial array. Again this method is also using System.arraycopy() method itself.</li> <li><code>System.arraycopy()</code>: System.arraycopy() is the best way to do partial copy of an array. It provides you an easy way to specify the total number of elements to copy and the source and destination array index positions. For example System.arraycopy(source, 3, destination, 2, 5) will copy 5 elements from source to destination, beginning from 3rd index of source to 2nd index of destination.</li> <li><code>Object.clone()</code>: Object class provides clone() method and since array in java is also an Object, you can use this method to achieve full array copy. This method will not suit you if you want partial copy of the array.</li> </ul> <p>Examples for copying arrays.</p> <pre><code>public class CopyArray {\n    public static void main(String[] args) {\n        int[] original = {1,2,3,4,5,6,7,8,9};\n\n        System.out.println(\"Original array = \" + Arrays.toString(original));\n\n        int[] copy = Arrays.copyOf(original, original.length);\n        System.out.println(\"Arrays.copyOf(): copy = \" + Arrays.toString(copy));\n\n        int[] copyRange = Arrays.copyOfRange(original, 3, 6);\n        System.out.println(\"Arrays.copyOfRange(): copyRange = \" + Arrays.toString(copyRange));\n\n        int[] systemCopy = new int[original.length];\n        System.arraycopy(original, 0, systemCopy, 0, original.length);\n        System.out.println(\"System.arraycopy(): systemCopy = \" + Arrays.toString(systemCopy));\n\n        int[] clone = original.clone();\n        System.out.println(\"Object.clone(): clone = \" + Arrays.toString(clone));\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Original array = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nArrays.copyOf(): copy = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nArrays.copyOfRange(): copyRange = [4, 5, 6]\nSystem.arraycopy(): systemCopy = [1, 2, 3, 4, 5, 6, 7, 8, 9]\nObject.clone(): clone = [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre> <p>Note that all the inbuilt methods discussed above for array copy perform <code>shallow copy</code>, so they are good for primitive data types and immutable objects such as String. If you want to copy an array of mutable objects, you should do it by writing code for a <code>deep copy</code> yourself.</p>"},{"location":"java-core/java-core-array-and-list/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Array and List on GitHub</li> </ul>"},{"location":"java-core/java-core-array-and-list/#references","title":"References","text":"<ul> <li>Java Array of ArrayList, ArrayList of Array</li> <li>ArrayList to Array Conversion in Java : toArray() Methods</li> <li>Java Array to List</li> <li>Java Copy Array \u2013 Array Copy in Java</li> </ul>"},{"location":"java-core/java-core-arraylist-and-linkedlist/","title":"ArrayList and LinkedList","text":"<p>ArrayList vs LinkedList.</p>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#arraylist","title":"ArrayList","text":""},{"location":"java-core/java-core-arraylist-and-linkedlist/#constructor","title":"Constructor","text":"<p>There are three constructors in Java ArrayList class.</p> <ul> <li>public ArrayList()</li> <li>public ArrayList(int initialCapacity)</li> <li>public ArrayList(Collection&lt;? extends E&gt; c)</li> </ul> <pre><code>private static void constructList() {\n    // no arguments\n    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\n    list1.add(5);\n    list1.add(9);\n    list1.add(4);\n    list1.add(2);\n    System.out.println(\"Construct list: \" + list1);\n\n    // with another list\n    List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(list1);\n    System.out.println(\"Construct list with another list: \" + list2);\n\n    // with treeset\n    SortedSet&lt;Integer&gt; treeSet1 = new TreeSet&lt;&gt;(list1);\n    List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(treeSet1);\n    System.out.println(\"Construct list with tree set: \" + list3);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct list: [5, 9, 4, 2]\nConstruct list with another list: [5, 9, 4, 2]\nConstruct list with tree set: [2, 4, 5, 9]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#common-operations","title":"Common Operations","text":"<ul> <li>list.add(item);</li> <li>list.add(0, item);</li> <li>list.remove(index);</li> <li>list.subList(index1, index2);</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // add\n    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; 9; i++) {\n        list1.add(i);\n    }\n    System.out.println(\"Common operations - add : \" + list1);\n\n    // insert\n    list1.add(0, 12);\n    System.out.println(\"Insert 12 at index 0 : \" + list1);\n    list1.add(5, 9);\n    System.out.println(\"Insert 9 at index 5 : \" + list1);\n\n    // remove\n    list1.remove(0);\n    System.out.println(\"Remove element which is at index 0 : \" + list1);\n\n    // get\n    System.out.println(\"Get element which is at index 3 : \" + list1.get(3));\n\n    // sub list\n    List&lt;Integer&gt; list2 = list1.subList(2, 4);\n    System.out.println(\"Sub list from index 2(inclusive) to index 4(exclusive) : \" + list2);\n}\n</code></pre> <p>Output.</p> <pre><code>Common operations - add : [0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 12 at index 0 : [12, 0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 9 at index 5 : [12, 0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nRemove element which is at index 0 : [0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nGet element which is at index 3 : 3\nSub list from index 2(inclusive) to index 4(exclusive) : [2, 3]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#sorting","title":"Sorting","text":"<pre><code>private static void sortList() {\n    // Sorting\n    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\n    list1.add(3);\n    list1.add(1);\n    list1.add(2);\n    Collections.sort(list1);                // ascending order, list1 = {1,2,3}\n    System.out.println(\"Sort list in ascending order: \" + list1);\n    Collections.sort(list1, (a,b)-&gt;(b-a));  // descending order, list1 = {3,2,1}\n    System.out.println(\"Sort list in descending order: \" + list1);\n}\n</code></pre> <p>Output.</p> <pre><code>Sort list in ascending order: [1, 2, 3]\nSort list in descending order: [3, 2, 1]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#traversal","title":"Traversal","text":"<p>There are three ways to traverse a list.</p> <ul> <li>basic for</li> <li>for each</li> <li>iterator</li> </ul> <pre><code>private static void traverseList() {\n    List&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // basic for\n    for (int i = 0; i &lt; fruits.size(); i++) {\n        System.out.println(\"Traverse List(basic for): processing - \" + fruits.get(i));\n    }\n\n    System.out.println();\n\n    // for each\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // iterator\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()) {\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse List(basic for): processing - Apple\nTraverse List(basic for): processing - Banana\nTraverse List(basic for): processing - Orange\nTraverse List(basic for): processing - Watermelon\nTraverse List(basic for): processing - Kiwi\n\nTraverse List(for each): processing - Apple\nTraverse List(for each): processing - Banana\nTraverse List(for each): processing - Orange\nTraverse List(for each): processing - Watermelon\nTraverse List(for each): processing - Kiwi\n\nTraverse List(iterator): processing - Apple\nTraverse List(iterator): processing - Banana\nTraverse List(iterator): processing - Orange\nTraverse List(iterator): processing - Watermelon\nTraverse List(iterator): processing - Kiwi\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#remove-element","title":"Remove Element","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>List.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    List&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // in for each loop\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n\n        if (\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits list after iteration = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    List&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Remove element: processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            iterator.remove();  // iterator.remove not list.remove\n        }\n    }\n\n    System.out.println(\"Fruits list after deletion = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - Apple\nRemove element: processing - Banana\nRemove element: processing - Orange\nRemove element: processing - Watermelon\nRemove element: processing - Kiwi\nFruits list after deletion = [Apple, Banana, Watermelon, Kiwi]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#linkedlist","title":"LinkedList","text":""},{"location":"java-core/java-core-arraylist-and-linkedlist/#constructor-of-linkedlist","title":"Constructor of LinkedList","text":"<p>There are two constructors in Java LinkedList class.</p> <ul> <li>public LinkedList()</li> <li>public LinkedList(Collection&lt;? extends E&gt; c)</li> </ul> <pre><code>private static void constructList() {\n    // no arguments\n    List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();\n    list1.add(5);\n    list1.add(9);\n    list1.add(4);\n    list1.add(4);\n    list1.add(2);\n    System.out.println(\"Construct list: \" + list1);\n\n    // with another list\n    List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;(list1);\n    System.out.println(\"Construct list with another list: \" + list2);\n\n    // with treeset\n    SortedSet&lt;Integer&gt; treeSet1 = new TreeSet&lt;&gt;(list1);\n    List&lt;Integer&gt; list3 = new LinkedList&lt;&gt;(treeSet1);\n    System.out.println(\"Construct list with tree set: \" + list3);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct list: [5, 9, 4, 4, 2]\nConstruct list with another list: [5, 9, 4, 4, 2]\nConstruct list with tree set: [2, 4, 5, 9]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#common-operations-of-linkedlist","title":"Common Operations of LinkedList","text":"<ul> <li>list.add(item);</li> <li>list.add(0, item);</li> <li>list.remove(index);</li> <li>list.subList(index1, index2);</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // add\n    List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();\n    for (int i = 0; i &lt; 9; i++) {\n        list1.add(i);\n    }\n    System.out.println(\"Common operations - add : \" + list1);\n\n    // insert\n    list1.add(0, 12);\n    System.out.println(\"Insert 12 at index 0 : \" + list1);\n    list1.add(5, 9);\n    System.out.println(\"Insert 9 at index 5 : \" + list1);\n\n    // remove\n    list1.remove(0);\n    System.out.println(\"Remove element which is at index 0 : \" + list1);\n\n    // sub list\n    List&lt;Integer&gt; list2 = list1.subList(2, 4);\n    System.out.println(\"Sub list from index 2(inclusive) to index 4(exclusive) : \" + list2);\n}\n</code></pre> <p>Output.</p> <pre><code>Common operations - add : [0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 12 at index 0 : [12, 0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 9 at index 5 : [12, 0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nRemove element which is at index 0 : [0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nSub list from index 2(inclusive) to index 4(exclusive) : [2, 3]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#sorting-of-linkedlist","title":"Sorting of LinkedList","text":"<pre><code>private static void sortList() {\n    // Sorting\n    List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();\n    list1.add(3);\n    list1.add(1);\n    list1.add(2);\n\n    Collections.sort(list1);                // ascending order, list1 = {1,2,3}\n    System.out.println(\"Sort list in ascending order: \" + list1);\n    Collections.sort(list1, (a,b)-&gt;(b-a));  // descending order, list1 = {3,2,1}\n    System.out.println(\"Sort list in descending order: \" + list1);\n}\n</code></pre> <p>Output.</p> <pre><code>Sort list in ascending order: [1, 2, 3]\nSort list in descending order: [3, 2, 1]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#traversal-of-linkedlist","title":"Traversal of LinkedList","text":"<p>There are two ways to traverse a list.</p> <ul> <li>for each</li> <li>iterator</li> </ul> <pre><code>private static void traverseList() {\n    List&lt;String&gt; fruits = new LinkedList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // for each\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // iterator\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()) {\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse List(for each): processing - Apple\nTraverse List(for each): processing - Banana\nTraverse List(for each): processing - Orange\nTraverse List(for each): processing - Watermelon\nTraverse List(for each): processing - Kiwi\n\nTraverse List(iterator): processing - Apple\nTraverse List(iterator): processing - Banana\nTraverse List(iterator): processing - Orange\nTraverse List(iterator): processing - Watermelon\nTraverse List(iterator): processing - Kiwi\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#remove-element-of-linkedlist","title":"Remove Element of LinkedList","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>List.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    List&lt;String&gt; fruits = new LinkedList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // in for each loop\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n\n        if (\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits list after iteration = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    List&lt;String&gt; fruits = new LinkedList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Remove element: processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            iterator.remove();  // iterator.remove not list.remove\n        }\n    }\n\n    System.out.println(\"Fruits list after deletion = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - Apple\nRemove element: processing - Banana\nRemove element: processing - Orange\nRemove element: processing - Watermelon\nRemove element: processing - Kiwi\nFruits list after deletion = [Apple, Banana, Watermelon, Kiwi]\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#interface","title":"Interface","text":"<p>LinkedList implements three interfaces: List, Queue and Queue.</p> <pre><code>private static void interfaces() {\n    // List Interface, insertion order\n    List&lt;Integer&gt; list = new LinkedList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(4);\n    list.forEach(System.out::println);  // print 1,2,4\n\n    // Queue interface, FIFO\n    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n    queue.offer(1);\n    queue.offer(2);\n    queue.offer(3);\n    while (!queue.isEmpty()) {\n        System.out.println(queue.poll());  // print 1,2,3\n    }\n\n    // Deque interface, FIFO or LIFO\n    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n    deque.offerLast(1);  // deque = {1}\n    deque.offerLast(2);  // deque = {1,2}\n    deque.offerFirst(3); // deque = {3, 1, 2}\n    deque.peekFirst();      // return 3\n    deque.peekLast( );      // return 2\n    deque.pollFirst();      // return 3, deque = {1,2}\n    deque.pollLast();       // return 2, deque = {1}\n}\n</code></pre>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#arraylist-vs-linkedlist","title":"ArrayList vs LinkedList","text":"<ul> <li> <p>The insert and remove operations give good performance (O(1)) in LinkedList compared to ArrayList(O(n)). Hence if there is a requirement of frequent addition and deletion in application then LinkedList is a best choice.</p> </li> <li> <p>Search (get method) operations are fast in Arraylist (O(1)) but not in LinkedList (O(n)) so If there are less add and remove operations and more search operations requirement, ArrayList would be your best bet.</p> </li> </ul>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java ArrayList and LinkedList on GitHub</li> </ul>"},{"location":"java-core/java-core-arraylist-and-linkedlist/#references","title":"References","text":"<ul> <li>Java Doc - Controlling Access to Members of a Class</li> <li>Core Java Tutorial</li> <li>Java Data Types</li> <li>Primitive Wrapper Classes are Immutable in Java</li> <li>Collections in Java \u2013 Tutorial</li> </ul>"},{"location":"java-core/java-core-basic/","title":"Java Basics","text":"<p>Basic knowledge of java.</p>"},{"location":"java-core/java-core-basic/#java-basic-knowledge","title":"Java basic knowledge","text":""},{"location":"java-core/java-core-basic/#java-access-modifiers","title":"Java Access Modifiers","text":"<p>Class Access Levels are as follows:</p> Access Modifiers private default protected public Inside Class Y Y Y Y Same Package Class N Y Y Y Same Package Sub-Class N Y Y Y Other Package Class N N N Y Other Package Sub-Class N N Y Y"},{"location":"java-core/java-core-basic/#java-primitive-data-types","title":"Java Primitive Data Types","text":"<p>A <code>primitive data type</code> specifies the size and type of variable values, and it has no additional methods. There are eight primitive data types in Java:</p> Data Type Size Description byte 1 byte Stores whole numbers from -128 to 127 short 2 bytes Stores whole numbers from -32,768 to 32,767 int 4 bytes Stores whole numbers from -2,147,483,648 to 2,147,483,647 long 8 bytes Stores whole numbers from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,808 float 4 bytes Stores fractional numbers from 3.4e\u2212038 to 3.4e+038. Sufficient for storing 6 to 7 decimal digits double 8 bytes Stores fractional numbers from 1.7e\u2212308 to 1.7e+038. Sufficient for storing 15 decimal digits boolean 1 byte Stores true or false values char 2 bytes Stores a single character/letter"},{"location":"java-core/java-core-basic/#java-non-primitive-data-types","title":"Java Non-primitive data types","text":"<p>Non-primitive data types are called <code>reference types</code> because they refer to objects. The main difference between <code>primitive</code> and <code>non-primitive</code> data types are:</p> <ul> <li>Primitive types are predefined (already defined) in Java. Non-primitive types are created by the programmer and is not defined by Java (except for <code>String</code>).</li> <li>Non-primitive types can be used to call methods to perform certain operations, while primitive types cannot.</li> <li>A primitive type has always a value, while non-primitve types can be <code>null</code>.</li> <li>A primitive type starts with a lowercase letter, while non-primitive types starts with an uppercase letter.</li> <li>The size of a primitive type depends on the data type, while non-primitive types have all the same size.</li> </ul> <p>Examples of non-primitive types are <code>Strings</code>, <code>Arrays</code>, <code>Classes</code>, <code>Interface</code>, etc.</p>"},{"location":"java-core/java-core-basic/#autoboxing-in-java","title":"Autoboxing in Java","text":"<p>Autoboxing in java was introduced in Java 1.5. Autoboxing and unboxing is a convenient way to auto transform primitive data type to it\u2019s corresponding java wrapper classes and vice versa.</p> <p>Autoboxing in Java Converting a primitive data type into an object of the corresponding wrapper class is called autoboxing. For example, converting int to Integer or converting long to Long object.</p> <p>Java compiler applies autoboxing when a primitive value is:</p> <ul> <li>Passed as a parameter to a method that expects an object of the corresponding wrapper class. For example a method with Integer argument can be called by passing int, java compiler will do the conversion of int to Integer.</li> <li>Assigned to a variable of the corresponding wrapper class. For example, assigning a Long object to long variable.</li> </ul> <p>Unboxing in Java Converting an object of a wrapper type to its corresponding primitive data type is called unboxing.</p> <p>Java compiler applies unboxing when an object of a wrapper class is:</p> <ul> <li>Passed as a parameter to a method that expects a value of the corresponding primitive type.</li> <li>Assigned to a variable of the corresponding primitive type.</li> </ul> <p>Java Autoboxing Example:</p> <pre><code>public static void main(String[] args) {\n    int i = 6;\n    long j = 105L;\n\n    // passed the int, will get converted to Integer object at Runtime using\n    // autoboxing in java\n    doSomething(i);\n\n    List&lt;Long&gt; list = new ArrayList&lt;&gt;();\n\n    // java autoboxing to add primitive type in collection classes\n    list.add(j);\n}\n\nprivate static void doSomething(Integer in) {\n    // unboxing in java, at runtime Integer.intValue() is called implicitly to return int\n    int j = in;\n\n    // java unboxing, Integer is passed where int is expected\n    doPrimitive(in);\n}\n\nprivate static void doPrimitive(int i) {\n\n}\n</code></pre>"},{"location":"java-core/java-core-basic/#wrapper-class-in-java","title":"Wrapper Class in Java","text":"<p>Wrapper class in java are the Object representation of eight primitive types in java. All the wrapper classes in java are <code>immutable</code> and <code>final</code>. Java 5 autoboxing and unboxing allows easy conversion between primitive types and their corresponding wrapper classes in java programs.</p> <p>Below table shows the primitive types and their wrapper class in java.</p> Primitive type Wrapper class Constructor Arguments byte Byte byte or String short Short short or String int Integer int or String long Long long or String float Float float, double or String double Double double or String char Character char boolean Boolean boolean or String <p>Example.</p> <pre><code>public static void main(String args[]){\n    int i = 10;\n    char c = 'a';\n\n    // primitives are simple to use\n    int j = i + 3;\n\n    // polymorphism achieved by Wrapper classes, we can't pass primitive here\n    doSomething(new Character(c));\n\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;();\n    // wrapper classes can be used in Collections\n    Integer in = new Integer(i);\n    list.add(in);\n\n    // autoboxing takes care of primitive to wrapper class conversion\n    list.add(j);\n\n    // wrapper classes can be null\n    in = null;\n\n    Integer ix = new Integer(12);\n    System.out.println(ix); // ix = 12\n    modify(ix);\n    System.out.println(ix); // ix is still 12\n}\n\nprivate static void doSomething(Object obj){\n\n}\n\nprivate static void modify(Integer ix) {\n    ix = ix + 1;\n    System.out.println(ix); // ix = 13\n}\n</code></pre> <p>Notice, variable <code>ix</code> in main() function is not changed after the call by modify() function.</p>"},{"location":"java-core/java-core-basic/#for-loop","title":"for loop","text":"<p>There are three types of for loop in java.</p> <ul> <li>General for loop</li> <li>for-each or enhanced for loop</li> <li>Java for loop with label(continue or break)</li> </ul> <p>Example for 'general for loop'.</p> <pre><code>// print integers 6 to 10\nfor (int i = 6; i &lt;= 10; i++) {\n    System.out.println(\"Java for loop example - \" + i);\n}\n</code></pre> <p>Example for 'for-each or enhanced for loop'.</p> <pre><code>// print integers with 'for each'\nint[] intArray = { 1, 2, 3, 4, 5 };\n\nfor (int i : intArray) {\n    System.out.println(\"Java for each example - \" + i);\n}\n\n// print strings with 'for loop'\nList&lt;String&gt; fruits = new ArrayList&lt;&gt;();\nfruits.add(\"Apple\");\nfruits.add(\"Banana\");\nfruits.add(\"Orange\");\n\nfor (String f : fruits) {\n    System.out.println(\"Java for each loop with collection - \" + f);\n}\n</code></pre> <p>Example for 'for loop with label'.</p> <pre><code>// for loop with label, continue\nint[][] intArr = { { 1, -2, 3 }, { 0, 3 }, { 9, 2, 5 }, { 1, 2, 5 }};\n\nprocess: for (int i = 0; i &lt; intArr.length; i++) {\n    boolean allPositive = true;\n    for (int j = 0; j &lt; intArr[i].length; j++) {\n        if (intArr[i][j] &lt; 0) {\n            allPositive = false;\n            continue process;\n        }\n    }\n    if (allPositive) {\n        // process the array\n        System.out.println(\"Array has no negative elements: \" + Arrays.toString(intArr[i]));\n    }\n}\n\n// for loop with label, break\nsearch:\nfor (int i = 0; i &lt; intArr.length; i++) {\n    for (int j = 0; j &lt; intArr[i].length; j++) {\n        if (intArr[i][j] &gt; 7) {\n            System.out.println(\"Find array which contains element larger than 7: \" + Arrays.toString(intArr[i]));\n            break search;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Java for loop example - 6\nJava for loop example - 7\nJava for loop example - 8\nJava for loop example - 9\nJava for loop example - 10\nJava for each example - 1\nJava for each example - 2\nJava for each example - 3\nJava for each example - 4\nJava for each example - 5\nJava for each loop with collection - Apple\nJava for each loop with collection - Banana\nJava for each loop with collection - Orange\nArray has no negative elements: [0, 3]\nArray has no negative elements: [9, 2, 5]\nArray has no negative elements: [1, 2, 5]\nFind array which contains element larger than 7: [9, 2, 5]\n</code></pre>"},{"location":"java-core/java-core-basic/#while-loop","title":"while loop","text":"<pre><code>// while loop\nint i = 6;\nwhile (i &lt;= 10) {\n    System.out.println(i);\n    i++;\n}\n\n// while loop with Iterator\nList&lt;String&gt; veggies = new ArrayList&lt;&gt;();\nveggies.add(\"Spinach\");\nveggies.add(\"Potato\");\nveggies.add(\"Tomato\");\n\nIterator&lt;String&gt; it = veggies.iterator();\n\nwhile(it.hasNext()) {\n    System.out.println(it.next());\n}\n\n// infinite loop\nwhile(true) {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    SimpleDateFormat sdf = new SimpleDateFormat(\"MMM dd,yyyy HH:mm:ss\");\n    Date current = new Date(System.currentTimeMillis());\n    System.out.println(sdf.format(current));\n}\n</code></pre> <p>Output.</p> <pre><code>6\n7\n8\n9\n10\nSpinach\nPotato\nTomato\nApr 01,2019 13:52:25\nApr 01,2019 13:52:26\nApr 01,2019 13:52:27\nApr 01,2019 13:52:28\nApr 01,2019 13:52:29\nApr 01,2019 13:52:30\n...\n</code></pre>"},{"location":"java-core/java-core-basic/#do-while-loop","title":"do while loop","text":"<pre><code>// do while loop\nint i = 6;\ndo {\n    System.out.println(i);\n    i++;\n} while (i &lt;= 10);\n\n// infinite loop\ndo {\n    try {\n        Thread.sleep(1000);\n    } catch (InterruptedException e) {\n        e.printStackTrace();\n    }\n    SimpleDateFormat sdf = new SimpleDateFormat(\"MMM dd,yyyy HH:mm:ss\");\n    Date current = new Date(System.currentTimeMillis());\n    System.out.println(sdf.format(current));\n} while(true);\n</code></pre> <p>Output.</p> <pre><code>6\n7\n8\n9\n10\nApr 01,2019 14:01:06\nApr 01,2019 14:01:07\nApr 01,2019 14:01:08\nApr 01,2019 14:01:09\nApr 01,2019 14:01:10\n</code></pre>"},{"location":"java-core/java-core-basic/#do-while-vs-while-loop","title":"do while vs while loop","text":"<p>The only time you should use <code>do while</code> loop is when you want to execute the statements inside loop <code>at least once</code>, even though condition expression returns false. Otherwise it\u2019s always better to use while loop.</p>"},{"location":"java-core/java-core-basic/#static-keyword","title":"Static Keyword","text":"<p>static keyword usage.</p> <ul> <li>static variable</li> <li>static methods</li> <li>static block</li> <li>static inner class</li> <li>Interface static method</li> </ul> <p>Example.</p> <pre><code>public class StaticKeywordExample {\n    public static void main(String[] args) {\n        StaticExample.setCount(5);\n\n        //non-private static variables can be accessed with class name\n        StaticExample.str = \"abc\";\n        StaticExample se = new StaticExample();\n        System.out.println(se.getCount());\n\n        //class and instance static variables are same\n        System.out.println(StaticExample.str + \" is same as \" + se.str);\n        System.out.println(StaticExample.str == se.str);\n\n        //static nested classes are like normal top-level classes\n        StaticExample.MyStaticClass myStaticClass1 = new StaticExample.MyStaticClass();\n        myStaticClass1.count = 10;\n\n        StaticExample.MyStaticClass myStaticClass2 = new StaticExample.MyStaticClass();\n        myStaticClass2.count = 20;\n\n        System.out.println(myStaticClass1.count);\n        System.out.println(myStaticClass2.count);\n    }\n}\n\nclass StaticExample {\n    //static block\n    static {\n        //can be used to initialize resources when class is loaded\n        System.out.println(\"StaticExample static block\");\n        //can access only static variables and methods\n        str = \"Test\";\n        setCount(2);\n    }\n\n    //multiple static blocks in same class\n    static{\n        System.out.println(\"StaticExample static block2\");\n    }\n\n    //static variable example\n    private static int count; //kept private to control its value through setter\n    public static String str;\n\n    // instance method\n    public int getCount() {\n        return count;\n    }\n\n    //static method example\n    public static void setCount(int count) {\n        if (count &gt; 0)\n            StaticExample.count = count;\n    }\n\n    //static util method\n    public static int addInts(int i, int...js){\n        int sum = i;\n        for (int x : js) {\n            sum += x;\n        }\n        return sum;\n    }\n\n    //static class example - used for packaging convenience only\n    public static class MyStaticClass{\n        public int count;\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-basic/#string-and-character","title":"String and Character","text":""},{"location":"java-core/java-core-basic/#string","title":"String","text":"<p>Common operations on String.</p> <ul> <li>Creation</li> <li>Concatenation</li> <li>Comparison</li> <li>Conversion</li> <li>Substring</li> <li>Replacement</li> </ul> <pre><code>// String creation\nString s1 = \"java\";                                  // s1 = \"java\"\nString s2 = new String(\"java\");                      // s2 = \"java\"\nString s3 = new String(new char[]{'j','a','v','a'}); // s3 = \"java\", created by char array\nString s4 = String.valueOf(5);                       // s4 = \"5\", created by int\n\n// concatenate strings\nString s10 = \"hello\";\nString s11 = \"123\";\nString s12 = s10 + s11;                                // s12 = \"hello123\";\n\n// String comparison\nString str1 = \"java\";                                  // str1 is stored in String Pool\nString str2 = \"java\";                                  // str2 is stored in String Pool\nString str3 = new String(\"java\");                      // str3 is created locally, it is not in String Pool\nString str4 = new String(new char[]{'j','a','v','a'}); // str4 = \"java\"\nSystem.out.println(str1 == str2);                      // true, both are from String Pool, same object\nSystem.out.println(str1.equals(str2));                 // true\nSystem.out.println(str1 == str3);                      // false, str3 is created with new keyword\nSystem.out.println(str1.equals(str3));                 // true\nSystem.out.println(str1 == str4);                      // false, str4 is created with new keyword\nSystem.out.println(str1.equals(str4));                 // true\n\n// Substring\nString s = \"hello, world\";\nString substring = s.substring(0, 5);             // substring = \"hello\"\nSystem.out.println(substring);\nCharSequence subSequence = s.subSequence(0, 5);   // subSequence = \"hello\"\nSystem.out.println(subSequence);\n\n// Split string to string array\nString sentence = \"I am a software engineer\";\nString[] array = sentence.split(\" \");      // array = {\"I\", \"am\", \"a\", \"software\", \"engineer\"}\n\n// Split string with regex\nString a = \"1+2i\";\nString[] x = a.split(\"\\\\+|i\");             // x = {\"1\", \"2\"};\nSystem.out.println(Arrays.toString(x));\n\nString b = \"1+2i3\";\nString[] y = b.split(\"\\\\+|i\");             // y = {\"1\", \"2\", \"3\"};\nSystem.out.println(Arrays.toString(y));\n\n// Replace string\nString strA = \"hello, world\";\nstrA = strA.replaceAll(\"o\",\"tt\");          // strA = \"helltt, wttld\";\nSystem.out.println(strA);\n\n// Convert string to upper case\nString strB = \"Hello, World!\";\nstrB = strB.toUpperCase();                 // strB = \"HELLO, WORLD!\"\nSystem.out.println(strB);\n\n// Convert string to lower case\nString strC = \"Hello, World!\";\nstrC = strC.toLowerCase();                 // strC = \"hello, world!\"\nSystem.out.println(strC);\n\n// intern()\nString strAA = \"intern\";\nString strBB = new String(\"intern\");\nSystem.out.println(strAA == strBB);                    // false, strBB is created with new keyword\nSystem.out.println(strAA.equals(strBB));               // true\n\n// get the string from String Poll\nString strCC = strBB.intern();                         // strCC is fetched from String Pool\nSystem.out.println(strAA == strCC);                    // true, strCC is strAA\nSystem.out.println(strAA.equals(strCC));               // true\n</code></pre>"},{"location":"java-core/java-core-basic/#stringbuilder","title":"StringBuilder","text":"<p>StringBuilder is mainly used to concatenate strings, as it has better performance than String.</p> <pre><code>// StringBuilder creation\nStringBuilder sb1 = new StringBuilder();\nStringBuilder sb2 = new StringBuilder(20);     // Set capacity\nStringBuilder sb3 = new StringBuilder(\"Hello, world!\"); // Creation with initial value\n\nStringBuilder sb = new StringBuilder(\"Have\");\n// append\nsb.append(\" a\");\nsb.append(\" nice\");\nsb.append(\" day!\");\nSystem.out.println(sb); // sb.toString() = \"Have a nice day!\"\nsb.append(1);\nsb.append(2);\nsb.append(3);\nSystem.out.println(sb); // sb.toString() = \"Have a nice day!123\"\n\n// insert\nsb.insert(0, \"Johnny, \");\nSystem.out.println(sb); // sb.toString() = \"Johnny, Have a nice day!123\"\n\n// replace\nsb.replace(8, 12, \"have\"); // change H to lower case\nSystem.out.println(sb); // sb.toString() = \"Johnny, have a nice day!123\"\n\n// delete\nsb.delete(sb.length() - 2, sb.length());\nSystem.out.println(sb); // sb.toString() = \"Johnny, have a nice day!1\"\n\n// Delete last character\nsb.setLength(sb.length() - 1);\nSystem.out.println(sb); // sb.toString() = \"Johnny, have a nice day!\"\n\n// reverse\nsb.reverse();\nSystem.out.println(sb); // sb.toString() = \"!yad ecin a evah ,ynnhoJ\"\n\n// convert to String\nString str = sb.toString();\nSystem.out.println(str); // str = \"!yad ecin a evah ,ynnhoJ\";\n</code></pre>"},{"location":"java-core/java-core-basic/#stringbuffer","title":"StringBuffer","text":"<p>StringBuffer is mainly used to concatenate strings, as it has better performance than String.</p> <pre><code>// StringBuffer creation\nStringBuffer sb1 = new StringBuffer();\nStringBuffer sb2 = new StringBuffer(20);     // Set capacity\nStringBuffer sb3 = new StringBuffer(\"Hello, world!\"); // Creation with initial value\n\nStringBuffer sb = new StringBuffer(\"Have\");\n// append\nsb.append(\" a\");\nsb.append(\" nice\");\nsb.append(\" day!\");\nSystem.out.println(sb); // sb.toString() = \"Have a nice day!\"\nsb.append(1);\nsb.append(2);\nsb.append(3);\nSystem.out.println(sb); // sb.toString() = \"Have a nice day!123\"\n\n// insert\nsb.insert(0, \"Johnny, \");\nSystem.out.println(sb); // sb.toString() = \"Johnny, Have a nice day!123\"\n\n// replace\nsb.replace(8, 12, \"have\"); // change H to lower case\nSystem.out.println(sb); // sb.toString() = \"Johnny, have a nice day!123\"\n\n// delete\nsb.delete(sb.length() - 2, sb.length());\nSystem.out.println(sb); // sb.toString() = \"Johnny, have a nice day!1\"\n\n// Delete last character\nsb.setLength(sb.length() - 1);\nSystem.out.println(sb); // sb.toString() = \"Johnny, have a nice day!\"\n\n// reverse\nsb.reverse();\nSystem.out.println(sb); // sb.toString() = \"!yad ecin a evah ,ynnhoJ\"\n\n// convert to String\nString str = sb.toString();\nSystem.out.println(str); // str = \"!yad ecin a evah ,ynnhoJ\";\n</code></pre>"},{"location":"java-core/java-core-basic/#string-vs-stringbuilder-vs-stringbuffer","title":"String vs StringBuilder vs StringBuffer","text":"Feature String StringBuilder StringBuffer mutable No Yes Yes thread-safe Yes No Yes"},{"location":"java-core/java-core-basic/#charsequence","title":"CharSequence","text":"<p>CharSequence is an <code>interface</code> that represents a sequence of characters. String, StringBuilder and StringBuffer are all its implementations.</p> <pre><code>// CharSequence creation, instantiated by implementation class(String, StringBuffer or  StringBuilder)\nCharSequence string = \"hello, String!\";\nCharSequence stringbuffer = new StringBuffer(\"hello, StringBuffer!\");\nCharSequence stringbuilder = new StringBuilder(\"hello, StringBuilder!\");\n\n// Comparison\nCharSequence cs1 = \"java\";                      // created by String, fetched from String Pool\nString str1 = \"java\";                           // fetched from String Pool\nStringBuilder sb1 = new StringBuilder(\"java\");\nStringBuffer sb2 = new StringBuffer(\"java\");\nSystem.out.println(cs1 == str1);                // true, since they are both from String Pool\nSystem.out.println(cs1.equals(str1));           // true, their values are same\nSystem.out.println(cs1.equals(sb1));            // false\nSystem.out.println(cs1.equals(sb1.toString())); // true\nSystem.out.println(cs1.equals(sb2));            // false\nSystem.out.println(cs1.equals(sb2.toString())); // true\n\nCharSequence cs2 = new String(\"java\");          // new string object, not in String Pool\nSystem.out.println(cs2 == str1);                // false\nSystem.out.println(cs2.equals(str1));           // true\n</code></pre> <p>Note, whether the object created by CharSequence is equal to other strings depends on how this object is created. If we know which class instantiated these objects, it is easy to apply the comparison rules.</p>"},{"location":"java-core/java-core-basic/#character","title":"Character","text":"<pre><code>// get integer value from char\nString s = \"ab5d\";\nint x = Character.getNumericValue(s.charAt(2)); // x = 5\n// check if character is number(one single character)\nCharacter.isDigit(c);\n// same as\nif (c &gt;= '0' &amp;&amp; c &lt;= '9') {\n\n}\n// check if character is number or letter\nCharacter.isLetterOrDigit(c);\n// same as\nif (c &gt;= '0' &amp;&amp; c &lt;= '9' || c &gt;= 'a' &amp;&amp; c &lt;= 'z' || c &gt;= 'A' &amp;&amp; c &lt;= 'Z') {\n\n}\n</code></pre>"},{"location":"java-core/java-core-basic/#bit-manipulation","title":"Bit Manipulation","text":"<pre><code>// flip bit with XOR, change 1 to 0 and change 0 to 1.\nint bit = 0;\nbit = bit ^ 1; // bit = 1;\nbit = bit ^ 1; // bit = 0;\n// find the complement of the give number\nint num = 10;  // 1010\nint mask = 15; // 1111\nint result = num ^ mask;  // result = 5, 0101\n\n// power\nint left = 3;\nint pow = 1 &lt;&lt; left; // pow = 8, 1000\n\n// shift\nint num = 5;\n// get the value of last bit\nint last = num &amp; 1; // last = 1\n// right shift\nnum &gt;&gt; 1; // return 2, 101 -&gt; 10\n// left shift\nnum &lt;&lt; 1: // return 10, 101 -&gt; 1010\n\n// number of one-bits\nint n = 177   // in binary format: 10110001\nint count = 0;\nwhile (n &gt; 0) {\n    if (n &amp; 1) {\n        count++;\n    }\n    n = n &gt;&gt; 1;\n}\nreturn count; // count = 4;\n\n// or use built-in method\nInteger.bitCount(177); // return 4\n</code></pre>"},{"location":"java-core/java-core-basic/#array-and-collections","title":"Array and Collections","text":""},{"location":"java-core/java-core-basic/#array-and-list","title":"Array and List","text":"<pre><code>// create empty array\nint[] nums = new int[]{};\nString[] strs = new String[]{};\n// create array with length = 3\nint[] nums = new int[3];\nString[] strs = new String[3];\n// create char array from string\nString s = \"hello\";\nchar[] chs = s.toCharArray(); // chs = {'h','e','l','l','o'};\n\n// create list\nList&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\nList&lt;String&gt; list2 = new ArrayList&lt;&gt;();\n// create list with array\nint[] nums = new int[]{1,2,3};\nList&lt;Integer&gt; list = Arrays.asList(nums); // list = {1,2,3}\n\n// loop\nfor (int i = 0; i &lt; nums.length; i++) {\n    int num = nums[i];\n}\n// or\nfor (int num : nums) {\n\n}\n\n// Sort array\nint[] nums = {3, 7, 6, 5, 9, 2};\nArrays.sort(nums);  // nums = {2,3,5,6,7,9};\n\n// Sort collection\nList&lt;String&gt; list = new ArrayList&lt;String&gt;();\nlist.add(\"orange\");\nlist.add(\"apple\");\nlist.add(\"banana\");\nCollections.sort(list); // list = {\"apple\", \"banana\", \"orange\"}\n\n// Binary search on sorted array or collection\nint index1 = Arrays.binarySearch(new char[]{'c','d','e','f','g'}, 'f');  // index1 = 3;\nint index2 = Arrays.binarySearch(new int[]{10,15,20,22,35}, 20); // index2 = 2;\nint index3 = Collections.binarySearch(Arrays.asList(new Integer[] {10,15,20,22,35}), 15); // index3 = 1;\n\n// Binary search on array\nint[] array = {10,15,20,22,35};\nint index1 = Arrays.binarySearch(array,20); // index1 = 2\nint index2 = Arrays.binarySearch(array,8);  // index2 = -1, (-insertion point) - 1\nint index3 = Arrays.binarySearch(array,40); // index3 = -6, (-insertion point) - 1\n\n// Binary search on collection\nList list = new ArrayList&lt;&gt;(Arrays.asList(new Integer[]{10,20,15,22,35}));\nint index1 = Collections.binarySearch(list,20); // index1 = 2\nint index2 = Collections.binarySearch(list,8);  // index2 = -1, (-insertion point) - 1\nint index3 = Collections.binarySearch(list,40); // index3 = -6, (-insertion point) - 1\n\n// print Array\nint[] nums = {1,3,5,7};\nSystem.out.println(Arrays.toString(nums)); // print [1,3,5,7]\n</code></pre>"},{"location":"java-core/java-core-basic/#hashset-hashmap-treemap","title":"HashSet, HashMap, TreeMap","text":"<pre><code>// create HashSet\nSet&lt;String&gt; set = new HashSet&lt;&gt;();\nSet&lt;Integer&gt; set = new HashSet&lt;&gt;();\n// initialize HashSet with List\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nSet&lt;Integer&gt; set = new HashSet&lt;&gt;(list); // set = {1,2}\n// initialize HashSet with array\nint[] nums = new int[]{1,2,3};\nSet&lt;Integer&gt; set = new HashSet&lt;&gt;(Arrays.asList(nums)); // set = {1,2,3}\n// create HashMap, key-value pair\nMap&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();\nMap&lt;Integer, String&gt; map = new HashMap&lt;&gt;();\n\n// remove duplicated elements in list\nList&lt;Integer&gt; list = new ArrayList&lt;&gt;();\nlist.add(1);\nlist.add(2);\nlist.add(1); // duplicate element\nSet&lt;Integer&gt; set = new HashSet&lt;&gt;(list); // set = {1,2}\nlist.clear();\nlist.addAll(set); // list = {1,2}\n\nTreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;&gt;();\ntreeMap.put(1, \"Monday\")\ntreeMap.put(2, \"Tuesday\")\ntreeMap.put(3, \"Wednesday\")\ntreeMap.put(4, \"Thursday\")\ntreeMap.put(5, \"Friday\")\nString day = treeMap.get(3); // day = \"Wednesday\"\nInteger lowKey = treeMap.lowerKey(3); // lowKey = 2\nInteger highKey = treeMap.higherKey(3); // lowKey = 4\nMap.Entry&lt;Integer, String&gt; lowEntry = treeMap.lowerEntry(3); // lowEntry = &lt;3, Wednesday&gt;\nMap.Entry&lt;Integer, String&gt; highEntry = treeMap.higherEntry(3); // lowEntry = &lt;4, Thursday&gt;\n</code></pre>"},{"location":"java-core/java-core-basic/#stack-and-queue","title":"Stack and Queue","text":"<pre><code>// create stack\nStack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n// create queue\nQueue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n// create Deque\nDeque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n\n// Loop elements in queue\nQueue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\nint sum = 0;\nfor (int i: queue) {\n    sum = sum + i;\n}\n</code></pre>"},{"location":"java-core/java-core-basic/#heap","title":"Heap","text":"<pre><code>// create min heap\nPriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();\n// create max heap\nPriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;&gt;((a,b)-&gt;b-a);\n</code></pre>"},{"location":"java-core/java-core-basic/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Core Basic on GitHub</li> </ul>"},{"location":"java-core/java-core-basic/#references","title":"References","text":"<ul> <li>Java Doc - Controlling Access to Members of a Class</li> <li>Core Java Tutorial</li> <li>Java Data Types</li> <li>Primitive Wrapper Classes are Immutable in Java</li> <li>Java Arrays</li> </ul>"},{"location":"java-core/java-core-bitset/","title":"BitSet","text":"<p>The <code>BitSet</code> class creates a special type of array that holds bit values. The BitSet array can increase in size as needed.</p> <p>Common Methods:</p> <ul> <li><code>and(BitSet bitSet)</code>: ANDs the contents of the invoking BitSet object with those specified by bitSet. The result is placed into the invoking object.</li> <li><code>or(BitSet bitSet)</code>: ORs the contents of the invoking BitSet object with that specified by bitSet. The result is placed into the invoking object.</li> <li><code>xor(BitSet bitSet)</code>: XORs the contents of the invoking BitSet object with that specified by bitSet. The result is placed into the invoking object.</li> <li><code>get(int index)</code>: Returns the current state of the bit at the specified index.</li> <li><code>set(int index)</code>: Sets the bit specified by index.</li> <li><code>size()</code>: Returns the number of bits in the invoking BitSet object.</li> <li><code>length()</code>: Returns the number of bits required to hold the contents of the invoking BitSet. This value is determined by the location of the last 1 bit.</li> <li><code>isEmpty()</code>: Returns true if all bits in the invoking object are zero.</li> <li><code>clear()</code>: Zeros all bits.</li> <li><code>nextClearBit(int startIndex)</code>: Returns the index of the next cleared bit, (that is, the next zero bit), starting from the index specified by startIndex.</li> <li><code>nextSetBit(int startIndex)</code>: Returns the index of the next set bit (that is, the next 1 bit), starting from the index specified by startIndex. If no bit is set, -1 is returned.</li> </ul>"},{"location":"java-core/java-core-bitset/#example","title":"Example","text":"<pre><code>import java.util.BitSet;\n\npublic class BitSetExample {\n    public static void main(String args[]) {\n        BitSet bits1 = new BitSet(16);\n        BitSet bits2 = new BitSet(16);\n\n        // set some bits\n        for (int i = 0; i &lt; 16; i++) {\n            if ((i % 2) == 0) {\n                bits1.set(i);\n            }\n            if ((i % 5) != 0) {\n                bits2.set(i);\n            }\n        }\n\n        System.out.println(\"Initial pattern in bits1: \" + bits1); // {0, 2, 4, 6, 8, 10, 12, 14}\n        System.out.println(\"Initial pattern in bits2: \" + bits2); // {1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14}\n        // bits1 = [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]\n        // bits2 = [0,1,1,1,1,0,1,1,1,1,0,1,1,1,1,0]\n\n        // AND bits\n        bits2.and(bits1);\n        System.out.println(\"bits2 AND bits1: \" + bits2); // {2, 4, 6, 8, 12, 14}\n        // bits1 = [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]\n        // bits2 = [0,0,1,0,1,0,1,0,1,0,0,0,1,0,1,0]\n\n        // OR bits\n        bits2.or(bits1);\n        System.out.println(\"bits2 OR bits1:  \" + bits2); // {0, 2, 4, 6, 8, 10, 12, 14}\n        // bits1 = [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]\n        // bits2 = [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]\n\n        // XOR bits\n        bits2.xor(bits1);\n        System.out.println(\"bits2 XOR bits1: \" + bits2); // {}\n        // bits1 = [1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0]\n        // bits2 = [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]\n\n        System.out.println(\"bits1's state: \" + convert(bits1, 16)); // 1010101010101010\n        System.out.println(\"bits2's state: \" + convert(bits2, 16)); // 0000000000000000\n\n        // Cardinality\n        System.out.println(\"bits1's cardinality: \" + bits1.cardinality()); // 8\n        System.out.println(\"bits2's cardinality: \" + bits2.cardinality()); // 0\n\n        // Get\n        System.out.println(\"The state of index 2 in bits1 is: \" + bits1.get(2)); // 8\n        System.out.println(\"The state of index 2 in bits2 is: \" + bits2.get(2)); // 8\n\n        // Size\n        System.out.println(\"bits1's size: \" + bits1.size()); // 64\n        System.out.println(\"bits2's size: \" + bits2.size()); // 64\n\n        // Length\n        System.out.println(\"bits1's length: \" + bits1.length()); // 15\n        System.out.println(\"bits2's length: \" + bits2.length()); // 0\n\n        // isEmpty\n        System.out.println(\"Is bits1 empty? \" + bits1.isEmpty()); // false\n        System.out.println(\"Is bits2 empty? \" + bits2.isEmpty()); // true\n\n        // nextClearBit\n        System.out.println(\"The next zero bit for index 2 of bits1? \" + bits1.nextClearBit(2)); // 3\n        System.out.println(\"The next zero bit for index 2 of bits2? \" + bits2.nextClearBit(2)); // 2\n\n        // nextSetBit\n        System.out.println(\"The next one bit for index 2 of bits1? \" + bits1.nextSetBit(2)); // 2\n        System.out.println(\"The next one bit for index 2 of bits2? \" + bits2.nextSetBit(2)); // -1\n    }\n\n    public static String convert(BitSet bits, int length) {\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i &lt; length; ++i) {\n            sb.append(bits.get(i) ? \"1\": \"0\");\n        }\n        return sb.toString();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Initial pattern in bits1: {0, 2, 4, 6, 8, 10, 12, 14}\nInitial pattern in bits2: {1, 2, 3, 4, 6, 7, 8, 9, 11, 12, 13, 14}\nbits2 AND bits1: {2, 4, 6, 8, 12, 14}\nbits2 OR bits1:  {0, 2, 4, 6, 8, 10, 12, 14}\nbits2 XOR bits1: {}\nbits1's state: 1010101010101010\nbits2's state: 0000000000000000\nbits1's cardinality: 8\nbits2's cardinality: 0\nThe state of index 2 in bits1 is: true\nThe state of index 2 in bits2 is: false\nbits1's size: 64\nbits2's size: 64\nbits1's length: 15\nbits2's length: 0\nIs bits1 empty? false\nIs bits2 empty? true\nThe next zero bit for index 2 of bits1? 3\nThe next zero bit for index 2 of bits2? 2\nThe next one bit for index 2 of bits1? 2\nThe next one bit for index 2 of bits2? -1\n</code></pre>"},{"location":"java-core/java-core-bitset/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java BitSet on GitHub</li> </ul>"},{"location":"java-core/java-core-bitset/#references","title":"References","text":"<ul> <li>Java - The BitSet Class</li> </ul>"},{"location":"java-core/java-core-collection/","title":"Collection","text":"<p>Commonly used collection classes. Usage of different collection objects, including list, set, map, thread-safe collection objects.</p> Collection Ordering Random Access KeyValue Duplicate Elements Null Element Thread Safety ArrayList Yes Yes No Yes Yes No LinkedList Yes No No Yes Yes No HashSet No No No No Yes No TreeSet Yes No No No No No HashMap No Yes Yes No Yes No TreeMap Yes Yes Yes No No No Vector Yes Yes No Yes Yes Yes HashTable No Yes Yes No No Yes Properties No Yes Yes No No Yes Stack Yes No No Yes Yes Yes CopyOnWriteArrayList Yes Yes No Yes Yes Yes ConcurrentHashMap No Yes Yes No Yes Yes CopyOnWriteArraySet No No No No Yes Yes"},{"location":"java-core/java-core-collection/#arraylist","title":"ArrayList","text":""},{"location":"java-core/java-core-collection/#constructor","title":"Constructor","text":"<p>There are three constructors in Java ArrayList class.</p> <ul> <li>public ArrayList()</li> <li>public ArrayList(int initialCapacity)</li> <li>public ArrayList(Collection&lt;? extends E&gt; c)</li> </ul> <pre><code>private static void constructList() {\n    // no arguments\n    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\n    list1.add(5);\n    list1.add(9);\n    list1.add(4);\n    list1.add(2);\n    System.out.println(\"Construct list: \" + list1);\n\n    // with another list\n    List&lt;Integer&gt; list2 = new ArrayList&lt;&gt;(list1);\n    System.out.println(\"Construct list with another list: \" + list2);\n\n    // with treeset\n    SortedSet&lt;Integer&gt; treeSet1 = new TreeSet&lt;&gt;(list1);\n    List&lt;Integer&gt; list3 = new ArrayList&lt;&gt;(treeSet1);\n    System.out.println(\"Construct list with tree set: \" + list3);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct list: [5, 9, 4, 2]\nConstruct list with another list: [5, 9, 4, 2]\nConstruct list with tree set: [2, 4, 5, 9]\n</code></pre>"},{"location":"java-core/java-core-collection/#common-operations","title":"Common Operations","text":"<ul> <li>list.add(item);</li> <li>list.add(0, item);</li> <li>list.remove(index);</li> <li>list.subList(index1, index2);</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // add\n    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\n    for (int i = 0; i &lt; 9; i++) {\n        list1.add(i);\n    }\n    System.out.println(\"Common operations - add : \" + list1);\n\n    // insert\n    list1.add(0, 12);\n    System.out.println(\"Insert 12 at index 0 : \" + list1);\n    list1.add(5, 9);\n    System.out.println(\"Insert 9 at index 5 : \" + list1);\n\n    // remove\n    list1.remove(0);\n    System.out.println(\"Remove element which is at index 0 : \" + list1);\n\n    // get\n    System.out.println(\"Get element which is at index 3 : \" + list1.get(3));\n\n    // sub list\n    List&lt;Integer&gt; list2 = list1.subList(2, 4);\n    System.out.println(\"Sub list from index 2(inclusive) to index 4(exclusive) : \" + list2);\n}\n</code></pre> <p>Output.</p> <pre><code>Common operations - add : [0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 12 at index 0 : [12, 0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 9 at index 5 : [12, 0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nRemove element which is at index 0 : [0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nGet element which is at index 3 : 3\nSub list from index 2(inclusive) to index 4(exclusive) : [2, 3]\n</code></pre>"},{"location":"java-core/java-core-collection/#sorting","title":"Sorting","text":"<pre><code>private static void sortList() {\n    // Sorting\n    List&lt;Integer&gt; list1 = new ArrayList&lt;&gt;();\n    list1.add(3);\n    list1.add(1);\n    list1.add(2);\n    Collections.sort(list1);                // ascending order, list1 = {1,2,3}\n    System.out.println(\"Sort list in ascending order: \" + list1);\n    Collections.sort(list1, (a,b)-&gt;(b-a));  // descending order, list1 = {3,2,1}\n    System.out.println(\"Sort list in descending order: \" + list1);\n}\n</code></pre> <p>Output.</p> <pre><code>Sort list in ascending order: [1, 2, 3]\nSort list in descending order: [3, 2, 1]\n</code></pre>"},{"location":"java-core/java-core-collection/#traversal","title":"Traversal","text":"<p>There are three ways to traverse a list.</p> <ul> <li>basic for</li> <li>for each</li> <li>iterator</li> </ul> <pre><code>private static void traverseList() {\n    List&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // basic for\n    for (int i = 0; i &lt; fruits.size(); i++) {\n        System.out.println(\"Traverse List(basic for): processing - \" + fruits.get(i));\n    }\n\n    System.out.println();\n\n    // for each\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // iterator\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()) {\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse List(basic for): processing - Apple\nTraverse List(basic for): processing - Banana\nTraverse List(basic for): processing - Orange\nTraverse List(basic for): processing - Watermelon\nTraverse List(basic for): processing - Kiwi\n\nTraverse List(for each): processing - Apple\nTraverse List(for each): processing - Banana\nTraverse List(for each): processing - Orange\nTraverse List(for each): processing - Watermelon\nTraverse List(for each): processing - Kiwi\n\nTraverse List(iterator): processing - Apple\nTraverse List(iterator): processing - Banana\nTraverse List(iterator): processing - Orange\nTraverse List(iterator): processing - Watermelon\nTraverse List(iterator): processing - Kiwi\n</code></pre>"},{"location":"java-core/java-core-collection/#remove-element","title":"Remove Element","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>List.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    List&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // in for each loop\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n\n        if (\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits list after iteration = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    List&lt;String&gt; fruits = new ArrayList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Remove element: processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            iterator.remove();  // iterator.remove not list.remove\n        }\n    }\n\n    System.out.println(\"Fruits list after deletion = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - Apple\nRemove element: processing - Banana\nRemove element: processing - Orange\nRemove element: processing - Watermelon\nRemove element: processing - Kiwi\nFruits list after deletion = [Apple, Banana, Watermelon, Kiwi]\n</code></pre>"},{"location":"java-core/java-core-collection/#linkedlist","title":"LinkedList","text":""},{"location":"java-core/java-core-collection/#constructor-of-linkedlist","title":"Constructor of LinkedList","text":"<p>There are two constructors in Java LinkedList class.</p> <ul> <li>public LinkedList()</li> <li>public LinkedList(Collection&lt;? extends E&gt; c)</li> </ul> <pre><code>private static void constructList() {\n    // no arguments\n    List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();\n    list1.add(5);\n    list1.add(9);\n    list1.add(4);\n    list1.add(4);\n    list1.add(2);\n    System.out.println(\"Construct list: \" + list1);\n\n    // with another list\n    List&lt;Integer&gt; list2 = new LinkedList&lt;&gt;(list1);\n    System.out.println(\"Construct list with another list: \" + list2);\n\n    // with treeset\n    SortedSet&lt;Integer&gt; treeSet1 = new TreeSet&lt;&gt;(list1);\n    List&lt;Integer&gt; list3 = new LinkedList&lt;&gt;(treeSet1);\n    System.out.println(\"Construct list with tree set: \" + list3);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct list: [5, 9, 4, 4, 2]\nConstruct list with another list: [5, 9, 4, 4, 2]\nConstruct list with tree set: [2, 4, 5, 9]\n</code></pre>"},{"location":"java-core/java-core-collection/#common-operations-of-linkedlist","title":"Common Operations of LinkedList","text":"<ul> <li>list.add(item);</li> <li>list.add(0, item);</li> <li>list.remove(index);</li> <li>list.subList(index1, index2);</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // add\n    List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();\n    for (int i = 0; i &lt; 9; i++) {\n        list1.add(i);\n    }\n    System.out.println(\"Common operations - add : \" + list1);\n\n    // insert\n    list1.add(0, 12);\n    System.out.println(\"Insert 12 at index 0 : \" + list1);\n    list1.add(5, 9);\n    System.out.println(\"Insert 9 at index 5 : \" + list1);\n\n    // remove\n    list1.remove(0);\n    System.out.println(\"Remove element which is at index 0 : \" + list1);\n\n    // sub list\n    List&lt;Integer&gt; list2 = list1.subList(2, 4);\n    System.out.println(\"Sub list from index 2(inclusive) to index 4(exclusive) : \" + list2);\n}\n</code></pre> <p>Output.</p> <pre><code>Common operations - add : [0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 12 at index 0 : [12, 0, 1, 2, 3, 4, 5, 6, 7, 8]\nInsert 9 at index 5 : [12, 0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nRemove element which is at index 0 : [0, 1, 2, 3, 9, 4, 5, 6, 7, 8]\nSub list from index 2(inclusive) to index 4(exclusive) : [2, 3]\n</code></pre>"},{"location":"java-core/java-core-collection/#sorting-of-linkedlist","title":"Sorting of LinkedList","text":"<pre><code>private static void sortList() {\n    // Sorting\n    List&lt;Integer&gt; list1 = new LinkedList&lt;&gt;();\n    list1.add(3);\n    list1.add(1);\n    list1.add(2);\n\n    Collections.sort(list1);                // ascending order, list1 = {1,2,3}\n    System.out.println(\"Sort list in ascending order: \" + list1);\n    Collections.sort(list1, (a,b)-&gt;(b-a));  // descending order, list1 = {3,2,1}\n    System.out.println(\"Sort list in descending order: \" + list1);\n}\n</code></pre> <p>Output.</p> <pre><code>Sort list in ascending order: [1, 2, 3]\nSort list in descending order: [3, 2, 1]\n</code></pre>"},{"location":"java-core/java-core-collection/#traversal-of-linkedlist","title":"Traversal of LinkedList","text":"<p>There are two ways to traverse a list.</p> <ul> <li>for each</li> <li>iterator</li> </ul> <pre><code>private static void traverseList() {\n    List&lt;String&gt; fruits = new LinkedList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // for each\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // iterator\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()) {\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse List(for each): processing - Apple\nTraverse List(for each): processing - Banana\nTraverse List(for each): processing - Orange\nTraverse List(for each): processing - Watermelon\nTraverse List(for each): processing - Kiwi\n\nTraverse List(iterator): processing - Apple\nTraverse List(iterator): processing - Banana\nTraverse List(iterator): processing - Orange\nTraverse List(iterator): processing - Watermelon\nTraverse List(iterator): processing - Kiwi\n</code></pre>"},{"location":"java-core/java-core-collection/#remove-element-of-linkedlist","title":"Remove Element of LinkedList","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>List.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    List&lt;String&gt; fruits = new LinkedList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    // in for each loop\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse List(for each): processing - \" + fruit);\n\n        if (\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Traverse List(iterator): processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits list after iteration = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    List&lt;String&gt; fruits = new LinkedList&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Kiwi\");\n\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Remove element: processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            iterator.remove();  // iterator.remove not list.remove\n        }\n    }\n\n    System.out.println(\"Fruits list after deletion = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - Apple\nRemove element: processing - Banana\nRemove element: processing - Orange\nRemove element: processing - Watermelon\nRemove element: processing - Kiwi\nFruits list after deletion = [Apple, Banana, Watermelon, Kiwi]\n</code></pre>"},{"location":"java-core/java-core-collection/#interface","title":"Interface","text":"<p>LinkedList implements three interfaces: List, Queue and Queue.</p> <pre><code>private static void interfaces() {\n    // List Interface, insertion order\n    List&lt;Integer&gt; list = new LinkedList&lt;&gt;();\n    list.add(1);\n    list.add(2);\n    list.add(4);\n    list.forEach(System.out::println);  // print 1,2,4\n\n    // Queue interface, FIFO\n    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();\n    queue.offer(1);\n    queue.offer(2);\n    queue.offer(3);\n    while (!queue.isEmpty()) {\n        System.out.println(queue.poll());  // print 1,2,3\n    }\n\n    // Deque interface, FIFO or LIFO\n    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n    deque.offerLast(1);  // deque = {1}\n    deque.offerLast(2);  // deque = {1,2}\n    deque.offerFirst(3); // deque = {3, 1, 2}\n    deque.peekFirst();      // return 3\n    deque.peekLast( );      // return 2\n    deque.pollFirst();      // return 3, deque = {1,2}\n    deque.pollLast();       // return 2, deque = {1}\n}\n</code></pre>"},{"location":"java-core/java-core-collection/#set-hashset-sortedset-treeset","title":"Set, HashSet, SortedSet, TreeSet","text":"<p>HashSet.</p> <pre><code>public static void main(String[] args) {\n    Set&lt;String&gt; set = new HashSet&lt;&gt;();\n\n    //initial capacity should be power of 2\n    set = new HashSet&lt;&gt;(32);\n\n    //setting backing HashMap initial capacity and load factor\n    set = new HashSet&lt;&gt;(32, 0.80f);\n\n    //creating HashSet from another Collection\n    Set&lt;String&gt; set1 = new HashSet&lt;&gt;(set);\n    Set&lt;String&gt; set2 = new HashSet&lt;&gt;(new ArrayList&lt;&gt;());\n}\n</code></pre> <p>Traverse set by for each or iterator.</p> <pre><code>private static void traverseSet() {\n    Set&lt;String&gt; fruits = new HashSet&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Mango\");\n\n    // by for each\n    for (String fruit : fruits) {\n        System.out.println(\"Processing - \" + fruit);\n    }\n\n    // by iterator\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()) {\n        String fruit = iterator.next();\n        System.out.println(\"Processing - \" + fruit);\n    }\n}\n</code></pre> <p>Remove element during traverse.</p> <pre><code>private static void correctWayToRemoveElement() {\n    Set&lt;String&gt; fruits = new HashSet&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Mango\");\n\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            iterator.remove(); // iterator.remove not set.remove\n        }\n    }\n\n    System.out.println(\"fruits set after iteration = \" + fruits);\n}\n</code></pre>"},{"location":"java-core/java-core-collection/#references","title":"References","text":"<ul> <li>Java Doc - Controlling Access to Members of a Class</li> <li>Core Java Tutorial</li> <li>Java Data Types</li> <li>Primitive Wrapper Classes are Immutable in Java</li> <li>Collections in Java \u2013 Tutorial</li> </ul>"},{"location":"java-core/java-core-comparable-vs-comparator/","title":"Comparable vs Comparator","text":"<p>Comparable, Comparator and their difference.</p> <p>A comparable object is capable of comparing itself with another object. The class itself must implements the <code>java.lang.Comparable</code> interface to compare its instances.</p> <p>Below is the definition of <code>Comparable</code> Interface.</p> <pre><code>public interface Comparable&lt;T&gt; {\n    public int compareTo(T o); // the only method\n}\n</code></pre> <p>Below is the definition of <code>Comparator</code> Interface.</p> <pre><code>public interface Comparator&lt;T&gt; {\n    int compare(T o1, T o2);\n    // other methods\n}\n</code></pre>"},{"location":"java-core/java-core-comparable-vs-comparator/#example","title":"Example","text":""},{"location":"java-core/java-core-comparable-vs-comparator/#comparable","title":"Comparable","text":"<p>We define a class named Employee.</p> <pre><code>public class Employee {\n    private int id;\n    private String name;\n    private int age;\n    private int salary;\n\n    public Employee(int id, String name, int age, int salary) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n\n    public int getId() {\n        return id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public int getAge() {\n        return age;\n    }\n\n    public int getSalary() {\n        return salary;\n    }\n\n    @Override\n    //this is overridden to print the user-friendly information about the Employee\n    public String toString() {\n        return \"[id=\" + this.id + \", name=\" + this.name + \", age=\" + this.age + \", salary=\" +\n                this.salary + \"]\";\n    }\n}\n</code></pre> <p>Then we use this class to create an employee array and use <code>Arrays.sort()</code> to sort this array.</p> <pre><code>public static void main(String[] args) {\n    // Create object array\n    Employee[] empArr = new Employee[3];\n    empArr[0] = new Employee(10, \"Johnny\", 21, 5000);\n    empArr[1] = new Employee(5, \"George\", 40, 4000);\n    empArr[2] = new Employee(1, \"Terry\", 33, 7000);\n\n    // Sort employee array using Comparable interface implementation\n    Arrays.sort(empArr);\n    System.out.println(\"Sort Employee list with default Comparable interface:\\n\" + Arrays.toString(empArr));\n}\n</code></pre> <p>We will get following error. This is because the <code>Arrays.sort()</code> or <code>Collections.sort()</code> method rely on Comparable interface.</p> <pre><code>Exception in thread \"main\" java.lang.ClassCastException: johnny.java.core.comparator.Employee cannot be cast to java.lang.Comparable\n    at java.util.ComparableTimSort.countRunAndMakeAscending(ComparableTimSort.java:320)\n    at java.util.ComparableTimSort.sort(ComparableTimSort.java:188)\n    at java.util.Arrays.sort(Arrays.java:1246)\n    at johnny.java.compare.CompareTest.main(CompareTest.java:17)\n</code></pre> <p>We need to implement <code>Comparable</code> interface in Employee class by overriding the <code>compareTo</code> method.</p> <pre><code>public class Employee implements Comparable&lt;Employee&gt; {\n    ...\n\n    public Employee(int id, String name, int age, int salary) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n        this.salary = salary;\n    }\n\n    ...\n\n    @Override\n    public int compareTo(Employee emp) {\n        // sort the employee based on id, in ascending order\n        // return negative(less than), zero(equal to), positive(greater than)\n        return (this.id - emp.id);\n    }\n    ...\n}\n</code></pre> <p>Run the test again and we get the following output. Now, we see the employee array is sorted by id in ascending order.</p> <pre><code>Sort employee list with default Comparable interface:\n[[id=1, name=Terry, age=33, salary=7000], [id=5, name=George, age=40, salary=4000], [id=10, name=Johnny, age=21, salary=5000]]\n</code></pre>"},{"location":"java-core/java-core-comparable-vs-comparator/#comparator","title":"Comparator","text":"<p>If we need to sort this array based on different fields, we can use the <code>Comparator</code> interface. We can either create a custom comparator in Employee class, like the following example. AgeComparator is a custom comparator base on age.</p> <pre><code>public class Employee implements Comparable&lt;Employee&gt; {\n    ...\n\n    @Override\n    public int compareTo(Employee emp) {\n        // sort the employee based on id, in ascending order\n        // return negative(less than), zero(equal to), positive(greater than)\n        return (this.id - emp.id);\n    }\n\n    // Compare employee based on age.\n    public static Comparator&lt;Employee&gt; AgeComparator = new Comparator&lt;Employee&gt;() {\n        @Override\n        public int compare(Employee e1, Employee e2) {\n            return e1.getAge() - e2.getAge();\n        }\n    };\n\n    ...\n}\n</code></pre> <p>Or we can create the custom comparator in anywhere. SalaryComparator is a separate class. It compares employee based on salary.</p> <pre><code>import java.util.Comparator;\n\npublic class SalaryComparator implements Comparator&lt;Employee&gt; {\n    @Override\n    public int compare(Employee e1, Employee e2) {\n        return e1.getSalary() - e2.getSalary();\n    }\n}\n</code></pre> <p>When calling the Arrays.sort method, we can provide a custom comparator as second parameter.</p> <pre><code>public static void main(String[] args) {\n    // Create object array\n    Employee[] empArr = new Employee[3];\n    empArr[0] = new Employee(10, \"Johnny\", 21, 5000);\n    empArr[1] = new Employee(5, \"George\", 40, 4000);\n    empArr[2] = new Employee(1, \"Terry\", 33, 7000);\n\n    // Sort employee array using Comparable interface implementation\n    Arrays.sort(empArr);\n    System.out.println(\"Sort employee list with default Comparable interface:\\n\" + Arrays.toString(empArr));\n\n    // Sort employee with custom comparator based on age\n    Arrays.sort(empArr, Employee.AgeComparator);\n    System.out.println(\"Sort employee list with custom Comparator interface(on Age):\\n\" + Arrays.toString(empArr));\n\n    // Sort employee with custom comparator based on salary\n    Arrays.sort(empArr, new SalaryComparator());\n    System.out.println(\"Sort employee list with custom Comparator interface(on Salary):\\n\" + Arrays.toString(empArr));\n}\n</code></pre> <p>See the result. The second array is sorted by age and the third array is sorted by salary.</p> <pre><code>Sort employee list with default Comparable interface:\n[[id=1, name=Terry, age=33, salary=7000], [id=5, name=George, age=40, salary=4000], [id=10, name=Johnny, age=21, salary=5000]]\nSort employee list with custom Comparator interface(on Age):\n[[id=10, name=Johnny, age=21, salary=5000], [id=1, name=Terry, age=33, salary=7000], [id=5, name=George, age=40, salary=4000]]\nSort employee list with custom Comparator interface(on Salary):\n[[id=5, name=George, age=40, salary=4000], [id=10, name=Johnny, age=21, salary=5000], [id=1, name=Terry, age=33, salary=7000]]\n</code></pre>"},{"location":"java-core/java-core-comparable-vs-comparator/#conclusion","title":"Conclusion","text":"<p>Comparable vs Comparator:</p> <ul> <li>Comparable interface can be used to provide <code>single</code> way of sorting whereas Comparator interface is used to provide <code>different</code> ways of sorting.</li> <li>For using Comparable, Class needs to implement it whereas for using Comparator we don\u2019t need to make any change in the class.</li> <li>Comparable interface is in <code>java.lang</code> package whereas Comparator interface is present in <code>java.util</code> package.</li> <li>We don\u2019t need to make any code changes at client side for using Comparable, <code>Arrays.sort()</code> or <code>Collection.sort()</code> methods automatically uses the <code>compareTo()</code> method of the class. For Comparator, client needs to provide the Comparator class to use in compare() method.</li> </ul>"},{"location":"java-core/java-core-comparable-vs-comparator/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Comparable and Comparator on GitHub</li> </ul>"},{"location":"java-core/java-core-comparable-vs-comparator/#references","title":"References","text":"<ul> <li>Comparable and Comparator in Java Example</li> </ul>"},{"location":"java-core/java-core-enum/","title":"Enum","text":"<p>Enum was introduced in Java 1.5 as a new type whose fields consists of a fixed set of constants.</p> <p>Enum example.</p> <pre><code>enum PriorityEnum {\n    LOW,\n    MEDIUM,\n    HIGH\n}\n</code></pre> <p>Usage of enum.</p> <pre><code>private static void enumLoop() {\n    PriorityEnum prt = PriorityEnum.MEDIUM;\n    System.out.println(prt);\n\n    // Enum in a Switch Statement\n    switch (prt) {\n        case LOW:\n            System.out.println(\"Low level\");\n            break;\n        case MEDIUM:\n            System.out.println(\"Medium level\");\n            break;\n        case HIGH:\n            System.out.println(\"High level\");\n            break;\n    }\n\n    // Loop Through an Enum\n    for (PriorityEnum penum : PriorityEnum.values()) {\n        System.out.println(penum);\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-enum/#enum-vs-constants","title":"Enum vs Constants","text":"<p>Create Constants.</p> <pre><code>class PriorityConstant {\n    public static final int LOW = 1;\n    public static final int MEDIUM = 2;\n    public static final int HIGH = 3;\n}\n</code></pre> <p>Example for showing the benefits of Enum over Constants.</p> <pre><code>public static void main(String[] args) {\n    // Compare the difference between Enum and Constant\n    enumVsConstants();\n}\n\nprivate static void enumVsConstants() {\n    //Enum values are fixed\n    enumExample(PriorityEnum.LOW);\n    enumExample(PriorityEnum.MEDIUM);\n    enumExample(PriorityEnum.HIGH);\n    enumExample(null);\n\n    constantsExample(1);\n    constantsExample(2);\n    constantsExample(3);\n    //we can pass any int constant\n    constantsExample(4);\n}\n\nprivate static void enumExample(PriorityEnum p) {\n    if (p == PriorityEnum.LOW) {\n        System.out.println(\"Low level\");\n    } else if (p == PriorityEnum.MEDIUM) {\n        System.out.println(\"Medium level\");\n    } else if (p == PriorityEnum.HIGH) {\n        System.out.println(\"High level\");\n    } else {\n        System.out.println(\"Invalid input!\");\n    }\n}\n\nprivate static void constantsExample(int p) {\n    if (p == PriorityConstant.LOW) {\n        System.out.println(\"Low level\");\n    } else if (p == PriorityConstant.MEDIUM) {\n        System.out.println(\"Medium level\");\n    } else if (p == PriorityConstant.HIGH) {\n        System.out.println(\"High level\");\n    } else {\n        System.out.println(\"Invalid input!\");\n    }\n}\n</code></pre> <p>Two problems with using constants that are solved by the enum.</p> <ul> <li>We can pass any int constant to the <code>constantsExample()</code> method but we can pass only fixed values to <code>enumExample()</code>, so it provides type safety.</li> <li>We can change the int constants value in <code>PriorityConstant</code> class but the above program will not throw any exception. It might not work as expected but if we change the enum constants, we will get compile time error that removes any possibility of runtime issues.</li> </ul>"},{"location":"java-core/java-core-enum/#methods-in-enum","title":"Methods in Enum","text":"<pre><code>import java.io.Closeable;\nimport java.io.IOException;\n\npublic enum ThreadStatesEnum implements Closeable {\n    START(1){\n        @Override\n        public String toString(){\n            return \"START implementation. Priority=\"+getPriority();\n        }\n\n        @Override\n        public String getDetail() {\n            return \"START\";\n        }\n    },\n    RUNNING(2){\n        @Override\n        public String getDetail() {\n            return \"RUNNING\";\n        }\n    },\n    WAITING(3){\n        @Override\n        public String getDetail() {\n            return \"WAITING\";\n        }\n    },\n    DEAD(4){\n        @Override\n        public String getDetail() {\n            return \"DEAD\";\n        }\n    };\n\n    private int priority;\n\n    public abstract String getDetail();\n\n    //Enum constructors should always be private.\n    private ThreadStatesEnum(int i){\n        priority = i;\n    }\n\n    //Enum can have methods\n    public int getPriority(){\n        return this.priority;\n    }\n\n    public void setPriority(int p){\n        this.priority = p;\n    }\n\n    //Enum can override functions\n    @Override\n    public String toString(){\n        return \"Default ThreadStatesConstructors implementation. Priority=\"+getPriority();\n    }\n\n    @Override\n    public void close() throws IOException {\n        System.out.println(\"Close of Enum\");\n    }\n}\n</code></pre> <p>Below are some of the important points for Enums in Java.</p> <ul> <li>All java enum implicitly extends <code>java.lang.Enum</code> class that extends Object class and implements Serializable and Comparable interfaces. So we can\u2019t extend any class in enum.</li> <li>Since enum is a keyword, we can\u2019t end package name with it, for example <code>johnny.java.enum</code> is not a valid package name.</li> <li>Enum can implement interfaces. As in above enum example, it\u2019s implementing <code>Closeable</code> interface.</li> <li>Enum constructors are always private.</li> <li>We can\u2019t create instance of enum using new operator.</li> <li>We can declare abstract methods in java enum, then all the enum fields must implement the abstract method. In above example getDetail() is the abstract method and all the enum fields have implemented it.</li> <li>We can define a method in enum and enum fields can override them too. For example, toString() method is defined in enum and enum field START has overridden it.</li> <li>Java enum fields has namespace, we can use enum field only with class name like ThreadStates.START</li> <li>Enums can be used in switch statement, we will see it in action in the later part of this tutorial.</li> <li>We can extend existing enum without breaking any existing functionality. For example, we can add a new field NEW in ThreadStates enum without impacting any existing functionality.</li> <li>Since enum fields are constants, java best practice is to write them in block letters and underscore for spaces. For example EAST, WEST, EAST_DIRECTION etc.</li> <li>Enum constants are implicitly static and final</li> <li>Enum constants are final but it\u2019s variable can still be changed. For example, we can use setPriority() method to change the priority of enum constants. We will see it in usage in below example.</li> <li>Since enum constants are final, we can safely compare them using \u201c==\u201d and equals() methods. Both will have the same result.</li> </ul> <p>Test enum.</p> <pre><code>import java.io.IOException;\nimport java.util.EnumMap;\nimport java.util.EnumSet;\nimport java.util.Set;\n\npublic class EnumExample {\n    public static void main(String[] args) throws IOException {\n\n        usingEnumMethods();\n\n        usingEnumValueOf();\n\n        usingEnumValues();\n\n        usingEnumInSwitch(ThreadStatesEnum.START);\n        usingEnumInSwitch(ThreadStatesEnum.DEAD);\n\n        usingEnumMap();\n\n        usingEnumSet();\n    }\n\n    private static void usingEnumSet() {\n        EnumSet&lt;ThreadStatesEnum&gt; enumSet = EnumSet.allOf(ThreadStatesEnum.class);\n        for (ThreadStatesEnum tsenum : enumSet){\n            System.out.println(\"Using EnumSet, priority = \" + tsenum.getPriority());\n        }\n    }\n\n    private static void usingEnumMap() {\n        EnumMap&lt;ThreadStatesEnum, String&gt; enumMap = new EnumMap&lt;ThreadStatesEnum,String&gt;(ThreadStatesEnum.class);\n        enumMap.put(ThreadStatesEnum.START, \"Thread is started\");\n        enumMap.put(ThreadStatesEnum.RUNNING, \"Thread is running\");\n        enumMap.put(ThreadStatesEnum.WAITING, \"Thread is waiting\");\n        enumMap.put(ThreadStatesEnum.DEAD, \"Thread is dead\");\n\n        Set&lt;ThreadStatesEnum&gt; keySet = enumMap.keySet();\n        for(ThreadStatesEnum key : keySet){\n            System.out.println(\"key=\"+key.toString()+\":: value=\"+enumMap.get(key));\n        }\n\n    }\n\n    private static void usingEnumInSwitch(ThreadStatesEnum th) {\n        switch (th){\n            case START:\n                System.out.println(\"START thread\");\n                break;\n            case WAITING:\n                System.out.println(\"WAITING thread\");\n                break;\n            case RUNNING:\n                System.out.println(\"RUNNING thread\");\n                break;\n            case DEAD:\n                System.out.println(\"DEAD thread\");\n        }\n    }\n\n    private static void usingEnumValues() {\n        ThreadStatesEnum[] thArray = ThreadStatesEnum.values();\n\n        for(ThreadStatesEnum th : thArray){\n            System.out.println(th.toString() + \"::priority=\"+th.getPriority());\n        }\n    }\n\n    private static void usingEnumValueOf() {\n        ThreadStatesEnum th = Enum.valueOf(ThreadStatesEnum.class, \"START\");\n        System.out.println(\"th priority=\"+th.getPriority());\n    }\n\n    private static void usingEnumMethods() throws IOException {\n        ThreadStatesEnum thc = ThreadStatesEnum.DEAD;\n        System.out.println(\"priority is:\"+thc.getPriority());\n\n        thc = ThreadStatesEnum.DEAD;\n        System.out.println(\"Using overriden method.\"+thc.toString());\n\n        thc = ThreadStatesEnum.START;\n        System.out.println(\"Using overriden method.\"+thc.toString());\n        thc.setPriority(10);\n        System.out.println(\"Enum Constant variable changed priority value=\"+thc.getPriority());\n        thc.close();\n    }\n}\n</code></pre> <p>Important Points  </p> <ul> <li>The usingEnumMethods() methods shows how to create an enum object and how we can use its methods. It\u2019s also showing use of setPriority(int i) method to change the variable of enum.</li> <li>usingEnumValueOf() shows the usage of java.util.Enum valueOf(enumType, name) through which we can create an enum object from String. It throws IllegalArgumentException if the specified enum type has no constant with the specified name, or the specified class object does not represent an enum type. It also throws NullPointerException if any of the arguments are null.</li> <li>usingEnumValues() method shows the usage of values() method that returns an array containing all of the values of the enum in the order they are declared. Note that this method is automatically generated by java compiler for every enum. You won\u2019t find values() implementation in java.util.Enum class.</li> <li>The usingEnumInSwitch() method shows how to use enum constants in switch case.</li> <li>usingEnumMap() method shows use of java.util.EnumMap, which is introduced in Java 1.5 Collections Framework. EnumMap is Map implementation for use with enum type keys. All of the keys in an enum map must come from a single enum type that is specified, explicitly or implicitly, when the map is created. We can\u2019t use null as key for EnumMap and EnumMap is not synchronized.</li> <li>usingEnumSet() method shows use of java.util.EnumSet, which is Set implementation for use with enum types. All of the elements in an enum set must come from a single enum type that is specified, explicitly or implicitly, when the set is created. EnumSet is not synchronized and null elements are not allowed. It also provides some useful methods like copyOf(<code>Collection&lt;E&gt; c</code>), of(E first, E... rest) and complementOf(<code>EnumSet&lt;E&gt; s</code>).</li> </ul>"},{"location":"java-core/java-core-enum/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Enum on GitHub</li> </ul>"},{"location":"java-core/java-core-enum/#references","title":"References","text":"<ul> <li>Enum in Java</li> </ul>"},{"location":"java-core/java-core-formatting/","title":"Formatting","text":"<p>Formatting for String, Int and Double.</p>"},{"location":"java-core/java-core-formatting/#string","title":"String","text":"<pre><code>public static void formatString() {\n    System.out.println(\"Format String:\");\n    String department = \"Physics\";\n    // 1) Print a String - no size indicator, positive size indicator, and negative size indicator\n    System.out.format(\"%s%n\", department);    // Results &gt;Physics [Left Justified]\n    System.out.format(\"%15s%n\", department);  // Results &gt; Physics [Right Justified]\n    System.out.format(\"%-15s%n\", department); // Results &gt;Physics [Left Justified]\n    System.out.println();\n    // 2) Print a String \u00ad- \"small\" size indicator, \"small\" size indicator with \".\"\n    System.out.format(\"%4s%n\", department);  // Results &gt;Physics [Still prints full String]\n    System.out.format(\"%.4s%n\", department); // Results &gt;Phys [Truncates the String]\n    System.out.println();\n    // 3) Print a String report with titles \u00ad- hard coded labels (does not line up well):\n    System.out.format(\"Department: %s%n\", department); // Results &gt;Department: Physics\n    System.out.format(\"Hobby: %s%n\", department);      // Results &gt;Hobby: Physics\n    System.out.format(\"Career: %s%n\", department);     // Results &gt;Career: Physics\n    System.out.println();\n    // 4) Print a String report with titles \u00ad- formatted labels (does line up well):\n    System.out.format(\"%-10s:%s%n\", \"Department\", department); // Results &gt;Department:Physics\n    System.out.format(\"%-10s:%s%n\", \"Hobby\", department);      // Results &gt;Hobby     :Physics\n    System.out.format(\"%-10s:%s%n\", \"Career\", department);     // Results &gt;Career    :Physics\n    System.out.println();\n}\n</code></pre> <p>Output.</p> <pre><code>Format String:\nPhysics\n        Physics\nPhysics        \n\nPhysics\nPhys\n\nDepartment: Physics\nHobby: Physics\nCareer: Physics\n\nDepartment:Physics\nHobby     :Physics\nCareer    :Physics\n</code></pre>"},{"location":"java-core/java-core-formatting/#int","title":"Int","text":"<pre><code>public static void formatInt() {\n    System.out.println(\"Format Int:\");\n    int population = 123456;\n    // 5) Print an \"int\" \u00ad Left Justified, No field width, with various formatting\n    System.out.format(\"%d%n\", population);     // Results &gt;123456   [Left Justified]\n    System.out.format(\"%+d%n\", population);    // Results &gt;+123456  [Left Justified, displays \"+\" for positive values]\n    System.out.format(\"%,d%n\", population);    // Results &gt;123,456  [Left Justified, Inserts commas where appropriate]\n    System.out.format(\"$%,d%n\", population);   // Results &gt;$123,456 [Left Justified, with commas -\u00ad preceded by a \"$\"\n    System.out.println();\n    // 6) Print an \"int\" \u00ad Left Justified, Using field width, with various formatting\n    System.out.format(\"%-9d%n\", population);   // Results &gt;123456   [Left Justified]\n    System.out.format(\"%-+9d%n\", population);  // Results &gt;+123456  [Left Justified, displays \"+\" for positive values]\n    System.out.format(\"%-,9d%n\", population);  // Results &gt;123,456  [Left Justified, Inserts commas where appropriate]\n    System.out.format(\"$%-,9d%n\", population); // Results &gt;$123,456 [Left Justified, with commas -\u00ad preceded by a \"$\"\n    System.out.println();\n    // 7) Print an \"int\" \u00ad Right Justified, Using field width, with various formatting\n    System.out.format(\"%9d%n\", population);    // Results &gt;   123456 [Right Justified]\n    System.out.format(\"%+9d%n\", population);   // Results &gt;  +123456 [Right Justified, displays \"+\" for positive values]\n    System.out.format(\"%,9d%n\", population);   // Results &gt;  123,456 [Right Justified, Inserts commas where appropriate]\n    System.out.format(\"%09d%n\", population);   // Results &gt;000123456 [Right Justified, padds blanks with Zeros]\n    System.out.println();\n}\n</code></pre> <p>Output.</p> <pre><code>Format Int:\n123456\n+123456\n123,456\n$123,456\n\n123456   \n+123456  \n123,456  \n$123,456  \n\n   123456\n  +123456\n  123,456\n000123456\n</code></pre>"},{"location":"java-core/java-core-formatting/#double","title":"Double","text":"<pre><code>public static void formatDouble() {\n    System.out.println(\"Format Double:\");\n    double price = 1234.567;\n    // 8) Print a \"double\" \u00ad Left Justified, No field width, with various formatting\n    System.out.format(\"%f%n\", price);  // Results &gt;1234.567000  [Left Justified, 6 decimal places]\n    System.out.format(\"%+f%n\", price); // Results &gt;+1234.567000 [Left Justified, displays \"+\" for positive values, 6 decimal places]\n    System.out.format(\"%,f%n\", price); // Results &gt;1,234.567000 [Left Justified, Inserts commas where appropriate, 6 decimal places]\n    System.out.println();\n    // 9) Print a \"double\" \u00ad Left Justified (only), Using decimal\u00adonly field widths, with various formatting\n    System.out.format(\"%.1f%n\", price); // Results &gt;1234.6    [Left Justified, no character max, \"1\" decimal place]\n    System.out.format(\"%.2f%n\", price); // Results &gt;1234.57   [Left Justified, no character max, \"2\" decimal place]\n    System.out.format(\"%.3f%n\", price); // Results &gt;1234.567  [Left Justified, no character max, \"3\" decimal place]\n    System.out.format(\"%.4f%n\", price); // Results &gt;1234.5670 [Left Justified, no character max, \"4\" decimal place]\n    System.out.println();\n    // 10) Print a \"double\" \u00ad Left Justified, Using whole number and decimal field widths, with various formatting\n    System.out.format(\"%-12.2f%n\", price);  // Results &gt;1234.57   [Left Justified, 12 character max, 2 decimal places]\n    System.out.format(\"%-+12.3f%n\", price); // Results &gt;+1234.567 [Left Justified, displays \"+\" for positive values, 12 character max, 3 decimal places]\n    System.out.format(\"%,-12.1f%n\", price); // Results &gt;1,234.6   [Left Justified, Inserts commas where appropriate, 2 decimal place]\n    System.out.println();\n}\n</code></pre> <p>Output.</p> <pre><code>Format Double:\n1234.567000\n+1234.567000\n1,234.567000\n\n1234.6\n1234.57\n1234.567\n1234.5670\n\n1234.57     \n+1234.567   \n1,234.6     \n</code></pre>"},{"location":"java-core/java-core-formatting/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Formatting on GitHub</li> </ul>"},{"location":"java-core/java-core-generics-type-erasure/","title":"Generics Type Erasure","text":"<p>Generics are used for tighter type checks at compile time and to provide a generic programming. To implement generic behavior, java compiler apply type erasure. <code>Type erasure</code> is a process in which compiler replaces a generic parameter with actual class or bridge method. In type erasure, compiler ensures that no extra classes are created and there is no runtime overhead.</p> <p>Type erasure rules:</p> <ul> <li>Replace type parameters in generic type with their <code>bound</code> if bounded type parameters are used.</li> <li>Replace type parameters in generic type with <code>Object</code> if unbounded type parameters are used.</li> <li>Insert type casts to preserve type safety.</li> <li>Generate bridge methods to keep polymorphism in extended generic types.</li> </ul>"},{"location":"java-core/java-core-generics-type-erasure/#erasure-examples","title":"Erasure Examples","text":""},{"location":"java-core/java-core-generics-type-erasure/#bounded-types-erasure","title":"Bounded Types Erasure","text":"<p>Java Compiler replaces type parameters in generic type with their bound if bounded type parameters are used.</p> <p>Example.</p> <pre><code>public class BoundedTypesErasureExample {\n    public static void main(String[] args) {\n        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();\n        Box&lt;Double&gt; doubleBox = new Box&lt;Double&gt;();\n\n        integerBox.add(new Integer(10));\n        doubleBox.add(new Double(10.0));\n\n        System.out.format(\"Integer Value: %d\\n\", integerBox.get());\n        System.out.format(\"Double Value: %s\\n\", doubleBox.get());\n    }\n\n    static class Box&lt;T extends Number&gt; {\n        private T t;\n\n        public void add(T t) {\n            this.t = t;\n        }\n\n        public T get() {\n            return t;\n        }\n    }\n}\n</code></pre> <p>In this case, java compiler will replace <code>T</code> with <code>Number</code> class and after type erasure, compiler will generate bytecode for the following code.</p> <pre><code>public class BoundedTypesErasureExample {\n    public static void main(String[] args) {\n        Box integerBox = new Box();\n        Box doubleBox = new Box();\n\n        integerBox.add(new Integer(10));\n        doubleBox.add(new Double(10.0));\n\n        System.out.format(\"Integer Value: %d\\n\", integerBox.get());\n        System.out.format(\"Double Value: %s\\n\", doubleBox.get());\n    }\n\n    static class Box {\n        private Number t;\n\n        public void add(Number t) {\n            this.t = t;\n        }\n\n        public Number get() {\n            return t;\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-generics-type-erasure/#unbounded-types-erasure","title":"Unbounded Types Erasure","text":"<p>Java Compiler replaces type parameters in generic type with Object if unbounded type parameters are used.</p> <p>Example.</p> <pre><code>public class UnboundedTypesErasureExample {\n    public static void main(String[] args) {\n        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();\n        Box&lt;String&gt; stringBox = new Box&lt;String&gt;();\n\n        integerBox.add(new Integer(10));\n        stringBox.add(new String(\"Hello World\"));\n\n        System.out.format(\"Integer Value: %d\\n\", integerBox.get());\n        System.out.format(\"String Value: %s\\n\", stringBox.get());\n    }\n\n    static class Box&lt;T&gt; {\n        private T t;\n\n        public void add(T t) {\n            this.t = t;\n        }\n\n        public T get() {\n            return t;\n        }\n    }\n}\n</code></pre> <p>In this case, java compiler will replace <code>T</code> with <code>Object</code> class and after type erasure, compiler will generate bytecode for the following code.</p> <pre><code>public class UnboundedTypesErasureExample {\n    public static void main(String[] args) {\n        Box integerBox = new Box();\n        Box stringBox = new Box();\n\n        integerBox.add(new Integer(10));\n        stringBox.add(new String(\"Hello World\"));\n\n        System.out.format(\"Integer Value: %d\\n\", integerBox.get());\n        System.out.format(\"String Value: %s\\n\", stringBox.get());\n    }\n\n    static class Box {\n        private Object t;\n\n        public void add(Object t) {\n            this.t = t;\n        }\n\n        public Object get() {\n            return t;\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-generics-type-erasure/#methods-erasure","title":"Methods Erasure","text":"<p>Java compiler replaces type parameters in generic type with Object if unbounded type parameters are used, and with type if bound parameters are used as method parameters.</p> <p>Example.</p> <pre><code>public class MethodsErasureExample {\n    public static void main(String[] args) {\n        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();\n        Box&lt;String&gt; stringBox = new Box&lt;String&gt;();\n\n        integerBox.add(new Integer(10));\n        stringBox.add(new String(\"Hello World\"));\n\n        printBox1(integerBox);\n        printBox2(stringBox);\n    }\n\n    private static &lt;T extends Box&gt; void printBox1(T box) {\n        System.out.println(\"Integer Value: \" + box.get());\n    }\n\n    private static &lt;T&gt; void printBox2(T box) {\n        System.out.println(\"String Value: \" + ((Box)box).get());\n    }\n\n    static class Box&lt;T&gt; {\n        private T t;\n\n        public void add(T t) {\n            this.t = t;\n        }\n\n        public T get() {\n            return t;\n        }\n    }\n}\n</code></pre> <p>In this case, java compiler will replace <code>T</code> with <code>Object</code> class and after type erasure, compiler will generate bytecode for the following code.</p> <pre><code>public class MethodsErasureExample {\n    public static void main(String[] args) {\n        Box integerBox = new Box();\n        Box stringBox = new Box();\n\n        integerBox.add(new Integer(10));\n        stringBox.add(new String(\"Hello World\"));\n\n        printBox1(integerBox);\n        printBox2(stringBox);\n    }\n\n    //Bounded Types Erasure\n    private static void printBox1(Box box) {\n        System.out.println(\"Integer Value: \" + box.get());\n    }\n\n    //Unbounded Types Erasure\n    private static void printBox2(Object box) {\n        System.out.println(\"String Value: \" + ((Box)box).get());\n    }\n\n    static class Box {\n        private Object t;\n\n        public void add(Object t) {\n            this.t = t;\n        }\n\n        public Object get() {\n            return t;\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-generics-type-erasure/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Generics Type Erasure on GitHub</li> </ul>"},{"location":"java-core/java-core-generics-type-erasure/#references","title":"References","text":"<ul> <li>Java Generics Tutorial</li> <li>Java Generics Example Tutorial \u2013 Generic Method, Class, Interface</li> </ul>"},{"location":"java-core/java-core-generics/","title":"Generics","text":"<p>Java Generics were introduced in JDK 5.0 with the aim of reducing bugs and adding an extra layer of abstraction over types.</p> <ul> <li>Java generic methods and generic classes enable programmers to specify, with a single method declaration, a set of related methods, or with a single class declaration, a set of related types, respectively.</li> <li>Generics also provide compile-time type safety that allows programmers to catch invalid types at compile time.</li> <li>Using Java Generic concept, we might write a generic method for sorting an array of objects, then invoke the generic method with Integer arrays, Double arrays, String arrays and so on, to sort the array elements.</li> </ul>"},{"location":"java-core/java-core-generics/#generic-classes","title":"Generic Classes","text":""},{"location":"java-core/java-core-generics/#generic-class","title":"Generic Class","text":"<p>A <code>generic class</code> declaration looks like a non-generic class declaration, except that the class name is followed by a <code>type parameter</code> section.</p> <p>The type parameter section of a generic class can have one or more type parameters separated by commas. These classes are known as <code>parameterized classes</code> or parameterized types because they accept one or more parameters.</p> <p>Syntax.</p> <pre><code>public class Box&lt;T&gt; {\n   private T t;\n}\n</code></pre> <ul> <li><code>Box</code> \u2212 Box is a generic class.</li> <li><code>T</code> \u2212 The generic type parameter passed to generic class. It can take any Object.</li> <li><code>t</code> \u2212 Instance of generic type T.</li> </ul> <p>Example.</p> <pre><code>public class GenericClassExample {\n    public static void main(String[] args) {\n        Box&lt;Integer&gt; integerBox = new Box&lt;Integer&gt;();\n        Box&lt;String&gt; stringBox = new Box&lt;String&gt;();\n\n        integerBox.add(new Integer(10));\n        stringBox.add(new String(\"Hello World\"));\n\n        System.out.format(\"Integer Value: %d\\n\", integerBox.get());\n        System.out.format(\"String Value: %s\\n\", stringBox.get());\n    }\n\n    static class Box&lt;T&gt; {\n        private T t;\n\n        public void add(T t) {\n            this.t = t;\n        }\n\n        public T get() {\n            return t;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nString Value: Hello World\n</code></pre>"},{"location":"java-core/java-core-generics/#type-parameter-naming-conventions","title":"Type Parameter Naming Conventions","text":"<p>By convention, type parameter names are named as single, uppercase letters so that a type parameter can be distinguished easily with an ordinary class or interface name.</p> <p>Following is the list of commonly used type parameter names:</p> <ul> <li><code>E</code> \u2212 <code>Element</code>, and is mainly used by Java Collections framework.</li> <li><code>K</code> \u2212 <code>Key</code>, and is mainly used to represent parameter type of key of a map.</li> <li><code>V</code> \u2212 <code>Value</code>, and is mainly used to represent parameter type of value of a map.</li> <li><code>N</code> \u2212 <code>Number</code>, and is mainly used to represent numbers.</li> <li><code>T</code> \u2212 <code>Type</code>, and is mainly used to represent first generic type parameter.</li> <li><code>S</code> \u2212 <code>Type</code>, and is mainly used to represent second generic type parameter.</li> <li><code>U</code> \u2212 <code>Type</code>, and is mainly used to represent third generic type parameter.</li> <li><code>V</code> \u2212 <code>Type</code>, and is mainly used to represent fourth generic type parameter.</li> </ul> <p>Following example will showcase above mentioned concept.</p> <pre><code>public class NamingConventionExample {\n    public static void main(String[] args) {\n        Box&lt;Integer, String&gt; box = new Box&lt;Integer, String&gt;();\n        box.add(Integer.valueOf(10),\"Hello World\");\n        System.out.format(\"Integer Value: %d\\n\", box.getFirst());\n        System.out.format(\"String Value: %s\\n\", box.getSecond());\n\n        Pair&lt;String, Integer&gt; pair = new Pair&lt;String, Integer&gt;();\n        pair.addKeyValue(\"A\", Integer.valueOf(20));\n        System.out.format(\"(Pair)Integer Value: %d\\n\", pair.getValue(\"A\"));\n\n        CustomList&lt;Box&gt; list = new CustomList&lt;Box&gt;();\n        list.addItem(box);\n        System.out.format(\"(CustomList)Integer Value: %d\\n\", list.getItem(0).getFirst());\n    }\n\n    static class Box&lt;T, S&gt; {\n        private T t;\n        private S s;\n\n        public void add(T t, S s) {\n            this.t = t;\n            this.s = s;\n        }\n\n        public T getFirst() {\n            return t;\n        }\n\n        public S getSecond() {\n            return s;\n        }\n    }\n\n    static class Pair&lt;K,V&gt;{\n        private Map&lt;K,V&gt; map = new HashMap&lt;K,V&gt;();\n\n        public void addKeyValue(K key, V value) {\n            map.put(key, value);\n        }\n\n        public V getValue(K key) {\n            return map.get(key);\n        }\n    }\n\n    static class CustomList&lt;E&gt;{\n        private List&lt;E&gt; list = new ArrayList&lt;E&gt;();\n\n        public void addItem(E value) {\n            list.add(value);\n        }\n\n        public E getItem(int index) {\n            return list.get(index);\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nString Value: Hello World\n(Pair)Integer Value: 20\n(CustomList)Integer Value: 10\n</code></pre>"},{"location":"java-core/java-core-generics/#type-inference","title":"Type Inference","text":"<p><code>Type inference</code> represents the Java compiler's ability to look at a method invocation and its corresponding declaration to check and determine the type argument(s). The inference algorithm checks the types of the arguments and, if available, assigned type is returned. Inference algorithms tries to find a specific type which can fulfill all type parameters.</p> <p>Using <code>diamond operator</code>, compiler determines the type of the parameter. This operator is avalilable from Java SE 7 version onwards.</p> <p>Syntax.</p> <pre><code>Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();\n</code></pre> <ul> <li><code>Box</code> \u2212 Box is a generic class.</li> <li><code>&lt;&gt;</code> \u2212 The diamond operator denotes type inference.</li> </ul> <p>Example.</p> <pre><code>public class TypeInferenceExample {\n    public static void main(String[] args) {\n        //type inference\n        Box&lt;Integer&gt; integerBox = new Box&lt;&gt;();\n        //unchecked conversion warning\n        Box&lt;String&gt; stringBox = new Box&lt;String&gt;();\n\n        integerBox.add(new Integer(10));\n        stringBox.add(new String(\"Hello World\"));\n\n        System.out.format(\"Integer Value: %d\\n\", integerBox.get());\n        System.out.format(\"String Value: %s\\n\", stringBox.get());\n    }\n\n    static class Box&lt;T&gt; {\n        private T t;\n\n        public void add(T t) {\n            this.t = t;\n        }\n\n        public T get() {\n            return t;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nString Value: Hello World\n</code></pre>"},{"location":"java-core/java-core-generics/#multiple-type-parameters","title":"Multiple Type Parameters","text":"<p>A generic class can have multiple type parameters.</p> <p>Example.</p> <pre><code>public class MultipleTypeParametersExample {\n    public static void main(String[] args) {\n        Box&lt;Integer, String&gt; box = new Box&lt;Integer, String&gt;();\n        box.add(Integer.valueOf(10),\"Hello World\");\n        System.out.format(\"Integer Value: %d\\n\", box.getFirst());\n        System.out.format(\"String Value: %s\\n\", box.getSecond());\n\n        Box&lt;String, String&gt; box1 = new Box&lt;String, String&gt;();\n        box1.add(\"Message\",\"Hello World\");\n        System.out.format(\"String Value: %s\\n\", box1.getFirst());\n        System.out.format(\"String Value: %s\\n\", box1.getSecond());\n    }\n\n    static class Box&lt;T, S&gt; {\n        private T t;\n        private S s;\n\n        public void add(T t, S s) {\n            this.t = t;\n            this.s = s;\n        }\n\n        public T getFirst() {\n            return t;\n        }\n\n        public S getSecond() {\n            return s;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nString Value: Hello World\nString Value: Message\nString Value: Hello World\n</code></pre>"},{"location":"java-core/java-core-generics/#parameterized-types","title":"Parameterized Types","text":"<p>A generic class can have parameterized types where a type parameter can be substituted with a parameterized type.</p> <p>Example.</p> <pre><code>public class ParameterizedTypesExample {\n    public static void main(String[] args) {\n        Box&lt;Integer, List&lt;String&gt;&gt; box\n                = new Box&lt;Integer, List&lt;String&gt;&gt;();\n\n        List&lt;String&gt; messages = new ArrayList&lt;String&gt;();\n\n        messages.add(\"Hi\");\n        messages.add(\"Hello\");\n        messages.add(\"Bye\");\n\n        box.add(Integer.valueOf(10),messages);\n        System.out.format(\"Integer Value: %d\\n\", box.getFirst());\n        System.out.format(\"String Value: %s\\n\", box.getSecond());\n    }\n\n    static class Box&lt;T, S&gt; {\n        private T t;\n        private S s;\n\n        public void add(T t, S s) {\n            this.t = t;\n            this.s = s;\n        }\n\n        public T getFirst() {\n            return t;\n        }\n\n        public S getSecond() {\n            return s;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nString Value: [Hi, Hello, Bye]\n</code></pre>"},{"location":"java-core/java-core-generics/#raw-types","title":"Raw Types","text":"<p>A raw type is an object of a generic class or interface if its type arguments are not passed during its creation.</p> <p>Example.</p> <pre><code>public class RawTypesExample {\n    public static void main(String[] args) {\n        Box&lt;Integer&gt; box = new Box&lt;Integer&gt;();\n\n        box.set(Integer.valueOf(10));\n        System.out.format(\"Integer Value: %d\\n\", box.getData());\n\n        Box rawBox = new Box();\n\n        //No warning\n        rawBox = box;\n        System.out.format(\"Integer Value: %d\\n\", rawBox.getData());\n\n        //Warning for unchecked invocation to set(T)\n        rawBox.set(Integer.valueOf(10));\n        System.out.format(\"Integer Value: %d\\n\", rawBox.getData());\n\n        //Warning for unchecked conversion\n        box = rawBox;\n        System.out.format(\"Integer Value: %d\\n\", box.getData());\n    }\n\n    static class Box&lt;T&gt; {\n        private T t;\n\n        public void set(T t) {\n            this.t = t;\n        }\n\n        public T getData() {\n            return t;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nInteger Value: 10\nInteger Value: 10\nInteger Value: 10\n</code></pre>"},{"location":"java-core/java-core-generics/#generic-methods","title":"Generic methods","text":"<p>You can write a single generic method declaration that can be called with arguments of different types. Based on the types of the arguments passed to the generic method, the compiler handles each method call appropriately.</p> <p>Following are the rules to define Generic Methods:</p> <ul> <li>All generic method declarations have a type parameter section delimited by <code>angle brackets</code>(&lt; and &gt;) that precedes the method's <code>return type</code> (\\&lt;E&gt; in the next example).</li> <li>Each type parameter section contains one or more type parameters separated by commas. A type parameter, also known as a type variable, is an identifier that specifies a generic type name.</li> <li>The type parameters can be used to declare the <code>return type</code> and act as placeholders for the types of the <code>arguments</code> passed to the generic method, which are known as actual type arguments.</li> <li>A generic method's body is declared like that of any other method. Note that type parameters can represent only reference types, not primitive types (like int, double and char).</li> </ul> <p>Example.</p> <pre><code>public class GenericMethodsExample {\n    public static void main(String args[]) {\n        // Create arrays of Integer, Double and Character\n        Integer[] intArray = { 1, 2, 3, 4, 5 };\n        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };\n        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };\n\n        System.out.print(\"Array integerArray contains: \");\n        printArray(intArray);   // pass an Integer array\n\n        System.out.print(\"\\nArray doubleArray contains: \");\n        printArray(doubleArray);   // pass a Double array\n\n        System.out.print(\"\\nArray characterArray contains: \");\n        printArray(charArray);   // pass a Character array\n    }\n\n    // generic method printArray\n    public static &lt;E&gt; void printArray(E[] inputArray) {\n        // Display array elements\n        for(E element : inputArray) {\n            System.out.format(\"%s, \", element);\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Array integerArray contains: 1, 2, 3, 4, 5,\nArray doubleArray contains: 1.1, 2.2, 3.3, 4.4,\nArray characterArray contains: H, E, L, L, O,\n</code></pre>"},{"location":"java-core/java-core-generics/#generic-collections","title":"Generic Collections","text":""},{"location":"java-core/java-core-generics/#generic-list","title":"Generic List","text":"<p>Java has provided generic support in <code>List</code> interface.</p> <p>Syntax.</p> <pre><code>List&lt;T&gt; list = new ArrayList&lt;T&gt;();\n</code></pre> <ul> <li><code>T</code> \u2212 The generic type parameter passed during list declaration.</li> <li><code>list</code> \u2212 object of List interface.</li> </ul> <p>Example.</p> <pre><code>public class GenericListExample {\n    public static void main(String[] args) {\n\n        List&lt;Integer&gt; integerList = new ArrayList&lt;Integer&gt;();\n        integerList.add(Integer.valueOf(10));\n        integerList.add(Integer.valueOf(11));\n\n        List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n        stringList.add(\"Hello World\");\n        stringList.add(\"Hi World\");\n\n        // access by index\n        System.out.format(\"Integer Value: %d\\n\", integerList.get(0));\n        System.out.format(\"String Value: %s\\n\", stringList.get(0));\n\n        // for loop\n        for(Integer data: integerList) {\n            System.out.format(\"Integer Value: %d\\n\", data);\n        }\n\n        // iterator\n        Iterator&lt;String&gt; stringIterator = stringList.iterator();\n        while(stringIterator.hasNext()) {\n            System.out.format(\"String Value: %s\\n\", stringIterator.next());\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nString Value: Hello World\nInteger Value: 10\nInteger Value: 11\nString Value: Hello World\nString Value: Hi World\n</code></pre>"},{"location":"java-core/java-core-generics/#generic-set","title":"Generic Set","text":"<p>Java has provided generic support in <code>Set</code> interface.</p> <p>Syntax.</p> <pre><code>Set&lt;T&gt; set = new HashSet&lt;T&gt;();\n</code></pre> <ul> <li><code>T</code> \u2212 The generic type parameter passed during set declaration.</li> <li><code>set</code> \u2212 object of Set Interface.</li> </ul> <p>Example.</p> <pre><code>public class GenericSetExample {\n    public static void main(String[] args) {\n\n        Set&lt;Integer&gt; integerSet = new HashSet&lt;Integer&gt;();\n        integerSet.add(Integer.valueOf(10));\n        integerSet.add(Integer.valueOf(11));\n\n        Set&lt;String&gt; stringSet = new HashSet&lt;String&gt;();\n        stringSet.add(\"Hello World\");\n        stringSet.add(\"Hi World\");\n\n        // for loop\n        for(Integer data: integerSet) {\n            System.out.format(\"Integer Value: %d\\n\", data);\n        }\n\n        // iterator\n        Iterator&lt;String&gt; stringIterator = stringSet.iterator();\n        while(stringIterator.hasNext()) {\n            System.out.format(\"String Value: %s\\n\", stringIterator.next());\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nInteger Value: 11\nString Value: Hello World\nString Value: Hi World\n</code></pre>"},{"location":"java-core/java-core-generics/#generic-map","title":"Generic Map","text":"<p>Java has provided generic support in <code>Map</code> interface.</p> <p>Syntax.</p> <pre><code>Map&lt;K, V&gt; map = new HashSet&lt;K, V&gt;();\n</code></pre> <ul> <li><code>T</code> \u2212 The generic type parameter passed during map declaration.</li> <li><code>map</code> \u2212 object of Map Interface.</li> </ul> <p>Example.</p> <pre><code>public class GenericMapExample {\n    public static void main(String[] args) {\n\n        Map&lt;Integer,Integer&gt; integerMap = new HashMap&lt;Integer,Integer&gt;();\n        integerMap.put(1, 10);\n        integerMap.put(2, 11);\n\n        Map&lt;String,String&gt; stringMap = new HashMap&lt;String,String&gt;();\n        stringMap.put(\"A\", \"Hello World\");\n        stringMap.put(\"B\",\"Hi World\");\n\n        // access by key\n        System.out.format(\"Integer Value: %d\\n\", integerMap.get(1));\n        System.out.format(\"String Value: %s\\n\", stringMap.get(\"A\"));\n\n        // iterate keys.\n        Iterator&lt;Integer&gt; integerIterator   = integerMap.keySet().iterator();\n        while(integerIterator.hasNext()) {\n            System.out.format(\"Integer Value: %d\\n\", integerIterator.next());\n        }\n\n        // iterate values.\n        Iterator&lt;String&gt; stringIterator   = stringMap.values().iterator();\n        while(stringIterator.hasNext()) {\n            System.out.format(\"String Value: %s\\n\", stringIterator.next());\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Integer Value: 10\nString Value: Hello World\nInteger Value: 1\nInteger Value: 2\nString Value: Hello World\nString Value: Hi World\n</code></pre>"},{"location":"java-core/java-core-generics/#bounded-type","title":"Bounded Type","text":"<p>There may be times when you'll want to <code>restrict</code> the kinds of types that are allowed to be passed to a type parameter. For example, a method that operates on numbers might only want to accept instances of Number or its subclasses. This is what bounded type parameters are for.</p>"},{"location":"java-core/java-core-generics/#bounded-type-parameters","title":"Bounded Type Parameters","text":"<p>To declare a bounded type parameter, list the type parameter's name, followed by the <code>extends</code> keyword, followed by its upper bound.</p> <p>Following example illustrates how extends is used in a general sense to mean either \"extends\" (as in classes) or \"implements\" (as in interfaces). This example is generic method to return the largest of three Comparable objects.</p> <p>Example.</p> <pre><code>public class BoundedTypeParametersExample {\n    public static void main(String args[]) {\n        System.out.format(\"Max of %d, %d and %d is %d\\n\",\n                3, 4, 5, maximum(3, 4, 5));\n\n        System.out.format(\"Max of %.1f,%.1f and %.1f is %.1f\\n\",\n                6.6, 8.8, 7.7, maximum(6.6, 8.8, 7.7));\n\n        System.out.format(\"Max of %s, %s and %s is %s\\n\",\"pear\",\n                \"apple\", \"orange\", maximum(\"pear\", \"apple\", \"orange\"));\n    }\n\n    // determines the largest of three Comparable objects\n    public static &lt;T extends Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) {\n        T max = x;   // assume x is initially the largest\n\n        if(y.compareTo(max) &gt; 0) {\n            max = y;   // y is the largest so far\n        }\n\n        if(z.compareTo(max) &gt; 0) {\n            max = z;   // z is the largest now\n        }\n        return max;   // returns the largest object\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Max of 3, 4 and 5 is 5\nMax of 6.6,8.8 and 7.7 is 8.8\nMax of pear, apple and orange is pear\n</code></pre>"},{"location":"java-core/java-core-generics/#multiple-bounds","title":"Multiple Bounds","text":"<p>A type parameter can have multiple bounds.</p> <p>For example, we can define a generic method with multiple bounds as follows. The T is a type parameter passed to the generic method and should be subtype of Number class and must implements Comparable interface. In case a class is passed as bound, it should be passed first before interface otherwise compile time error will occur.</p> <pre><code>public static &lt;T extends Number &amp; Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z)\n</code></pre> <ul> <li><code>T</code> \u2212 The generic type parameter passed to generic method. It can take any Object.</li> <li><code>maximum</code> \u2212 The name of the generic method.</li> </ul> <p>Example.</p> <pre><code>public class MultipleBoundsExample {\n    public static void main(String[] args) {\n        System.out.format(\"Max of %d, %d and %d is %d\\n\",\n                3, 4, 5, maximum( 3, 4, 5 ));\n\n        System.out.format(\"Max of %.1f,%.1f and %.1f is %.1f\\n\",\n                6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ));\n    }\n\n    public static &lt;T extends Number &amp; Comparable&lt;T&gt;&gt; T maximum(T x, T y, T z) {\n        T max = x;\n        if(y.compareTo(max) &gt; 0) {\n            max = y;\n        }\n\n        if(z.compareTo(max) &gt; 0) {\n            max = z;\n        }\n        return max;\n    }\n\n    // Compiler throws error in case of below declaration\n   /* public static &lt;T extends Comparable&lt;T&gt; &amp; Number&gt; T maximum1(T x, T y, T z) {\n      T max = x;\n      if(y.compareTo(max) &gt; 0) {\n         max = y;\n      }\n\n      if(z.compareTo(max) &gt; 0) {\n         max = z;\n      }\n      return max;\n   }*/\n}\n</code></pre> <p>Output.</p> <pre><code>Max of 3, 4 and 5 is 5\nMax of 6.6,8.8 and 7.7 is 8.8\n</code></pre>"},{"location":"java-core/java-core-generics/#wildcards","title":"Wildcards","text":""},{"location":"java-core/java-core-generics/#using-wildcards","title":"Using Wildcards","text":"<p>Wildcards can be used in three ways \u2212</p> <ul> <li>Unbounded Wildcard \u2212 <code>?</code></li> <li>Upper Bounded Wildcard \u2212 <code>? extends</code> Type.</li> <li>Lower Bounded Wildcard \u2212 <code>? super</code> Type.</li> </ul> <p>See the difference between upper bound wildcard and lower bound wildcard. </p>"},{"location":"java-core/java-core-generics/#unbounded-wildcards","title":"Unbounded Wildcards","text":"<p>The question mark (?), represents the wildcard, stands for <code>unknown</code> type in generics. There may be times when any object can be used when a method can be implemented using functionality provided in the Object class or When the code is independent of the type parameter. To declare a Unbounded Wildcard parameter, list the <code>?</code> only.</p> <p>Example.</p> <pre><code>public class UnboundedWildcardsExample {\n    public static void main(String args[]) {\n        List&lt;Integer&gt; integerList = Arrays.asList(1, 2, 3);\n        printAll(integerList);\n        List&lt;Double&gt; doubleList = Arrays.asList(1.1, 2.5, 3.8);\n        printAll(doubleList);\n    }\n\n    public static void printAll(List&lt;?&gt; list) {\n        for (Object item : list) {\n            System.out.print(item + \", \");\n        }\n        System.out.println();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>1, 2, 3,\n1.1, 2.5, 3.8,\n</code></pre>"},{"location":"java-core/java-core-generics/#upper-bounded-wildcards","title":"Upper Bounded Wildcards","text":"<p>Upper bounded wildcards is used to restrict the kinds of types that are allowed to be passed to a type parameter. To declare a upper bounded wildcard parameter, list the <code>?</code>, followed by the <code>extends</code> keyword, followed by its upper bound.</p> <p>Example.</p> <pre><code>public class UpperBoundedWildcardsExample {\n    public static void print(List&lt;? extends Fruit&gt; list, String type) {\n        System.out.println(type + \" list is printed\");\n    }\n\n    public static void main(String[] args) {\n        List&lt;Food&gt; foods = new ArrayList&lt;&gt;();\n        List&lt;Fruit&gt; fruits = new ArrayList&lt;&gt;();\n        List&lt;Apple&gt; apples = new ArrayList&lt;&gt;();\n        List&lt;Banana&gt; bananas = new ArrayList&lt;&gt;();\n\n        //compile time error: can't call print method\n        //print(foods, \"food\" );\n\n        //add fruit list\n        print(fruits, \"fruit\");\n\n        //add apple list\n        print(apples, \"apple\");\n\n        //add banana list\n        print(bananas, \"banana\");\n    }\n\n    static class Food {}\n\n    static class Fruit extends Food {}\n\n    static class Apple extends Fruit {}\n\n    static class Banana extends Fruit {}\n}\n</code></pre> <p>Output.</p> <pre><code>fruit list is printed\napple list is printed\nbanana list is printed\n</code></pre>"},{"location":"java-core/java-core-generics/#lower-bounded-wildcards","title":"Lower Bounded Wildcards","text":"<p>Lower bounded wildcards is also used to restrict the kinds of types that are allowed to be passed to a type parameter. To declare a lower bounded wildcard parameter, list the <code>?</code>, followed by the <code>super</code> keyword, followed by its lower bound.</p> <p>Example.</p> <pre><code>public class LowerBoundedWildcardsExample {\n    public static void print(List&lt;? super Fruit&gt; list, String type) {\n        System.out.println(type + \" list is printed\");\n    }\n\n    public static void main(String[] args) {\n        List&lt;Food&gt; foods = new ArrayList&lt;&gt;();\n        List&lt;Fruit&gt; fruits = new ArrayList&lt;&gt;();\n        List&lt;Apple&gt; apples = new ArrayList&lt;&gt;();\n        List&lt;Banana&gt; bananas = new ArrayList&lt;&gt;();\n\n        //add food list\n        print(foods, \"food\" );\n\n        //add fruit list\n        print(fruits, \"fruit\");\n\n        //compile time error: can't call print method\n        //print(apples, \"apple\");\n\n        //compile time error: can't call print method\n        //print(bananas, \"banana\");\n    }\n\n    static class Food {}\n\n    static class Fruit extends Food {}\n\n    static class Apple extends Fruit {}\n\n    static class Banana extends Fruit {}\n}\n</code></pre> <p>Output.</p> <pre><code>food list is printed\nfruit list is printed\n</code></pre>"},{"location":"java-core/java-core-generics/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Generics on GitHub</li> <li>Java Generic Diagrams(draw.io) in Google Drive</li> </ul>"},{"location":"java-core/java-core-generics/#references","title":"References","text":"<ul> <li>Java Generics Tutorial</li> <li>Java Generics Example Tutorial \u2013 Generic Method, Class, Interface</li> </ul>"},{"location":"java-core/java-core-io-vs-nio/","title":"IO vs NIO","text":"<p>Difference between IO and NIO.</p>"},{"location":"java-core/java-core-io-vs-nio/#differences-between-java-standard-io-and-java-nio","title":"Differences between Java Standard IO and Java NIO","text":"<p>The table below summarizes the main differences between Java NIO and IO.</p> IO NIO Stream oriented Buffer oriented Blocking IO Non blocking IO, Selectors"},{"location":"java-core/java-core-io-vs-nio/#io-streams-vs-nio-blocks","title":"IO Streams vs NIO Blocks","text":"<p>The most important distinction between the standard I/O library (found in java.io package) and NIO has to do with how data is packaged and transmitted. Standard I/O deals with data in streams, whereas NIO deals with data in blocks.</p> <p>A <code>stream-oriented I/O</code> system deals with data one or more bytes at a time. An input stream produces one byte of data, and an output stream consumes one byte of data. It is very easy to create filters for streamed data. It is also relatively simply to chain several filters together so that each one does its part in what amounts to a single, sophisticated processing mechanism. Important thing is that bytes are not cached anywhere. Furthermore, you cannot move forth and back in the data in a stream. If you need to move forth and back in the data read from a stream, you must cache it in a buffer first.</p> <p>A <code>block-oriented I/O</code> system deals with data in blocks. Each operation produces or consumes a block of data in one step. Processing data by the block can be much faster than processing it by the (streamed) byte. You can move forth and back in the buffer as you need to. This gives you a bit more flexibility during processing. However, you also need to check if the buffer contains all the data you need in order to fully process it. And, you need to make sure that when reading more data into the buffer, you do not overwrite data in the buffer you have not yet processed. But block-oriented I/O lacks some of the elegance and simplicity of stream-oriented I/O.</p>"},{"location":"java-core/java-core-io-vs-nio/#synchronous-vs-asynchronous-io","title":"Synchronous vs. Asynchronous IO","text":"<p>Java IO\u2019s various streams are blocking or synchronous. That means, that when a thread invokes a read() or write(), that thread is blocked until there is some data to read, or the data is fully written. The thread will be in blocked state for this period. This has been cited as a good solid reason for bringing multi-threading in modern languages.</p> <p>In asynchronous IO, a thread can request that some data be written to a channel, but not wait for it to be fully written. The thread can then go on and do something else in the mean time. Usually these threads spend their idle time on when not blocked in IO calls, is usually performing IO on other channels in the meantime. That is, a single thread can now manage multiple channels of input and output.</p> <p>Synchronous programs often have to resort to polling, or to the creation of many, many threads, to deal with lots of connections. With asynchronous I/O, you can listen for I/O events on an arbitrary number of channels, without polling and without extra threads.</p> <p>The central object in asynchronous I/O is called the <code>Selector</code>. A Selector is where you register your interest in various I/O events, and it is the object that tells you when those events occur.</p>"},{"location":"java-core/java-core-io-vs-nio/#java-nio-selector","title":"Java NIO Selector","text":"<p>The Java NIO <code>Selector</code> is a component which can examine one or more Java NIO Channel instances, and determine which channels are ready for e.g. reading or writing. This way a single thread can manage multiple channels, and thus multiple network connections.</p> <pre><code>public static void main(String[] args) throws IOException {\n    Selector selector = Selector.open();\n    ServerSocketChannel serverSocket = ServerSocketChannel.open();\n    serverSocket.bind(new InetSocketAddress(\"localhost\", 5454));\n    serverSocket.configureBlocking(false);\n    serverSocket.register(selector, SelectionKey.OP_ACCEPT);\n    ByteBuffer buffer = ByteBuffer.allocate(256);\n\n    while (true) {\n        int readyChannels = selector.selectNow();\n        if(readyChannels == 0) {\n            continue;\n        }\n        Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();\n        Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();\n        while (iter.hasNext()) {\n            SelectionKey key = iter.next();\n\n            if(key.isAcceptable()) {\n                // a connection was accepted by a ServerSocketChannel.\n                register(selector, serverSocket);\n            } else if (key.isConnectable()) {\n                // a connection was established with a remote server.\n            } else if (key.isReadable()) {\n                // a channel is ready for reading\n                answerWithEcho(buffer, key);\n            } else if (key.isWritable()) {\n                // a channel is ready for writing\n            }\n            iter.remove();\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-io-vs-nio/#io-vs-nio-apis","title":"IO vs NIO APIs","text":"<p>Using NIO look different than when using IO. Here in NIO, rather than just read the data byte for byte from e.g. an InputStream, the data must first be read into a buffer, and then be processed from thereafter.</p> <p>Sample code using standard IO.</p> <pre><code>public static void main(String[] args) {\n    BufferedReader br = null;\n    String line = null;\n    try {\n        br = new BufferedReader(new FileReader(\"test.txt\"));\n        System.out.println(\"Reading file with BufferedReader...\");\n        while ((line = br.readLine()) != null) {\n            System.out.println(line);\n        }\n        br.close();\n    }\n    catch (IOException ioe) {\n        System.out.println(ioe);\n    }\n}\n</code></pre> <p>Sample code using NIO.</p> <pre><code>public static void main(String[] args) {\n    try {\n        int capacity = 1024; // chunk size\n        RandomAccessFile raf = new RandomAccessFile(\"test.txt\", \"r\");\n        FileChannel channel = raf.getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(capacity);\n        System.out.println(\"Reading file with Buffer of Fixed Size...\");\n        //int chunk = 1;\n        while (channel.read(buffer) &gt; 0) {\n            //System.out.println(\"Chunk:\" + chunk++);\n            buffer.flip();\n            for (int i = 0; i &lt; buffer.limit(); i++) {\n                System.out.print((char) buffer.get());\n            }\n            buffer.clear(); // do something with the data and clear/compact it.\n        }\n        channel.close();\n        raf.close();\n    }\n    catch (IOException ioe) {\n        System.out.println(ioe);\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-io-vs-nio/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java NIO on GitHub</li> </ul>"},{"location":"java-core/java-core-io-vs-nio/#references","title":"References","text":"<ul> <li>Java NIO vs. IO</li> <li>Java Standard IO vs. Java NIO</li> </ul>"},{"location":"java-core/java-core-io/","title":"IO","text":"<p>Read and write file in java.</p>"},{"location":"java-core/java-core-io/#java-io","title":"Java IO","text":"<p>Java IO is an API that comes with Java which is targeted at reading and writing data (input and output). Most applications need to process some input and produce some output based on that input. For instance, read data from a file or over network, and write to a file or write a response back over the network. The Java IO API is located in the Java IO package <code>java.io</code>.</p>"},{"location":"java-core/java-core-io/#input-and-output-source-and-destination","title":"Input and Output - Source and Destination","text":"<p>Java's IO package mostly concerns itself with the reading of raw data from a source and writing of raw data to a destination. The most typical sources and destinations of data are these:</p> <p>Files Pipes Network Connections In-memory Buffers (e.g. arrays) System.in, System.out, System.error The diagram below illustrates the principle of a program reading data from a source and writing it to some destination:</p>  graph LR;     Source--&gt;Program     Program--&gt;Destination  <p>Streams <code>IO Streams</code> are a core concept in Java IO. A stream is a conceptually endless flow of data. You can either read from a stream or write to a stream. A stream is connected to a data source or a data destination. Streams in Java IO can be either byte based (reading and writing bytes) or character based (reading and writing characters).</p> <p>The InputStream, OutputStream, Reader and Writer A program that needs to read data from some source needs an <code>InputStream</code>or a <code>Reader</code>. A program that needs to write data to some destination needs an <code>OutputStream</code> or a <code>Writer</code>. This is also illustrated in the diagram below:</p>  graph LR;     Source--&gt;InputStream/Reader     InputStream/Reader--&gt;Program     Program--&gt;OutputStream/Writer     OutputStream/Writer--&gt;Destination  <ul> <li>An InputStream or Reader is linked to a source of data. An OutputStream or Writer is linked to a destination of data.</li> </ul>"},{"location":"java-core/java-core-io/#java-io-purposes-and-features","title":"Java IO Purposes and Features","text":"<p>Java IO contains many subclasses of the InputStream, OutputStream, Reader and Writer classes. The reason is, that all of these subclasses are addressing various different purposes. That is why there are so many different classes. The purposes addressed are summarized below:</p> <ul> <li>File Access</li> <li>Network Access</li> <li>Internal Memory Buffer Access</li> <li>Inter-Thread Communication (Pipes)</li> <li>Buffering</li> <li>Filtering</li> <li>Parsing</li> <li>Reading and Writing Text (Readers / Writers)</li> <li>Reading and Writing Primitive Data (long, int etc.)</li> <li>Reading and Writing Objects</li> </ul> <p>These purposes are nice to know about when reading through the Java IO classes. They make it somewhat easier to understand what the classes are targeting.</p>"},{"location":"java-core/java-core-io/#java-io-class-overview","title":"Java IO Class Overview","text":"<p>|\u00a0|Byte Based||Character Based|| |Type\u00a0|Input|Output|Input|Output| |---|---|---|---|---| |Basic|InputStream|OutputStream|ReaderInputStreamReader|WriterOutputStreamWriter |Arrays|ByteArrayInputStream|ByteArrayOutputStream|CharArrayReader|CharArrayWriter| |Files|FileInputStreamRandomAccessFile|FileOutputStreamRandomAccessFile|FileReader|FileWriter| |Pipes|PipedInputStream|PipedOutputStream|PipedReader|PipedWriter| |Buffering|BufferedInputStream|BufferedOutputStream|BufferedReader|BufferedWriter| |Filtering|FilterInputStream|FilterOutputStream|FilterReader|FilterWriter| |Parsing|PushbackInputStreamStreamTokenizer|\u00a0|PushbackReaderLineNumberReader|\u00a0| |Strings|\u00a0|\u00a0|StringReader|StringWriter| |Data|DataInputStream|DataOutputStream|\u00a0|\u00a0| |Data Formatted|\u00a0|PrintStream|\u00a0|PrintWriter| |Objects|ObjectInputStream|ObjectOutputStream|\u00a0|\u00a0| |Utilities|SequenceInputStream|\u00a0|\u00a0|\u00a0|</p>"},{"location":"java-core/java-core-io/#file-and-directory","title":"File and Directory","text":"<p>File read and write.</p> <pre><code>private static void fileWriteAndRead() throws IOException {\n    // Create file instance\n    File file = new File(\"example-create-file.txt\");\n    // Check if file Exists\n    boolean fileExist = file.exists(); // false\n    System.out.println(\"File exists:\" + fileExist);\n    // Create file on disk\n    file.createNewFile();\n    // creates a FileWriter Object\n    Writer writer = new FileWriter(file);\n    // Write content to file\n    writer.write(\"hello, java io\");\n    writer.flush();\n    writer.close();\n\n    long length = file.length();\n    System.out.println(\"File length:\" + length);\n\n    // Creates a FileReader Object\n    FileReader reader = new FileReader(file);\n    int data = reader.read();\n    while (data != -1) {\n        System.out.print((char)data);\n        data = reader.read();\n    }\n    System.out.println();\n    reader.close();\n}\n</code></pre> <p>Output:</p> <pre><code>File exists:false\nFile length:14\nhello, java io\n</code></pre> <p>Rename and delete file.</p> <pre><code>private static void fileRenameAndDelete() throws IOException {\n    // rename file\n    File oldFile = new File(\"example-create-file.txt\");\n    File newFile = new File(\"renamed-file.txt\");\n    oldFile.renameTo(newFile);\n    System.out.println(\"Old file exists:\" + oldFile.exists()); // false\n    System.out.println(\"New file exists:\" + newFile.exists()); // true\n\n    // delete file\n    newFile.delete();\n    System.out.println(\"New file exists:\" + newFile.exists()); // false\n}\n</code></pre> <p>Output:</p> <pre><code>Old file exists:false\nNew file exists:true\nNew file exists:false\n</code></pre> <p>Create directory, get files from directory.</p> <pre><code>private static void directory() throws IOException {\n    String directoryPath = \"javaio/newdir\";\n    File dir1 = new File(directoryPath);\n    // Clean directory if exists\n    if (dir1.exists()) {\n        deleteDirectory(dir1);\n    }\n\n    // Create a Directory if it does not exist\n    //boolean dirCreated = dir1.mkdir(); // won't work\n    boolean dirCreated = dir1.mkdirs(); // return true\n    System.out.println(\"Directory exists:\" + dir1.exists()); // true\n\n    boolean isDirectory = dir1.isDirectory(); // return true\n\n    // Create multiple files\n    for (int i = 1 ; i &lt;= 5 ; i++){\n        File file = new File(dir1, \"name\" + i + \".txt\") ;\n        file.createNewFile();\n    }\n    // List files in directory\n    File dir2 = new File(directoryPath);\n    String[] fileNames = dir2.list();\n    Arrays.sort(fileNames);\n    for (String filename : fileNames) {\n        System.out.println(filename);\n    }\n    // Absolute file path\n    File[] files = dir2.listFiles();\n    Arrays.sort(files);\n    for (File file : files) {\n        System.out.println(file.getAbsoluteFile());\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>Directory exists:true\nname1.txt\nname2.txt\nname3.txt\nname4.txt\nname5.txt\n/Users/Johnny/GitHub/java-programming/javaio/newdir/name1.txt\n/Users/Johnny/GitHub/java-programming/javaio/newdir/name2.txt\n/Users/Johnny/GitHub/java-programming/javaio/newdir/name3.txt\n/Users/Johnny/GitHub/java-programming/javaio/newdir/name4.txt\n/Users/Johnny/GitHub/java-programming/javaio/newdir/name5.txt\n</code></pre> <p>Delete directory and all files inside it.</p> <pre><code>private static boolean deleteDirectory(File dir) {\n    File[] files = dir.listFiles();\n    if (files != null) {\n        for (File file : files) {\n            // recursively delete\n            deleteDirectory(file);\n        }\n    }\n    return dir.delete();\n}\n</code></pre>"},{"location":"java-core/java-core-io/#file-stream","title":"File Stream","text":"<pre><code>public static void main(String[] args) throws IOException {\n    String path = \"fileForStream.txt\";\n    File file = new File(path);\n    FileOutputStream output = new FileOutputStream(file, false); // true: append, false: overwrite\n    String content = \"hello, file stream\";\n    System.out.println(\"Write to file: \" + content);\n    output.write(content.getBytes());\n    output.flush();\n    output.close();\n\n    FileInputStream input = new FileInputStream(file);\n    System.out.print(\"Read from file: \");\n    int data = input.read();\n    while (data != -1) {\n        System.out.print((char)data);\n        data = input.read();\n    }\n    System.out.println();\n    input.close();\n}\n</code></pre> <p>Output:</p> <pre><code>Write to file: hello, file stream\nRead from file: hello, file stream\n</code></pre>"},{"location":"java-core/java-core-io/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java IO on GitHub</li> </ul>"},{"location":"java-core/java-core-io/#references","title":"References","text":"<ul> <li>Java IO Tutorial</li> <li>Java IO Tutorials and Examples</li> </ul>"},{"location":"java-core/java-core-iterator/","title":"Iterator","text":"<p>Iterator and customize it for different purposes.</p>"},{"location":"java-core/java-core-iterator/#iterator-interface","title":"Iterator Interface","text":"<p>The <code>Iterator</code> interface is used for iterating (looping) various collection classes such as HashMap, ArrayList, LinkedList etc. It has three methods:</p> <ul> <li><code>hasNext()</code> - Returns true if the iteration has more elements.</li> <li><code>next()</code> - Returns the next element in the iteration.</li> <li><code>remove()</code> - Removes from the underlying collection the last element returned by this iterator (optional operation).</li> </ul>"},{"location":"java-core/java-core-iterator/#getting-and-using-iterator","title":"Getting and Using Iterator","text":"<p>In general, to use an iterator to cycle through the contents of a collection, follow these steps:</p> <ul> <li>Obtain an iterator to the start of the collection by calling the collection's <code>iterator()</code> method.</li> <li>Set up a loop that makes a call to <code>hasNext()</code>. Have the loop iterate as long as hasNext() returns true.</li> <li>Within the loop, obtain each element by calling <code>next()</code>.</li> </ul> <p>Example for how to use iterator.</p> <pre><code>import java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class IteratorExample {\n    public static void main(String args[]){\n        List&lt;String&gt; names = new ArrayList();\n        names.add(\"Peter\");\n        names.add(\"Paul\");\n        names.add(\"Johnny\");\n\n        Iterator&lt;String&gt; it = names.iterator();\n\n        while (it.hasNext()) {\n            String str = it.next();\n            System.out.println(str);\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Peter\nPaul\nJohnny\n</code></pre>"},{"location":"java-core/java-core-iterator/#concurrentmodificationexception-while-using-iterator","title":"ConcurrentModificationException while using Iterator","text":"<p>We cannot add or remove elements to the collection while using iterator over it.</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n\npublic class ModificationExceptionExample {\n    public static void main(String args[]){\n        List&lt;String&gt; books = new ArrayList&lt;&gt;();\n        books.add(\"C\");\n        books.add(\"Java\");\n        books.add(\"Python\");\n\n        for (String book : books) {\n            System.out.println(book);\n            //We are adding element while iterating list\n            books.add(\"C++\");\n        }\n    }\n}\n</code></pre> <p>ConcurrentModificationException occurs at line of <code>books.add(\"C++\")</code>.</p> <pre><code>Exception in thread \"main\" java.util.ConcurrentModificationException\n    at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901)\n    at java.util.ArrayList$Itr.next(ArrayList.java:851)\n    at johnny.java.core.iterator.ModificationExceptionExample.main(ModificationExceptionExample.java:13)\nC\n</code></pre>"},{"location":"java-core/java-core-iterator/#custom-iterator","title":"Custom Iterator","text":""},{"location":"java-core/java-core-iterator/#sorted-iterator","title":"Sorted Iterator","text":"<p>Create an iterator which accepts an integer array and returns its elements in increasing order. For example, the given array is [3,6,8,2,4,7,1], this iterator returns [1,2,3,4,6,7,8] if we keep calling the next() method.</p> <p>Create a class with implementing Iterator interface. Override the <code>hasNext()</code> and <code>next()</code> method.</p> <pre><code>import java.util.Arrays;\nimport java.util.Iterator;\n\npublic class SortedIterator implements Iterator&lt;Integer&gt; {\n\n    private Integer[] nums;\n    private int index;\n    public SortedIterator(int[] arr) {\n        if (arr != null &amp;&amp; arr.length &gt; 0) {\n            this.nums = new Integer[arr.length];\n            Arrays.sort(arr);\n            for (int i = 0; i &lt; arr.length; i++) {\n                nums[i] = arr[i];\n            }\n            index = 0;\n        } else {\n            nums = new Integer[]{};\n            index = 0;\n        }\n    }\n\n    @Override\n    public boolean hasNext(){\n        return index &gt;= 0 &amp;&amp; index &lt; nums.length;\n    }\n\n    @Override\n    public Integer next() {\n        if (index &lt; 0 || index &gt;= nums.length) {\n            return null;\n        }\n\n        return nums[index++];\n    }\n}\n</code></pre> <p>Testing.</p> <pre><code>public class SortedIteratorExample {\n    public static void main(String args[]){\n        SortedIterator iterator = new SortedIterator(new int[]{3,6,8,2,4,7,1});\n\n        while (iterator.hasNext()) {\n            Integer num = iterator.next();\n            System.out.println(num);\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>1\n2\n3\n4\n6\n7\n8\n</code></pre>"},{"location":"java-core/java-core-iterator/#common-element-iterator","title":"Common Element Iterator","text":"<p>Give two sorted iterator, implement a common element iterator. For example: Suppose we have iterator1, which contains int array [1,3,5,7,9]. And we also have iterator2, which contains int array [2,3,4,8,9]. The common element iterator should return the common elements in the above two iterators, [3,9].</p> <p>Create a class with implementing Iterator interface. Override the <code>hasNext()</code> and <code>next()</code> method.</p> <pre><code>import java.util.Iterator;\n\npublic class CommonIterator implements Iterator {\n\n    private SortedIterator itr1;\n    private SortedIterator itr2;\n    private Integer common;\n\n    public CommonIterator(SortedIterator itr1, SortedIterator itr2) {\n        this.itr1 = itr1;\n        this.itr2 = itr2;\n    }\n\n    @Override\n    public boolean hasNext(){\n        if (common != null) {\n            return true;\n        }\n\n        if (!itr1.hasNext() || !itr2.hasNext()) {\n            return false;\n        }\n\n        Integer num1 = itr1.next();\n        Integer num2 = itr2.next();\n\n        if (num1 == num2) {\n            common = num1;\n            return true;\n        }\n\n        while (num1 != num2) {\n            if (num1 &lt; num2) {\n                if (!itr1.hasNext()) {\n                    return false;\n                }\n                num1 = itr1.next();\n            } else {\n                if (!itr2.hasNext()) {\n                    return false;\n                }\n                num2 = itr2.next();\n            }\n        }\n\n        common = num1;\n        return true;\n    }\n\n    @Override\n    public Integer next() {\n        if (hasNext()) {\n            int temp = common;\n            common = null;\n            return temp;\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre> <p>Testing.</p> <pre><code>import johnny.java.core.iterator.custom.CommonIterator;\nimport johnny.java.core.iterator.custom.SortedIterator;\n\npublic class CommonIteratorExample {\n    public static void main(String args[]){\n        SortedIterator itr1 = new SortedIterator(new int[]{1,3,5,7,9});\n        SortedIterator itr2 = new SortedIterator(new int[]{2,3,4,8,9});\n        CommonIterator iterator = new CommonIterator(itr1, itr2);\n\n        while (iterator.hasNext()) {\n            Integer num = iterator.next();\n            System.out.println(num);\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>3\n9\n</code></pre>"},{"location":"java-core/java-core-iterator/#removable-iterator","title":"Removable Iterator","text":"<p>Given a list of integer, use it to implement iterator, override <code>remove</code> method. Notice that the remove method only remove the <code>last visited element</code>(visited by next() method).</p> <pre><code>import java.util.Iterator;\nimport java.util.List;\n\npublic class RemovableIterator implements Iterator&lt;Integer&gt; {\n\n    private List&lt;Integer&gt; list;\n    private int last = -1;\n    private int curr = 0;\n    public RemovableIterator(List&lt;Integer&gt; list) {\n        this.list = list;\n    }\n\n    @Override\n    public boolean hasNext(){\n        if (curr &lt; list.size()) {\n            return true;\n        }\n\n        return false;\n    }\n\n    @Override\n    public Integer next() {\n        if (hasNext()) {\n            last = curr;\n            curr++;\n            return list.get(last);\n        }\n\n        return null;\n    }\n\n    @Override\n    public void remove() {\n        if (last &gt; 0) {\n            //throw exception\n        }\n\n        list.remove(last);\n        curr = last; // keep the current position\n        last = -1;\n    }\n}\n</code></pre> <p>Test with with deleting elements 2 and 8.</p> <pre><code>import johnny.java.core.iterator.custom.RemovableIterator;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class RemovableIteratorExample {\n    public static void main(String args[]){\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(new Integer[]{3,5,6,8,2,4,7,1}));\n        RemovableIterator iterator = new RemovableIterator(list);\n        while (iterator.hasNext()){\n            Integer number = iterator.next();\n            System.out.println(\"Processing - \" + number);\n\n            if(number == 8 || number == 2) {\n                iterator.remove();\n            }\n        }\n\n        System.out.println(\"list after iteration = \" + list);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Processing - 3\nProcessing - 5\nProcessing - 6\nProcessing - 8\nProcessing - 2\nProcessing - 4\nProcessing - 7\nProcessing - 1\nlist after iteration = [3, 5, 6, 4, 7, 1]\n</code></pre>"},{"location":"java-core/java-core-iterator/#predicate-iterator","title":"Predicate Iterator","text":"<p>First, create a custom <code>predicate</code>, which returns true only if the given value is larger than 5.</p> <pre><code>public class BiggerThanFivePredicate implements Predicate&lt;Integer&gt; {\n    @Override\n    public boolean test(Integer val) {\n\n        Integer five = 5;\n\n        return val &gt; five;\n    }\n}\n</code></pre> <p>Then, create the custom iterator with this predicate. Override the <code>hasNext()</code> and <code>next()</code> method. Use the custom predicate to filter out unmatched data.</p> <pre><code>public class PredicateIterator implements Iterator&lt;Integer&gt; {\n    private Iterator&lt;Integer&gt; itr;\n    private BiggerThanFivePredicate btf;\n    private Integer next;\n    public PredicateIterator(Iterator&lt;Integer&gt; itr, BiggerThanFivePredicate btf) {\n        this.itr = itr;\n        this.btf = btf;\n    }\n\n    @Override\n    public boolean hasNext(){\n        if (next != null) {\n            return true;\n        }\n\n        while (itr.hasNext()) {\n            Integer num = itr.next();\n            if (btf.test(num)) {\n                next = num;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public Integer next() {\n        if (hasNext()) {\n            int temp = next;\n            next = null;\n            return temp;\n        }\n\n        return null;\n    }\n}\n</code></pre> <p>Testing.</p> <pre><code>import johnny.java.core.iterator.custom.BiggerThanFivePredicate;\nimport johnny.java.core.iterator.custom.PredicateIterator;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class PredicateIteratorExample {\n    public static void main(String args[]){\n        List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(new Integer[]{3,5,6,8,2,4,7,1}));\n        BiggerThanFivePredicate btf = new BiggerThanFivePredicate();\n        PredicateIterator iterator = new PredicateIterator(list.iterator(), btf);\n\n        while (iterator.hasNext()) {\n            Integer num = iterator.next();\n            System.out.println(num);\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>6\n8\n7\n</code></pre>"},{"location":"java-core/java-core-iterator/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Iterator on GitHub</li> </ul>"},{"location":"java-core/java-core-iterator/#references","title":"References","text":"<ul> <li>Java Doc - Interface Iterator</li> <li>Java Predicate</li> <li>Java Iterator with examples</li> </ul>"},{"location":"java-core/java-core-java-tricks/","title":"Java tricks","text":""},{"location":"java-core/java-core-java-tricks/#overflow-when-assigning-integer-value","title":"Overflow when assigning Integer value","text":"<p>As we all know, the range of Integer in java is from -2147483648(-2^31) to 2147483647(2^31 - 1). And we use constant Integer.MIN_VALUE to represent -2147483648, and Integer.MAX_VALUE to represent 2147483647. When trying to increment the max value or decrement the min value, overflow occurs. That is</p> <pre><code>Integer.MAX_VALUE + 1 = Integer.MIN_VALUE;\nInteger.MIN_VALUE - 1 = Integer.MAX_VALUE;\n</code></pre> <p>If you try to assign Integer.MAX_VALUE + 1 to a long type variable, the result may not be what you want.</p> <pre><code>long var1 = Integer.MAX_VALUE + 1; //var1 = -2147483648\n</code></pre> <p>You will get var1 = -2147483648 instead of desired 2147483648. The following statement doesn't work, either.</p> <pre><code>long var1 = (long)(Integer.MAX_VALUE + 1);\n</code></pre> <p>The correct way is to cast the variable to long type before adding. The following two approaches will work.</p> <pre><code>long var1 = Integer.MAX_VALUE;\nvar1 = var1 + 1;\n\n//or\nlong var1 = (long)Integer.MAX_VALUE + 1;\n</code></pre>"},{"location":"java-core/java-core-java-tricks/#how-a-primitive-floatdouble-value-can-be-00","title":"How a primitive float/double value can be -0.0?","text":"<p>Float is a tricky type in java.  </p>"},{"location":"java-core/java-core-java-tricks/#the-first-issue-is-precision-of-float","title":"The first issue is precision of float","text":"<p>You could never be able to store a floating point number of infinite precision with finite resources. You should never test if a floating point number == to some other, i.e. never write code like this:</p> <pre><code>if (a == b)\n</code></pre> <p>where a and b are floats. Due to rounding errors those two numbers might be stored as different values in memory. You should define a precision you want to work with:</p> <pre><code>private final static double EPSILON = 0.00001;\n</code></pre> <p>and then test against the precision you need</p> <pre><code>if (Math.abs(a - b) &lt; epsilon)\n</code></pre>"},{"location":"java-core/java-core-java-tricks/#the-second-is-the-negative-zero-value-00","title":"The second is the negative zero value, -0.0","text":"<p>When I working on an algorithm problem 149. Max Points on a Line in leetcode.com, I need to calculate the slope of two points, below are the original codes.</p> <pre><code>slope = (double)(points[i].y - points[j].y) / (points[i].x - points[j].x);\n</code></pre> <p>My program runs failed for one test case: [2,3],[3,3],[-5,3]. After debugging, I found the root cause is because of negative -0.0. The slope between point[2,3] and point[3,3] is -0.0. And the slope between point[2,3] and point[-5,3] is 0.0. But actually they are all in the same line with slope 0.0.</p> <p>I updated my code to add 0.0 at the end of the line to make sure no negative zero appears. The problem is solved, and my solution passed all test cases.</p> <pre><code>slope = (double)(points[i].y - points[j].y) / (points[i].x - points[j].x) + 0.0;\n</code></pre>"},{"location":"java-core/java-core-java-tricks/#reference","title":"Reference","text":"<ul> <li>How can a primitive float value be -0.0? What does that mean?</li> <li>What Every Computer Scientist Should Know About Floating-Point Arithmetic</li> </ul>"},{"location":"java-core/java-core-java-tricks/#difference-between-i-and-i-in-a-loop","title":"Difference between i++ and ++i in a loop?","text":"<ul> <li>i++ =&gt; add 1 to a, returns the old value.</li> <li>++i =&gt; add 1 to a, returns the new value.</li> </ul> <pre><code>String[] items = {\"a\",\"b\",\"c\",\"d\"};\nint i = 0;\nfor (String item : items) {\n    System.out.print(++i);\n}\nSystem.out.println();\n\ni = 0;\nfor (String item : items) {\n    System.out.print(i++);\n}\nSystem.out.println();\n\n//output\n1234\n0123\n</code></pre> <p>The below two <code>for</code> loops print the same output.</p> <pre><code>for (int i = 0; i &lt; 5; i++) {\n    System.out.print(i);\n}\nSystem.out.println();\nfor (int i = 0; i &lt; 5; ++i) {\n    System.out.print(i);\n}\n\n//output\n01234\n01234\n</code></pre>"},{"location":"java-core/java-core-java-tricks/#is-java-pass-by-reference-or-pass-by-value","title":"Is Java \u201cpass-by-reference\u201d or \u201cpass-by-value\u201d?","text":"<p>Everything in Java is pass-by-value. For class object, it pass its address to method.</p> <pre><code>public class Main{\n    public static void main(String[] args){\n        Foo f = new Foo(\"f\");\n        changeReference(f); // It won't change the reference!\n        System.out.println(f.val); // Prints 'f'\n        modifyReference(f); // It will modify the object that the reference variable \"f\" refers to!\n        System.out.println(f.val); // Prints 'c'\n        setToNull(f); // f wont't be null\n        System.out.println(f.val); // Still prints 'c'\n    }\n    public static void changeReference(Foo a){\n        Foo b = new Foo(\"b\");\n        a = b;\n    }\n    public static void modifyReference(Foo c){\n        c.setAttribute(\"c\");\n    }\n    public static void setToNull(Foo d){\n        d = null;\n    }\n    private static class Foo {\n        public String val = \"\";\n        public Foo (String val) {\n            this.val = val;\n        }\n        public void setAttribute(String val) {\n            this.val = val;\n        }\n    }\n}\n</code></pre> <p>Notice, method <code>setToNull(Foo d)</code> won't work, object 'f' is still a non-null object.</p>"},{"location":"java-core/java-core-java-tricks/#reference-2","title":"Reference 2","text":"<p>Search the same code in the page of below link, there is an diagram explains why.</p> <ul> <li>Is Java \u201cpass-by-reference\u201d or \u201cpass-by-value\u201d?</li> </ul>"},{"location":"java-core/java-core-java-tricks/#convert-enum-to-string","title":"Convert Enum to String","text":"<p>When using Enum, we probably encounter the situation that we need to convert it to String. We can call 'toString()' method.</p> <pre><code>enum Color {\n  RED, GREEN, BLUE;\n}\npublic static void main(String[] args)\n{\n  Color c1 = Color.RED;\n  String strColor = c1.toString();  // type cast\n  System.out.println(strColor);\n}\n</code></pre> <p>Better solution. Define the Enum type with String.</p> <pre><code>public enum Color {\n   RED(\"RED\"),\n   GREEN(\"GREEN\"),\n   BLUE(\"BLUE\");\n\n   private String name;\n   private Color (String name)\n   {\n       this.name = name;\n   }\n   public String getName()\n   {\n       return name;\n   }\n}\n\npublic static void main(String[] args)\n{\n  String strColor = Color.RED.getName(); // no type cast\n  System.out.println(strColor);\n}\n</code></pre>"},{"location":"java-core/java-core-java-tricks/#reference-3","title":"Reference 3","text":"<ul> <li>Best way to create enum of strings?</li> </ul>"},{"location":"java-core/java-core-map/","title":"Map","text":"<p>Map, HashMap and TreeMap.</p>"},{"location":"java-core/java-core-map/#map-interface","title":"Map interface","text":""},{"location":"java-core/java-core-map/#hashmap","title":"HashMap","text":"<ul> <li>Interface: java.util.Map</li> <li>Class: java.util.HashMap</li> </ul>"},{"location":"java-core/java-core-map/#constructor","title":"Constructor","text":"<p>There are three constructors in Java HashMap class.</p> <ul> <li>public HashMap()</li> <li>public HashMap(int initialCapacity)</li> <li>public HashMap(int initialCapacity, float loadFactor)</li> <li>public HashMap(Map&lt;? extends K, ? extends V&gt; m)</li> </ul> <pre><code>private static void constructHashMap() {\n    Map&lt;String, String&gt; map1 = new HashMap&lt;&gt;();\n    map1.put(\"A\", \"A\"); // put example\n    map1.put(\"B\", \"B\");\n    map1.put(\"C\", \"C\");\n    map1.put(\"D\", null); // null value\n    map1.put(null, \"Z\"); // null key\n    System.out.println(\"Construct HashMap: \" + map1);\n\n    // initial capacity should be power of 2\n    Map&lt;String, String&gt; map2 = new HashMap&lt;&gt;(32);\n\n    // setting backing HashMap initial capacity and load factor\n    Map&lt;String, String&gt; map3 = new HashMap&lt;&gt;(32, 0.80f);\n\n    // creating HashMap from another Map\n    Map&lt;String, String&gt; map4 = new HashMap&lt;&gt;(map1);\n    System.out.println(\"Construct HashMap with another map: \" + map4);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct HashMap: {null=Z, A=A, B=B, C=C, D=null}\nConstruct HashMap with another map: {null=Z, A=A, B=B, C=C, D=null}\n</code></pre>"},{"location":"java-core/java-core-map/#common-operations","title":"Common Operations","text":"<ul> <li>hashMap.put(key, value);</li> <li>hashMap.containsKey(key);</li> <li>hashMap.get(key);</li> <li>hashMap.remove(key);</li> <li>hashMap.keySet();</li> <li>hashMap.values();</li> <li>hashMap.entrySet();</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // Add key value pair to map\n    Map&lt;String, String&gt; hashMap = new HashMap&lt;&gt;();\n    hashMap.put(\"A\", \"A\"); // put example\n    hashMap.put(\"B\", \"B\");\n    hashMap.put(\"C\", \"C\");\n    hashMap.put(\"D\", null); // null value\n    hashMap.put(null, \"Z\"); // null key\n\n    // Check key existence\n    System.out.println(\"Check whether key 'A' exists: \" + hashMap.containsKey(\"A\"));\n    System.out.println(\"Check whether key 'D' exists: \" + hashMap.containsKey(\"D\"));\n    System.out.println(\"Check whether key 'M' exists: \" + hashMap.containsKey(\"M\"));\n    System.out.println(\"Check whether key 'null' exist : \" + hashMap.containsKey(null));\n\n    // Get value with key\n    System.out.println(\"Value for Key C = \" + hashMap.get(\"C\"));\n    System.out.println(\"Value for Key null = \" + hashMap.get(null));\n\n    // Keys\n    Set&lt;String&gt; keySet = hashMap.keySet();\n    System.out.println(\"Map keys = \" + keySet);\n\n    // Values\n    Collection&lt;String&gt; values = hashMap.values();\n    System.out.println(\"Map values = \" + values);\n\n    // Entries\n    Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = hashMap.entrySet();\n    System.out.println(\"Map entries = \" + entrySet);\n\n    // Remove\n    hashMap.remove(\"B\");\n    System.out.println(\"Remove entry whose key is B : \" + hashMap);\n}\n</code></pre> <p>Output.</p> <pre><code>Check whether key 'A' exists: true\nCheck whether key 'D' exists: true\nCheck whether key 'M' exists: false\nCheck whether key 'null' exist : true\nValue for Key C = C\nValue for Key null = Z\nMap keys = [null, A, B, C, D]\nMap values = [Z, A, B, C, null]\nMap entries = [null=Z, A=A, B=B, C=C, D=null]\nRemove entry whose key is B : {null=Z, A=A, C=C, D=null}\n</code></pre>"},{"location":"java-core/java-core-map/#traversal","title":"Traversal","text":"<p>There are two ways to traverse a list.</p> <ul> <li>for each(Key)</li> <li>for each(Value)</li> <li>for each(Entry)</li> <li>iterator(Key)</li> <li>iterator(Value)</li> <li>iterator(Entry)</li> </ul> <pre><code>private static void traverseHashMap() {\n    Map&lt;Integer, String&gt; fruits = new HashMap&lt;&gt;();\n    fruits.put(4, \"Banana\");\n    fruits.put(9, \"Apple\");\n    fruits.put(5, \"Orange\");\n    fruits.put(2, \"Mango\");\n\n    // for each key\n    for (Integer key : fruits.keySet()) {\n        System.out.println(\"Traverse Key(for each): processing - \" + key);\n    }\n\n    System.out.println();\n\n    // for each value\n    for (String value : fruits.values()) {\n        System.out.println(\"Traverse Value(for each): processing - \" + value);\n    }\n\n    System.out.println();\n\n    // for each entry(key, value)\n    for (Map.Entry&lt;Integer, String&gt; entry : fruits.entrySet()) {\n        System.out.println(\"Traverse Entry(for each): processing - \" + entry);\n    }\n\n    System.out.println();\n\n    // entry iterator\n    Iterator&lt;Integer&gt; iterator1 = fruits.keySet().iterator();\n\n    while (iterator1.hasNext()) {\n        Integer fruit = iterator1.next();\n        System.out.println(\"Traverse Key(iterator): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // entry iterator\n    Iterator&lt;String&gt; iterator2 = fruits.values().iterator();\n\n    while (iterator2.hasNext()) {\n        String fruit = iterator2.next();\n        System.out.println(\"Traverse Value(iterator): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // entry iterator\n    Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator3 = fruits.entrySet().iterator();\n\n    while (iterator3.hasNext()) {\n        Map.Entry&lt;Integer, String&gt; fruit = iterator3.next();\n        System.out.println(\"Traverse Entry(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse Key(for each): processing - 2\nTraverse Key(for each): processing - 4\nTraverse Key(for each): processing - 5\nTraverse Key(for each): processing - 9\n\nTraverse Value(for each): processing - Mango\nTraverse Value(for each): processing - Banana\nTraverse Value(for each): processing - Orange\nTraverse Value(for each): processing - Apple\n\nTraverse Entry(for each): processing - 2=Mango\nTraverse Entry(for each): processing - 4=Banana\nTraverse Entry(for each): processing - 5=Orange\nTraverse Entry(for each): processing - 9=Apple\n\nTraverse Key(iterator): processing - 2\nTraverse Key(iterator): processing - 4\nTraverse Key(iterator): processing - 5\nTraverse Key(iterator): processing - 9\n\nTraverse Value(iterator): processing - Mango\nTraverse Value(iterator): processing - Banana\nTraverse Value(iterator): processing - Orange\nTraverse Value(iterator): processing - Apple\n\nTraverse Entry(iterator): processing - 2=Mango\nTraverse Entry(iterator): processing - 4=Banana\nTraverse Entry(iterator): processing - 5=Orange\nTraverse Entry(iterator): processing - 9=Apple\n</code></pre>"},{"location":"java-core/java-core-map/#remove-element","title":"Remove Element","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>Map.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    Map&lt;Integer, String&gt; fruits = new HashMap&lt;&gt;();\n    fruits.put(4, \"Banana\");\n    fruits.put(9, \"Apple\");\n    fruits.put(5, \"Orange\");\n    fruits.put(2, \"Mango\");\n\n    // in for each loop\n    for (Integer key : fruits.keySet()) {\n        System.out.println(\"Traverse HashMap(for each): processing - \" + key);\n\n        if (key == 5) {\n            fruits.remove(5);  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;Integer&gt; iterator = fruits.keySet().iterator();\n\n    while (iterator.hasNext()){\n        Integer key = iterator.next();\n        System.out.println(\"Traverse HashMap(iterator): processing - \" + key);\n\n        if (key == 5) {\n            fruits.remove(5);  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits map after remove = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    Map&lt;Integer, String&gt; fruits = new HashMap&lt;&gt;();\n    fruits.put(4, \"Banana\");\n    fruits.put(9, \"Apple\");\n    fruits.put(5, \"Orange\");\n    fruits.put(2, \"Mango\");\n\n    Iterator&lt;Integer&gt; iterator = fruits.keySet().iterator();\n\n    while (iterator.hasNext()){\n        Integer key = iterator.next();\n        System.out.println(\"Remove element: processing - \" + key + \"=\" + fruits.get(key));\n\n        if (key == 5) {\n            iterator.remove(); // iterator.remove not set.remove\n        }\n    }\n\n    System.out.println(\"fruits map after remove = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - 2=Mango\nRemove element: processing - 4=Banana\nRemove element: processing - 5=Orange\nRemove element: processing - 9=Apple\nfruits map after remove = {2=Mango, 4=Banana, 9=Apple}\n</code></pre>"},{"location":"java-core/java-core-map/#treemap","title":"TreeMap","text":"<ul> <li>Interface: java.util.SortedMap</li> <li>Class: java.util.TreeMap</li> </ul>"},{"location":"java-core/java-core-map/#constructor-of-treemap","title":"Constructor of TreeMap","text":"<p>There are three constructors in Java TreeMap class.</p> <ul> <li>public TreeMap()</li> <li>public TreeMap(Comparator&lt;? super E&gt; comparator)</li> <li>public TreeMap(Map&lt;? extends K, ? extends V&gt; m)</li> </ul> <pre><code>private static void constructTreeMap() {\n    SortedMap&lt;String, String&gt; treeMap1 = new TreeMap&lt;&gt;();\n    treeMap1.put(\"A\", \"A\"); // put example\n    treeMap1.put(\"B\", \"B\");\n    treeMap1.put(\"C\", \"C\");\n    treeMap1.put(\"D\", null); // null value\n    //treeMap1.put(null, \"Z\"); // key can't be null\n    System.out.println(\"Construct TreeMap: \" + treeMap1);\n\n    // Comparator\n    SortedMap&lt;String, String&gt; treeMap2 = new TreeMap&lt;&gt;((a,b)-&gt;b.compareTo(a)); // reverse order\n    treeMap2.put(\"A\", \"A\");\n    treeMap2.put(\"B\", \"B\");\n    treeMap2.put(\"C\", \"C\");\n    treeMap2.put(\"D\", \"D\");\n    System.out.println(\"Construct TreeMap with comparator: \" + treeMap2);\n\n    // with another map\n    Map&lt;String, String&gt; map = new HashMap&lt;&gt;();\n    map.put(\"B\", \"B\");\n    map.put(\"A\", \"A\");\n    map.put(\"D\", \"D\");\n    map.put(\"C\", \"C\");\n\n    SortedMap&lt;String, String&gt; treeMap3 = new TreeMap&lt;&gt;(map);\n    System.out.println(\"Construct TreeMap with map: \" + treeMap3);\n\n    // creating TreeMap from another Map\n    Map&lt;String, String&gt; treeMap4 = new TreeMap&lt;&gt;(treeMap2);\n    System.out.println(\"Construct TreeMap with another treemap: \" + treeMap4);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct TreeMap: {A=A, B=B, C=C, D=null}\nConstruct TreeMap with comparator: {D=D, C=C, B=B, A=A}\nConstruct TreeMap with map: {A=A, B=B, C=C, D=D}\nConstruct TreeMap with another treemap: {D=D, C=C, B=B, A=A}\n</code></pre>"},{"location":"java-core/java-core-map/#common-operations-of-treemap","title":"Common Operations of TreeMap","text":"<ul> <li>treeMap.put(key, value);</li> <li>treeMap.containsKey(key);</li> <li>treeMap.get(key);</li> <li>treeMap.remove(item);</li> <li>treeMap.keySet();</li> <li>treeMap.values();</li> <li>treeMap.entrySet();</li> <li>treeMap.firstEntry();</li> <li>treeMap.lastEntry();</li> <li>treeMap.lowerKey(item);</li> <li>treeMap.higherKey(item);</li> <li>treeMap.lowerEntry(item);</li> <li>treeMap.higherEntry(item);</li> <li>treeMap.floorEntry(item);</li> <li>treeMap.ceilingEntry(item);</li> <li>treeMap.pollFirstEntry();</li> <li>treeMap.pollLastEntry();</li> <li>treeMap.subMap(fromKey, fromInclusive, toKey, toInclusive);</li> <li>treeMap.headSet(toKey, inclusive);</li> <li>treeMap.tailSet(fromKey, inclusive);</li> <li>treeMap.descendingSet();</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // Add\n    TreeMap&lt;Integer, String&gt; treeMap1 = new TreeMap&lt;&gt;();\n    for (int i = 0; i &lt; 10; i++) {\n        treeMap1.put(i, i + \"\");\n    }\n    System.out.println(\"Common operations - add : \" + treeMap1);\n\n    // Check existence\n    System.out.println(\"Check whether key 1 exists: \" + treeMap1.containsKey(1));\n    System.out.println(\"Check whether key 3 exists: \" + treeMap1.containsKey(3));\n    System.out.println(\"Check whether key 100 exists: \" + treeMap1.containsKey(100));\n\n    // Get value with key\n    System.out.println(\"Value for Key 1 = \" + treeMap1.get(1));\n    System.out.println(\"Value for Key 100 = \" + treeMap1.get(100));\n\n    // Keys\n    Set&lt;Integer&gt; keySet = treeMap1.keySet();\n    System.out.println(\"Map keys = \" + keySet);\n\n    // Values\n    Collection&lt;String&gt; values = treeMap1.values();\n    System.out.println(\"Map values = \" + values);\n\n    // Entries\n    Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entrySet = treeMap1.entrySet();\n    System.out.println(\"Map entries = \" + entrySet);\n\n    // lower and higher boundaries\n    System.out.println(\"First entry is: \" + treeMap1.firstEntry());\n    System.out.println(\"Last entry is: \" + treeMap1.lastEntry());\n    System.out.println(\"Closest lower key than 4 is: \"+ treeMap1.lowerKey(4));\n    System.out.println(\"Closest higher key than 4 is: \"+ treeMap1.higherKey(4));\n    System.out.println(\"Closest lower entry than 5 is: \" + treeMap1.lowerEntry(5));\n    System.out.println(\"Closest higher entry than 5 is: \" + treeMap1.higherEntry(5));\n    System.out.println(\"Closest floor entry than 5 is: \"+ treeMap1.floorEntry(5));\n    System.out.println(\"Closest ceiling entry than 4 is: \" + treeMap1.ceilingEntry(4));\n\n    // lower(n)   smaller than the given element\n    // floor(n)   smaller than or equal to the given element\n    // ceiling(n) larger than or equal to the given element\n    // higher(n)  larger than the given element\n\n    // poll first and last entries\n    System.out.println(\"First entry(Polled) is: \" + treeMap1.pollFirstEntry());\n    System.out.println(\"Last entry(Polled) is: \" + treeMap1.pollLastEntry());\n    System.out.println(\"TreeMap after polling: \" + treeMap1);\n\n    // submap, headmap and tailmap\n    Map&lt;Integer, String&gt; subMap = treeMap1.subMap(2, true, 6, true);\n    System.out.println(\"Submap from 2 to 6 is: \" + subMap);\n    System.out.println(\"HeadMap to 5: \" + treeMap1.headMap(5, true));\n    System.out.println(\"TailMap from 5: \" + treeMap1.tailMap(5, true));\n\n    // reverse\n    Map&lt;Integer, String&gt; descendingMap = treeMap1.descendingMap();\n    System.out.println(\"Descending map: \" + descendingMap);\n\n    // remove\n    treeMap1.remove(6);\n    System.out.println(\"Remove element 6 : \" + treeMap1);\n}\n</code></pre> <p>Output.</p> <pre><code>Common operations - add : {0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}\nCheck whether key 1 exists: true\nCheck whether key 3 exists: true\nCheck whether key 100 exists: false\nValue for Key 1 = 1\nValue for Key 100 = null\nMap keys = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nMap values = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nMap entries = [0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9]\nFirst entry is: 0=0\nLast entry is: 9=9\nClosest lower key than 4 is: 3\nClosest higher key than 4 is: 5\nClosest lower entry than 5 is: 4=4\nClosest higher entry than 5 is: 6=6\nClosest floor entry than 5 is: 5=5\nClosest ceiling entry than 4 is: 4=4\nFirst entry(Polled) is: 0=0\nLast entry(Polled) is: 9=9\nTreeMap after polling: {1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8}\nSubmap from 2 to 6 is: {2=2, 3=3, 4=4, 5=5, 6=6}\nHeadMap to 5: {1=1, 2=2, 3=3, 4=4, 5=5}\nTailMap from 5: {5=5, 6=6, 7=7, 8=8}\nDescending map: {8=8, 7=7, 6=6, 5=5, 4=4, 3=3, 2=2, 1=1}\nRemove element 6 : {1=1, 2=2, 3=3, 4=4, 5=5, 7=7, 8=8}\n</code></pre>"},{"location":"java-core/java-core-map/#traversal-of-treemap","title":"Traversal of TreeMap","text":"<p>There are two ways to traverse a list.</p> <ul> <li>for each(Key)</li> <li>for each(Value)</li> <li>for each(Entry)</li> <li>iterator(Key)</li> <li>iterator(Value)</li> <li>iterator(Entry)</li> </ul> <pre><code>private static void traverseTreeMap() {\n    SortedMap&lt;Integer, String&gt; fruits = new TreeMap&lt;&gt;();\n    fruits.put(4, \"Banana\");\n    fruits.put(9, \"Apple\");\n    fruits.put(5, \"Orange\");\n    fruits.put(2, \"Mango\");\n\n    // for each key\n    for (Integer key : fruits.keySet()) {\n        System.out.println(\"Traverse Key(for each): processing - \" + key);\n    }\n\n    System.out.println();\n\n    // for each value\n    for (String value : fruits.values()) {\n        System.out.println(\"Traverse Value(for each): processing - \" + value);\n    }\n\n    System.out.println();\n\n    // for each entry(key, value)\n    for (Map.Entry&lt;Integer, String&gt; entry : fruits.entrySet()) {\n        System.out.println(\"Traverse Entry(for each): processing - \" + entry);\n    }\n\n    System.out.println();\n\n    // entry iterator\n    Iterator&lt;Integer&gt; iterator1 = fruits.keySet().iterator();\n\n    while (iterator1.hasNext()) {\n        Integer fruit = iterator1.next();\n        System.out.println(\"Traverse Key(iterator): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // entry iterator\n    Iterator&lt;String&gt; iterator2 = fruits.values().iterator();\n\n    while (iterator2.hasNext()) {\n        String fruit = iterator2.next();\n        System.out.println(\"Traverse Value(iterator): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // entry iterator\n    Iterator&lt;Map.Entry&lt;Integer, String&gt;&gt; iterator3 = fruits.entrySet().iterator();\n\n    while (iterator3.hasNext()) {\n        Map.Entry&lt;Integer, String&gt; fruit = iterator3.next();\n        System.out.println(\"Traverse Entry(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse Key(for each): processing - 2\nTraverse Key(for each): processing - 4\nTraverse Key(for each): processing - 5\nTraverse Key(for each): processing - 9\n\nTraverse Value(for each): processing - Mango\nTraverse Value(for each): processing - Banana\nTraverse Value(for each): processing - Orange\nTraverse Value(for each): processing - Apple\n\nTraverse Entry(for each): processing - 2=Mango\nTraverse Entry(for each): processing - 4=Banana\nTraverse Entry(for each): processing - 5=Orange\nTraverse Entry(for each): processing - 9=Apple\n\nTraverse Key(iterator): processing - 2\nTraverse Key(iterator): processing - 4\nTraverse Key(iterator): processing - 5\nTraverse Key(iterator): processing - 9\n\nTraverse Value(iterator): processing - Mango\nTraverse Value(iterator): processing - Banana\nTraverse Value(iterator): processing - Orange\nTraverse Value(iterator): processing - Apple\n\nTraverse Entry(iterator): processing - 2=Mango\nTraverse Entry(iterator): processing - 4=Banana\nTraverse Entry(iterator): processing - 5=Orange\nTraverse Entry(iterator): processing - 9=Apple\n</code></pre>"},{"location":"java-core/java-core-map/#remove-element-of-treemap","title":"Remove Element of TreeMap","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>Map.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    SortedMap&lt;Integer, String&gt; fruits = new TreeMap&lt;&gt;();\n    fruits.put(4, \"Banana\");\n    fruits.put(9, \"Apple\");\n    fruits.put(5, \"Orange\");\n    fruits.put(2, \"Mango\");\n\n    // in for each loop\n    for (Integer key : fruits.keySet()) {\n        System.out.println(\"Traverse TreeMap(for each): processing - \" + key);\n\n        if (key == 5) {\n            fruits.remove(5);  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;Integer&gt; iterator = fruits.keySet().iterator();\n\n    while (iterator.hasNext()){\n        Integer key = iterator.next();\n        System.out.println(\"Traverse TreeMap(iterator): processing - \" + key);\n\n        if (key == 5) {\n            fruits.remove(5);  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits tree map after remove = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    SortedMap&lt;Integer, String&gt; fruits = new TreeMap&lt;&gt;();\n    fruits.put(4, \"Banana\");\n    fruits.put(9, \"Apple\");\n    fruits.put(5, \"Orange\");\n    fruits.put(2, \"Mango\");\n\n    Iterator&lt;Integer&gt; iterator = fruits.keySet().iterator();\n\n    while (iterator.hasNext()){\n        Integer key = iterator.next();\n        System.out.println(\"Remove element: processing - \" + key + \"=\" + fruits.get(key));\n\n        if (key == 5) {\n            iterator.remove(); // iterator.remove not set.remove\n        }\n    }\n\n    System.out.println(\"fruits tree map after remove = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - 2=Mango\nRemove element: processing - 4=Banana\nRemove element: processing - 5=Orange\nRemove element: processing - 9=Apple\nfruits tree map after remove = {2=Mango, 4=Banana, 9=Apple}\n</code></pre>"},{"location":"java-core/java-core-map/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Map on GitHub</li> </ul>"},{"location":"java-core/java-core-map/#references","title":"References","text":"<ul> <li>Java Doc - Controlling Access to Members of a Class</li> <li>Core Java Tutorial</li> <li>Java Data Types</li> <li>Primitive Wrapper Classes are Immutable in Java</li> <li>Collections in Java \u2013 Tutorial</li> </ul>"},{"location":"java-core/java-core-nio/","title":"NIO","text":"<p>Read and write file with NIO APIs.</p>"},{"location":"java-core/java-core-nio/#nio-overview","title":"NIO Overview","text":"<p>The new input/output (<code>NIO</code>) library was introduced with JDK 1.4. Java NIO offers a different way of working with IO than the standard IO API's.</p> <p>Java NIO consist of the following core components:</p> <ul> <li>Channels</li> <li>Buffers</li> <li>Selectors</li> </ul> <p>The rest of the components, like <code>Pipe</code> and <code>FileLock</code> are merely utility classes to be used in conjunction with the three core components.</p>"},{"location":"java-core/java-core-nio/#channels-and-buffers","title":"Channels and Buffers","text":"<p>In the standard IO API you work with <code>byte streams</code> and <code>character streams</code>.</p>  graph LR;     Source--&gt;InputStream/Reader     InputStream/Reader--&gt;Program     Program--&gt;OutputStream/Writer     OutputStream/Writer--&gt;Destination  <p>In NIO you work with <code>channels</code> and <code>buffers</code>. Data is always read from a channel into a buffer, or written from a buffer to a channel.</p>  graph LR;     Source--&gt;Channel/Buffer     Channel/Buffer--&gt;Destination"},{"location":"java-core/java-core-nio/#non-blocking-io","title":"Non-blocking IO","text":"<p>Java NIO enables you to do <code>non-blocking IO</code>. For instance, a thread can ask a channel to read data into a buffer. While the channel reads data into the buffer, the thread can do something else. Once data is read into the buffer, the thread can then continue processing it. The same is true for writing data to channels.</p>"},{"location":"java-core/java-core-nio/#selectors","title":"Selectors","text":"<p>Java NIO contains the concept of <code>selectors</code>. A selector is an object that can monitor multiple channels for events (like: connection opened, data arrived etc.). Thus, a single thread can monitor multiple channels for data.</p>"},{"location":"java-core/java-core-nio/#channels-and-buffers_1","title":"Channels and Buffers","text":"<p>Typically, all IO in NIO starts with a Channel. A Channel is a like a stream.</p> <p>From the Channel data can be read into a Buffer.</p>  graph LR;     sr(Channel) -- Read --&gt; rr[Buffer]     classDef orange fill:#F9B075,stroke:#E77C23,stroke-width:3px     classDef green fill:#A1BE62,stroke:#4F6128,stroke-width:3px     class sr orange     class rr green  <p>Data can also be written from a Buffer into a Channel.</p>  graph RL;     rr[Buffer] -- Write --&gt; sr(Channel)     classDef orange fill:#F9B075,stroke:#E77C23,stroke-width:3px     classDef green fill:#A1BE62,stroke:#4F6128,stroke-width:3px     class sr orange     class rr green  <p>There are several Channel and Buffer types. Here is a list of the primary Channel implementations in Java NIO: * FileChannel * DatagramChannel * SocketChannel * ServerSocketChannel</p> <p>These channels cover UDP + TCP network IO, and file IO.</p> <p>Here is a list of the core Buffer implementations in Java NIO: * ByteBuffer * CharBuffer * DoubleBuffer * FloatBuffer * IntBuffer * LongBuffer * ShortBuffer</p> <p>These Buffer's cover the basic data types that you can send via IO: byte, short, int, long, float, double and characters.</p>"},{"location":"java-core/java-core-nio/#read-files","title":"Read Files","text":"<p>Suppose we have a file named 'text.txt' with the following content.</p> <pre><code>iPad Pro(Latest Version)\nModel: 12.9-inch iPad Pro\nColor: Space Gray\nStorage: 256GB\nConnectivity: WiFI\nPrice: $1149.00\n</code></pre>"},{"location":"java-core/java-core-nio/#read-file-with-bufferedreader","title":"Read File with BufferedReader","text":"<pre><code>// Read file with standard IO APIs\npublic static void main(String[] args) {\n    BufferedReader br = null;\n    String line = null;\n    try {\n        br = new BufferedReader(new FileReader(\"out/test.txt\"));\n        System.out.println(\"Reading file with BufferedReader...\");\n        while ((line = br.readLine()) != null) {\n            System.out.println(line);\n        }\n        br.close();\n    }\n    catch (IOException ioe) {\n        System.out.println(ioe);\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>Reading file with BufferedReader...\niPad Pro(Latest Version)\nModel: 12.9-inch iPad Pro\nColor: Space Gray\nStorage: 256GB\nConnectivity: WiFI\nPrice: $1149.00\n</code></pre>"},{"location":"java-core/java-core-nio/#read-file-with-buffer-of-file-size","title":"Read File with Buffer of File Size","text":"<pre><code>// Read a small file with buffer of file size\npublic static void main(String[] args) {\n    try {\n        RandomAccessFile raf = new RandomAccessFile(\"out/test.txt\",\"r\");\n        FileChannel channel = raf.getChannel();\n        long fileSize = channel.size();\n        ByteBuffer buffer = ByteBuffer.allocate((int) fileSize);\n        channel.read(buffer);\n        //buffer.rewind();\n        buffer.flip();\n        System.out.println(\"Reading file with Buffer of File Size...\");\n        for (int i = 0; i &lt; fileSize; i++) {\n            System.out.print((char) buffer.get());\n        }\n        buffer.clear();\n        channel.close();\n        raf.close();\n    }\n    catch (IOException ioe) {\n        System.out.println(ioe);\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>Reading file with Buffer of File Size...\niPad Pro(Latest Version)\nModel: 12.9-inch iPad Pro\nColor: Space Gray\nStorage: 256GB\nConnectivity: WiFI\nPrice: $1149.00\n</code></pre>"},{"location":"java-core/java-core-nio/#read-file-with-fixed-buffer-size","title":"Read File with Fixed Buffer Size","text":"<p>In case the file is very large, we can't read all contents into memory at once. In this case, we read it chunk by chunk. Each time, only small size is read.</p> <pre><code>// Read a large file with fixed size buffer\npublic static void main(String[] args) {\n    try {\n        int capacity = 32; // chunk size\n        RandomAccessFile raf = new RandomAccessFile(\"out/test.txt\", \"r\");\n        FileChannel channel = raf.getChannel();\n        ByteBuffer buffer = ByteBuffer.allocate(capacity);\n        System.out.println(\"Reading file with Buffer of Fixed Size...\");\n        //int chunk = 1;\n        while (channel.read(buffer) &gt; 0) {\n            //System.out.println(\"Chunk:\" + chunk++);\n            buffer.flip();\n            for (int i = 0; i &lt; buffer.limit(); i++) {\n                System.out.print((char) buffer.get());\n            }\n            buffer.clear(); // do something with the data and clear/compact it.\n        }\n        channel.close();\n        raf.close();\n    }\n    catch (IOException ioe) {\n        System.out.println(ioe);\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>Reading file with Buffer of Fixed Size...\niPad Pro(Latest Version)\nModel: 12.9-inch iPad Pro\nColor: Space Gray\nStorage: 256GB\nConnectivity: WiFI\nPrice: $1149.00\n</code></pre>"},{"location":"java-core/java-core-nio/#selectors_1","title":"Selectors","text":"<p>The Java <code>NIO Selector</code> is a component which can examine one or more Java NIO Channel instances, and determine which channels are ready for e.g. reading or writing. This way a single thread can manage multiple channels, and thus multiple network connections.</p>"},{"location":"java-core/java-core-nio/#why-use-a-selector","title":"Why Use a Selector?","text":"<p>The advantage of using just a single thread to handle multiple channels is that you need less threads to handle the channels. Actually, you can use just one thread to handle all of your channels. Switching between threads is expensive for an operating system, and each thread takes up some resources (memory) in the operating system too. Therefore, the less threads you use, the better.</p> <p>Here is an illustration of a thread using a Selector to handle 3 Channel's:</p>  graph TD     rr[Thread] --&gt; rf{Selector}     rf --&gt;|One| sr1(Channel)     rf --&gt;|Two| sr2(Channel)     rf --&gt;|Three| sr3(Channel)     classDef orange fill:#F9B075,stroke:#E77C23,stroke-width:3px     classDef red fill:#CF7875,stroke:#9F4A47,stroke-width:3px     classDef purple fill:#C8BCD7,stroke:#5F497A,stroke-width:3px     class sr1 orange     class sr2 orange     class sr3 orange     class rf red     class rr purple"},{"location":"java-core/java-core-nio/#channels-selector","title":"Channels &amp; Selector","text":"<p>In order to use a Channel with a Selector you must register the Channel with the Selector. Four events are available: - Connect - Accept - Read - Write</p> <p>These four events are represented by the four SelectionKey constants: * SelectionKey.OP_CONNECT * SelectionKey.OP_ACCEPT * SelectionKey.OP_READ * SelectionKey.OP_WRITE-</p> <pre><code>Selector selector = Selector.open();\nchannel.configureBlocking(false);\nSelectionKey key = channel.register(selector, SelectionKey.OP_READ);\n</code></pre>"},{"location":"java-core/java-core-nio/#example","title":"Example","text":"<p>We\u2019ll create an echo server and an echo client. The client connects to the server and starts sending messages to it. The server echoes back messages sent by each client. When the server encounters a specific message(\"Poison Pill\"), it interprets it as the end of the communication and closes the connection with the client.</p> <p>Below is a complete client-server example built with NIO Selector.</p> <p>1) The Server.</p> <pre><code>public class EchoServer {\n    private static final String POISON_PILL = \"POISON_PILL\";\n\n    public static void main(String[] args) throws IOException {\n        Selector selector = Selector.open();\n        ServerSocketChannel serverSocket = ServerSocketChannel.open();\n        serverSocket.bind(new InetSocketAddress(\"localhost\", 5454));\n        serverSocket.configureBlocking(false);\n        serverSocket.register(selector, SelectionKey.OP_ACCEPT);\n        ByteBuffer buffer = ByteBuffer.allocate(256);\n\n        while (true) {\n            int readyChannels = selector.selectNow();\n            if(readyChannels == 0) {\n                continue;\n            }\n            Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();\n            Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();\n            while (iter.hasNext()) {\n                SelectionKey key = iter.next();\n\n                if(key.isAcceptable()) {\n                    // a connection was accepted by a ServerSocketChannel.\n                    register(selector, serverSocket);\n                } else if (key.isConnectable()) {\n                    // a connection was established with a remote server.\n                } else if (key.isReadable()) {\n                    // a channel is ready for reading\n                    answerWithEcho(buffer, key);\n                } else if (key.isWritable()) {\n                    // a channel is ready for writing\n                }\n                iter.remove();\n            }\n        }\n    }\n\n    private static void answerWithEcho(ByteBuffer buffer, SelectionKey key)\n            throws IOException {\n\n        SocketChannel client = (SocketChannel) key.channel();\n        client.read(buffer);\n        if (new String(buffer.array()).trim().equals(POISON_PILL)) {\n            client.close();\n            System.out.println(\"Not accepting client messages anymore\");\n        }\n\n        buffer.flip();\n        client.write(buffer);\n        buffer.clear();\n    }\n\n    private static void register(Selector selector, ServerSocketChannel serverSocket)\n            throws IOException {\n\n        SocketChannel client = serverSocket.accept();\n        client.configureBlocking(false);\n        client.register(selector, SelectionKey.OP_READ);\n    }\n\n    public static Process start() throws IOException {\n        String javaHome = System.getProperty(\"java.home\");\n        String javaBin = javaHome + File.separator + \"bin\" + File.separator + \"java\";\n        String classpath = System.getProperty(\"java.class.path\");\n        String className = EchoServer.class.getCanonicalName();\n\n        ProcessBuilder builder = new ProcessBuilder(javaBin, \"-cp\", classpath, className);\n\n        return builder.start();\n    }\n}\n</code></pre> <p>2) The client.</p> <pre><code>public class EchoClient {\n    private static SocketChannel client;\n    private static ByteBuffer buffer;\n    private static EchoClient instance;\n\n    public static EchoClient start() {\n        if (instance == null)\n            instance = new EchoClient();\n\n        return instance;\n    }\n\n    public static void stop() throws IOException {\n        client.close();\n        buffer = null;\n    }\n\n    private EchoClient() {\n        try {\n            client = SocketChannel.open(new InetSocketAddress(\"localhost\", 5454));\n            buffer = ByteBuffer.allocate(256);\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    public String sendMessage(String msg) {\n        buffer = ByteBuffer.wrap(msg.getBytes());\n        String response = null;\n        try {\n            client.write(buffer);\n            buffer.clear();\n            client.read(buffer);\n            response = new String(buffer.array()).trim();\n            System.out.println(\"response=\" + response);\n            buffer.clear();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        return response;\n    }\n}\n</code></pre> <p>3) Test class.</p> <pre><code>public class EchoTest {\n\n    Process server;\n    EchoClient client;\n\n    @Before\n    public void setup() throws IOException, InterruptedException {\n        server = EchoServer.start();\n        Thread.sleep(2000); // sleep to make sure server is up.\n        client = EchoClient.start();\n    }\n\n    @Test\n    public void givenServerClient_whenServerEchosMessage_thenCorrect() {\n        String resp1 = client.sendMessage(\"hello\");\n        String resp2 = client.sendMessage(\"world\");\n        String disconnect = client.sendMessage(\"POISON_PILL\");\n        //String error = client.sendMessage(\"welcome\"); // will fail as connection is closed\n\n        assertEquals(\"hello\", resp1);\n        assertEquals(\"world\", resp2);\n        assertEquals(\"POISON_PILL\", disconnect);\n    }\n\n    @After\n    public void teardown() throws IOException {\n        server.destroy();\n        EchoClient.stop();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>response=hello\nresponse=world\nresponse=POISON_PILL\n</code></pre>"},{"location":"java-core/java-core-nio/#memory-mapped-files","title":"Memory-Mapped Files","text":""},{"location":"java-core/java-core-nio/#memory-mapped-io","title":"Memory Mapped IO","text":"<p>For conventional file I/O, in which user processes issue read() and write() system calls to transfer data, there is almost always <code>one or more</code> copy operations to move the data between these filesystem pages in <code>kernel space</code> and a memory area in <code>user space</code>. This is because there is not usually a one-to-one alignment between filesystem pages and user buffers.</p> <p>There is, however, a special type of I/O operation supported by most operating systems that allows user processes to take maximum advantage of the page-oriented nature of system I/O and completely <code>avoid buffer copies</code>. This is called <code>memory-mapped I/O</code> and we are going to learn few things here around memory-mapped files.</p>"},{"location":"java-core/java-core-nio/#java-memory-mapped-files","title":"Java Memory-Mapped Files","text":"<p>Memory-mapped I/O uses the filesystem to establish a virtual memory mapping from user space directly to the applicable filesystem pages. With a memory-mapped file, we can pretend that the entire file is in memory and that we can access it by simply treating it as a very large array. This approach greatly simplifies the code we write in order to modify the file.</p> <p>To do both writing and reading in memory mapped files, we start with a <code>RandomAccessFile</code>, get a channel for that file. Memory mapped byte buffers are created via the <code>FileChannel.map()</code> method. This class extends the ByteBuffer class with operations that are specific to memory-mapped file regions.</p>"},{"location":"java-core/java-core-nio/#benefits-of-memory-mapped-files","title":"Benefits of Memory Mapped Files","text":"<p>Memory-Mapped IO have several advantages over normal I/O: * The user process sees the file data as memory, so there is no need to issue read() or write() system calls. * As the user process touches the mapped memory space, page faults will be generated automatically to bring in the file data from disk. If the user modifies the mapped memory space, the affected page is automatically marked as dirty and will be subsequently flushed to disk to update the file. * The virtual memory subsystem of the operating system will perform intelligent caching of the pages, automatically managing memory according to system load. * The data is always page-aligned, and <code>no buffer copying</code> is ever needed. * Very large files can be mapped without consuming large amounts of memory to copy the data.</p>"},{"location":"java-core/java-core-nio/#example-of-mappedbytebuffer","title":"Example of MappedByteBuffer","text":"<pre><code>public class MappedByteBufferExample {\n    private static String fileName = \"out/test.txt\";\n    private static String content;\n    static {\n        content = \"iPad Pro(Latest Version)\" + System.lineSeparator();\n        content += \"Model: 12.9-inch iPad Pro\" + System.lineSeparator();\n        content += \"Color: Space Gray \" + System.lineSeparator();\n        content += \"Storage: 256GB\" + System.lineSeparator();\n        content += \"Connectivity: WiFI\" + System.lineSeparator();\n        content += \"Price: $1149.00\";\n    }\n\n    // Read a large file with MappedByteBuffer\n    public static void main(String[] args) {\n        try {\n            prepare();\n            System.out.println();\n            readWithMappedByteBuffer(51);\n            System.out.println();\n            writeWithMappedByteBuffer(51, \"[Applecare: 1year]\" + System.lineSeparator());\n            System.out.println();\n            readWithMappedByteBuffer(0);\n        }\n        catch (Exception ex) {\n            System.out.println(ex);\n        }\n    }\n\n    private static void prepare() throws IOException {\n        // Create file object\n        File file = new File(fileName);\n\n        //Delete the file\n        file.delete();\n\n        try (FileOutputStream output = new FileOutputStream(file, false)) {\n            System.out.println(\"Preparing the file with content: \");\n            System.out.println(content);\n            output.write(content.getBytes());\n        }\n    }\n\n    private static void readWithMappedByteBuffer(int pos) throws Exception {\n        try (RandomAccessFile raf = new RandomAccessFile(fileName, \"r\")) {\n            FileChannel channel = raf.getChannel();\n            // specify the position where to start reading\n            MappedByteBuffer buffer = channel.map(FileChannel.MapMode.READ_ONLY, pos, channel.size() - pos);\n            buffer.load();\n            System.out.println(\"Reading file with MappedByteBuffer at position: \" + pos);\n            for (int i = 0; i &lt; buffer.limit(); i++) {\n                System.out.print((char) buffer.get());\n            }\n        }\n        System.out.println();\n    }\n\n    private static void writeWithMappedByteBuffer(int pos, String newline) throws Exception {\n        try (RandomAccessFile raf = new RandomAccessFile(new File(fileName), \"rw\")) {\n            // Get file channel in read-write mode\n            FileChannel fileChannel = raf.getChannel();\n\n            // Get direct byte buffer access using channel.map() operation\n            MappedByteBuffer buffer = fileChannel.map(FileChannel.MapMode.READ_WRITE, pos, newline.length());\n\n            //Write the content using put methods\n            System.out.println(\"Writing content to file with MappedByteBuffer at pos: \" + pos);\n            System.out.print(newline);\n            buffer.put(newline.getBytes());\n            System.out.println(\"Done!\");\n        }\n    }\n}\n</code></pre> <p>Output:</p> <pre><code>Preparing the file with content:\niPad Pro(Latest Version)\nModel: 12.9-inch iPad Pro\nColor: Space Gray\nStorage: 256GB\nConnectivity: WiFI\nPrice: $1149.00\n\nReading file with MappedByteBuffer at position: 51\nColor: Space Gray\nStorage: 256GB\nConnectivity: WiFI\nPrice: $1149.00\n\nWriting content to file with MappedByteBuffer at pos: 51\n[Applecare: 1year]\nDone!\n\nReading file with MappedByteBuffer at position: 0\niPad Pro(Latest Version)\nModel: 12.9-inch iPad Pro\n[Applecare: 1year]\nStorage: 256GB\nConnectivity: WiFI\nPrice: $1149.00\n</code></pre> <ul> <li>We can specify the <code>starting point</code> and the <code>length</code> when using MappedByteBuffer for reading or writing.</li> <li>In the output of reading, the first two lines are ignored.</li> <li>In the output of writing, the third line is overwritten to <code>[Applecare: 1year]</code>.</li> </ul>"},{"location":"java-core/java-core-nio/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java NIO on GitHub</li> </ul>"},{"location":"java-core/java-core-nio/#references","title":"References","text":"<ul> <li>Java NIO Tutorial</li> <li>3 Ways to Read Files \u2013 Java NIO</li> <li>Java Memory-Mapped Files \u2013 Java MappedByteBuffer</li> <li>Java NIO Selector</li> <li>Introduction to the Java NIO Selector</li> </ul>"},{"location":"java-core/java-core-scanner/","title":"Scanner","text":"<p>Scanner, System.io, System.out</p>"},{"location":"java-core/java-core-scanner/#input-types","title":"Input Types","text":"<p>Scanner methods.</p> Method Description <code>nextBoolean()</code> Reads a <code>boolean</code> value from the user <code>nextByte()</code> Reads a <code>byte</code> value from the user <code>nextDouble()</code> Reads a <code>double</code> value from the user <code>nextFloat()</code> Reads a <code>float</code> value from the user <code>nextInt()</code> Reads a <code>int</code> value from the user <code>nextLine()</code> Reads a <code>String</code> value from the user <code>nextLong()</code> Reads a <code>long</code> value from the user <code>nextShort()</code> Reads a <code>short</code> value from the user"},{"location":"java-core/java-core-scanner/#examples","title":"Examples","text":""},{"location":"java-core/java-core-scanner/#common-usage","title":"Common Usage","text":"<pre><code>import java.util.Scanner;\n\npublic class ScannerExample {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n\n        // String input\n        System.out.println(\"Enter name:\");\n        String name = scan.nextLine();\n        System.out.println(\"Your name is: \" + name);\n\n        // Int input\n        System.out.println(\"Enter age:\");\n        int age = scan.nextInt();\n        System.out.println(\"Your age is: \" + age);\n\n        // Double input\n        System.out.println(\"Enter salary:\");\n        double salary = scan.nextDouble();\n        System.out.println(\"Your salary is: \" + salary);\n    }\n}\n</code></pre> <p>Test by typing name, age and salary, check the output.</p> <pre><code>Enter name:\njohnny\nYour name is: johnny\nEnter age:\n29\nYour age is: 29\nEnter salary:\n8065\nYour salary is: 8065.0\n</code></pre>"},{"location":"java-core/java-core-scanner/#read-long-stringhasnext-next","title":"Read Long String(hasNext + next)","text":"<p>Use while loop to read input by words(space is the delimiter) and use <code>hasNext()</code> method to check if there is any more token. When the input is <code>quit</code>, exit the loop.</p> <pre><code>import java.util.Scanner;\n\npublic class NextExample {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Testing hasNext and next, input string:\");\n\n        String s = \"\";\n        while (scan.hasNext()) {\n            String next = scan.next();\n            if (next.equals(\"quit\")) {\n                break;\n            }\n            s += next + \"-\";\n        }\n        // Input 'quit' to stop the input\n        System.out.println(\"String: \" + s);\n    }\n}\n</code></pre> <p>Input two sentences and check the output.</p> <pre><code>Testing hasNext and next, input string:\nHi Johnny, how are you?\nI'm good, Lucy. Nice to see you again.\nquit\nString: Hi-Johnny,-how-are-you?-I'm-good,-Lucy.-Nice-to-see-you-again.-\n</code></pre>"},{"location":"java-core/java-core-scanner/#read-long-stringhasnextline-nextline","title":"Read Long String(hasNextLine + nextLine)","text":"<p>We can also read the input by lines with <code>hasNextLine()</code> and <code>nextLine()</code>.</p> <pre><code>import java.util.Scanner;\n\npublic class NextLineExample {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Testing hasNextLine and nextLine, input string:\");\n\n        String s = \"\";\n        while (scan.hasNextLine()) {\n            String nextline = scan.nextLine();\n            if (nextline.equals(\"quit\")) {\n                break;\n            }\n            s += nextline + \"-\";\n        }\n        // Input 'quit' to stop the input\n        System.out.println(\"String: \" + s);\n    }\n}\n</code></pre> <p>Input the same two sentences and check the difference.</p> <pre><code>Testing hasNextLine and nextLine, input string:\nHi Johnny, how are you?\nI'm good, Lucy. Nice to see you again.\nquit\nString: Hi Johnny, how are you?-I'm good, Lucy. Nice to see you again.-\n</code></pre>"},{"location":"java-core/java-core-scanner/#default-delimiter","title":"Default Delimiter","text":"<p>By default, scanner uses white space as delimiter.</p> <pre><code>import java.util.Scanner;\n\npublic class DefaultDelimiterExample {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Testing default delimiter, input string:\");\n\n        String s = \"\";\n        while (scan.hasNext()) {\n            s += scan.next() + \"-\";\n        }\n        // CMD + D on Mac to supply EOF for testing in terminal\n        System.out.println(\"String: \" + s);\n    }\n}\n</code></pre> <p>Input 'It's a nice day, isn't it?', the output looks as follows.</p> <pre><code>Testing default delimiter, input string:\nIt's a nice day, isn't it?\n^D\nString: It's-a-nice-day,-isn't-it?-\n</code></pre>"},{"location":"java-core/java-core-scanner/#custom-delimiter","title":"Custom Delimiter","text":"<p>We can specify any string as the delimiter by calling <code>useDelimiter()</code> method.</p> <pre><code>import java.util.Scanner;\n\npublic class CustomDelimiterExample {\n    public static void main(String[] args) {\n        Scanner scan = new Scanner(System.in);\n        System.out.println(\"Testing custom delimiter, input string:\");\n\n        // change the delimiter of this scanner\n        scan.useDelimiter(\",\");\n\n        String s = \"\";\n        while (scan.hasNext()) {\n            s += scan.next() + \"-\";\n        }\n        // CMD + D on Mac to supply EOF for testing in terminal\n        System.out.println(\"String: \" + s);\n    }\n}\n</code></pre> <p>Input 'It's a nice day, isn't it?' again, see the difference.</p> <pre><code>Testing custom delimiter, input string:\nIt's a nice day, isn't it?\n^D\nString: It's a nice day- isn't it?\n-\n</code></pre>"},{"location":"java-core/java-core-scanner/#read-and-write-file","title":"Read and Write File","text":"<p>The above examples show how to read input from screen and print output to screen. We can also use Scanner to read and write with files, if the standard in/out is set to file channel.</p>"},{"location":"java-core/java-core-scanner/#example","title":"Example","text":"<p>Suppose we have a file with following content. Each line is an order item, which contains name, price and quantity. We will use Scanner to read this file, calculate the cost(price * quantity) and write the result to another file.</p> <pre><code>apple 4.2 2\npear 5.0 3\npeach 10.3 1\nblueberry 15.0 2\ncoconut 8.6 1\n</code></pre> <p>OrderItem bean.</p> <pre><code>public class OrderItem {\n    public String name;\n    public double price;\n    public int quantity;\n\n    public OrderItem(String name, double price, int quantity) {\n        this.name = name;\n        this.price = price;\n        this.quantity = quantity;\n    }\n}\n</code></pre> <p>ScannerFileExample.</p> <pre><code>import java.io.File;\nimport java.io.FileInputStream;\nimport java.io.PrintStream;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Scanner;\n\npublic class ScannerFileExample {\n    private static final String INPUT_FILE = \"input.txt\";\n    private static final String OUTPUT_FILE = \"output.txt\";\n\n    public static void main(String args[]) throws Exception {\n        String currentDir = System.getProperty(\"user.dir\");\n\n        List&lt;OrderItem&gt; items = new ArrayList&lt;&gt;();\n        // Set system.io\n        Path path = Paths.get(currentDir, \"java-core-scanner\", \"files\", INPUT_FILE);\n        File file = path.toFile();\n        System.setIn(new FileInputStream(file));\n\n        // Get items from file\n        Scanner sc = new Scanner(System.in);\n        while (sc.hasNextLine()) {\n            items.add(new OrderItem(sc.next(), sc.nextDouble(), sc.nextInt()));\n        }\n        sc.close();\n\n        // Set system.out\n        Path output = Paths.get(currentDir, \"java-core-scanner\", \"files\", OUTPUT_FILE);\n        File outputFile = output.toFile();\n        System.setOut(new PrintStream(outputFile));\n\n        // Calculate the cost\n        for (OrderItem item : items) {\n            System.out.print(item.name + \": \");\n            System.out.println(item.price * item.quantity);\n        }\n    }\n}\n</code></pre> <p>After executing this program, we can get the result in file output.txt.</p> <pre><code>apple: 8.4\npear: 15.0\npeach: 10.3\nblueberry: 30.0\ncoconut: 8.6\n</code></pre>"},{"location":"java-core/java-core-scanner/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Scanner on GitHub</li> </ul>"},{"location":"java-core/java-core-scanner/#references","title":"References","text":"<ul> <li>Java User Input (Scanner)</li> <li>how to redirect stdin and stdout to a text file in java</li> </ul>"},{"location":"java-core/java-core-set/","title":"Set","text":"<p>Set Interface, HashSet and TreeSet.</p>"},{"location":"java-core/java-core-set/#set-interface","title":"Set interface","text":""},{"location":"java-core/java-core-set/#hashset","title":"HashSet","text":"<ul> <li>Interface: java.util.Set</li> <li>Class: java.util.HashSet</li> </ul>"},{"location":"java-core/java-core-set/#constructor","title":"Constructor","text":"<p>There are four constructors in Java HashSet class.</p> <ul> <li>public HashSet()</li> <li>public HashSet(int initialCapacity)</li> <li>public HashSet(int initialCapacity, float loadFactor)</li> <li>public HashSet(Collection&lt;? extends E&gt; c)</li> </ul> <pre><code>private static void constructHashSet() {\n    Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;();\n    set1.add(1);\n    set1.add(2);\n    set1.add(3);\n    set1.add(4);\n    System.out.println(\"Construct set: \" + set1);\n\n    // initial capacity should be power of 2\n    Set&lt;Integer&gt; set2 = new HashSet&lt;&gt;(32);\n\n    // setting backing HashSet initial capacity and load factor\n    Set&lt;Integer&gt; set3 = new HashSet&lt;&gt;(32, 0.80f);\n\n    // creating HashSet from another Collection\n    Set&lt;Integer&gt; set4 = new HashSet&lt;&gt;(Arrays.asList(new Integer[]{1,2,3,4,5,6,7}));\n    System.out.println(\"Construct set with list: \" + set4);\n    Set&lt;Integer&gt; set5 = new HashSet&lt;&gt;(set1);\n    System.out.println(\"Construct set with another set: \" + set5);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct set: [1, 2, 3, 4]\nConstruct set with list: [1, 2, 3, 4, 5, 6, 7]\nConstruct set with another set: [1, 2, 3, 4]\n</code></pre>"},{"location":"java-core/java-core-set/#common-operations","title":"Common Operations","text":"<ul> <li>set.add(item);</li> <li>set.contains(item);</li> <li>set.remove(item);</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // add\n    Set&lt;Integer&gt; set1 = new HashSet&lt;&gt;();\n    for (int i = 0; i &lt; 9; i++) {\n        set1.add(i);\n    }\n    System.out.println(\"Common operations - add : \" + set1);\n\n    // check existence\n    System.out.println(\"Check if element 3 exists : \" + set1.contains(3));\n\n    // remove\n    set1.remove(6);\n    System.out.println(\"Remove element 6 : \" + set1);\n}\n</code></pre> <p>Output.</p> <pre><code>Common operations - add : [0, 1, 2, 3, 4, 5, 6, 7, 8]\nCheck whether element 3 exists : true\nRemove element 6 : [0, 1, 2, 3, 4, 5, 7, 8]\n</code></pre>"},{"location":"java-core/java-core-set/#traversal","title":"Traversal","text":"<p>There are two ways to traverse a list.</p> <ul> <li>for each</li> <li>iterator</li> </ul> <pre><code>private static void traverseSet() {\n    Set&lt;String&gt; fruits = new HashSet&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Mango\");\n\n    // for each\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse Set(for each): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // iterator\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()) {\n        String fruit = iterator.next();\n        System.out.println(\"Traverse Set(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse Set(for each): processing - Apple\nTraverse Set(for each): processing - Mango\nTraverse Set(for each): processing - Orange\nTraverse Set(for each): processing - Banana\n\nTraverse Set(iterator): processing - Apple\nTraverse Set(iterator): processing - Mango\nTraverse Set(iterator): processing - Orange\nTraverse Set(iterator): processing - Banana\n</code></pre>"},{"location":"java-core/java-core-set/#remove-element","title":"Remove Element","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>Set.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    Set&lt;String&gt; fruits = new HashSet&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Mango\");\n\n    // in for each loop\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse Set(for each): processing - \" + fruit);\n\n        if (\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Traverse Set(iterator): processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits set after iteration = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    Set&lt;String&gt; fruits = new HashSet&lt;&gt;();\n    fruits.add(\"Apple\");\n    fruits.add(\"Banana\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Watermelon\");\n    fruits.add(\"Mango\");\n\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Remove element: processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            iterator.remove(); // iterator.remove not set.remove\n        }\n    }\n\n    System.out.println(\"fruits set after iteration = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - Apple\nRemove element: processing - Watermelon\nRemove element: processing - Mango\nRemove element: processing - Orange\nRemove element: processing - Banana\nfruits set after iteration = [Apple, Watermelon, Mango, Banana]\n</code></pre>"},{"location":"java-core/java-core-set/#treeset","title":"TreeSet","text":"<ul> <li>Interface: java.util.SortedSet</li> <li>Class: java.util.TreeSet</li> </ul>"},{"location":"java-core/java-core-set/#constructor-of-treeset","title":"Constructor of TreeSet","text":"<p>There are three constructors in Java TreeSet class.</p> <ul> <li>public TreeSet()</li> <li>public TreeSet(Comparator&lt;? super E&gt; comparator)</li> <li>public TreeSet(Collection&lt;? extends E&gt; c)</li> </ul> <pre><code>private static void constructTreeSet() {\n    SortedSet&lt;Integer&gt; treeSet1 = new TreeSet&lt;&gt;();\n    treeSet1.add(5);\n    treeSet1.add(9);\n    treeSet1.add(4);\n    treeSet1.add(2);\n    System.out.println(\"Construct TreeSet: \" + treeSet1);\n\n    // Comparator\n    SortedSet&lt;Integer&gt; treeSet2 = new TreeSet&lt;&gt;((a,b)-&gt;b-a); // reverse order\n    treeSet2.add(5);\n    treeSet2.add(9);\n    treeSet2.add(4);\n    treeSet2.add(2);\n    System.out.println(\"Construct TreeSet with comparator: \" + treeSet2);\n\n    // with another Collection\n    List&lt;Integer&gt; list = Arrays.asList(7,2,1,4,6,5);\n    SortedSet&lt;Integer&gt; treeSet3 = new TreeSet&lt;&gt;(list);\n    System.out.println(\"Construct TreeSet with list: \" + treeSet3);\n\n    // with another TreeSet\n    SortedSet&lt;Integer&gt; treeSet4 = new TreeSet&lt;&gt;(treeSet2);\n    System.out.println(\"Construct TreeSet with another set: \" + treeSet4);\n}\n</code></pre> <p>Output.</p> <pre><code>Construct TreeSet: [2, 4, 5, 9]\nConstruct TreeSet with comparator: [9, 5, 4, 2]\nConstruct TreeSet with list: [1, 2, 4, 5, 6, 7]\nConstruct TreeSet with another set: [9, 5, 4, 2]\n</code></pre>"},{"location":"java-core/java-core-set/#common-operations-of-treeset","title":"Common Operations of TreeSet","text":"<ul> <li>treeSet.add(item);</li> <li>treeSet.contains(item);</li> <li>treeSet.remove(item);</li> <li>treeSet.first();</li> <li>treeSet.last();</li> <li>treeSet.lower(item);</li> <li>treeSet.higher(item);</li> <li>treeSet.floor(item);</li> <li>treeSet.ceiling(item);</li> <li>treeSet.pollFirst();</li> <li>treeSet.pollLast();</li> <li>treeSet.subSet(fromElement, fromInclusive, toElement, toInclusive);</li> <li>treeSet.headSet(toElement, inclusive);</li> <li>treeSet.tailSet(fromElement, inclusive);</li> <li>treeSet.descendingSet();</li> </ul> <p>Example.</p> <pre><code>private static void commonOperations() {\n    // add\n    TreeSet&lt;Integer&gt; treeSet1 = new TreeSet&lt;&gt;();\n    for (int i = 0; i &lt; 10; i++) {\n        treeSet1.add(i);\n    }\n    System.out.println(\"Common operations - add : \" + treeSet1);\n\n    // check existence\n    System.out.println(\"Check if element 3 exists : \" + treeSet1.contains(3));\n\n    // lower and higher boundaries\n    System.out.println(\"First element is: \" + treeSet1.first());\n    System.out.println(\"Last element is: \" + treeSet1.last());\n    System.out.println(\"Closest lower element than 4 is: \"+ treeSet1.lower(4));\n    System.out.println(\"Closest higher element than 4 is: \"+ treeSet1.higher(4));\n    System.out.println(\"Closest floor element than 5 is: \"+ treeSet1.floor(5));\n    System.out.println(\"Closest ceiling element than 4 is: \" + treeSet1.ceiling(4));\n\n    // lower(n)   smaller than the given element\n    // floor(n)   smaller than or equal to the given element\n    // ceiling(n) larger than or equal to the given element\n    // higher(n)  larger than the given element\n\n    // poll first and last entries\n    System.out.println(\"First element(Polled) is: \" + treeSet1.pollFirst());\n    System.out.println(\"Last element(Polled) is: \" + treeSet1.pollLast());\n    System.out.println(\"TreeMap after polling: \" + treeSet1);\n\n    // submap, headmap and tailmap\n    Set&lt;Integer&gt; subSet = treeSet1.subSet(2, true, 6, true);\n    System.out.println(\"SubSet from 2 to 6 is: \" + subSet);\n    System.out.println(\"HeadSet to 5: \" + treeSet1.headSet(5, true));\n    System.out.println(\"TailMap from 5: \" + treeSet1.tailSet(5, true));\n\n    // reverse\n    Set&lt;Integer&gt; descendingSet = treeSet1.descendingSet();\n    System.out.println(\"Descending set: \" + descendingSet);\n\n    // remove\n    treeSet1.remove(6);\n    System.out.println(\"Remove element 6 : \" + treeSet1);\n}\n</code></pre> <p>Output.</p> <pre><code>Common operations - add : [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nCheck whether element 3 exists : true\nFirst element is: 0\nLast element is: 9\nClosest lower element than 4 is: 3\nClosest higher element than 4 is: 5\nClosest floor element than 5 is: 5\nClosest ceiling element than 4 is: 4\nFirst element(Polled) is: 0\nLast element(Polled) is: 9\nTreeMap after polling: [1, 2, 3, 4, 5, 6, 7, 8]\nSubSet from 2 to 6 is: [2, 3, 4, 5, 6]\nHeadSet to 5: [1, 2, 3, 4, 5]\nTailMap from 5: [5, 6, 7, 8]\nDescending set: [8, 7, 6, 5, 4, 3, 2, 1]\nRemove element 6 : [1, 2, 3, 4, 5, 7, 8]\n</code></pre>"},{"location":"java-core/java-core-set/#traversal-of-treeset","title":"Traversal of TreeSet","text":"<p>There are two ways to traverse a list.</p> <ul> <li>for each</li> <li>iterator</li> </ul> <pre><code>private static void traverseTreeSet() {\n    Set&lt;String&gt; fruits = new TreeSet&lt;&gt;();\n    fruits.add(\"Banana\");\n    fruits.add(\"Apple\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Mango\");\n\n    // for each\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse TreeSet(for each): processing - \" + fruit);\n    }\n\n    System.out.println();\n\n    // iterator\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()) {\n        String fruit = iterator.next();\n        System.out.println(\"Traverse TreeSet(iterator): processing - \" + fruit);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Traverse TreeSet(for each): processing - Apple\nTraverse TreeSet(for each): processing - Banana\nTraverse TreeSet(for each): processing - Mango\nTraverse TreeSet(for each): processing - Orange\n\nTraverse TreeSet(iterator): processing - Apple\nTraverse TreeSet(iterator): processing - Banana\nTraverse TreeSet(iterator): processing - Mango\nTraverse TreeSet(iterator): processing - Orange\n</code></pre>"},{"location":"java-core/java-core-set/#remove-element-of-treeset","title":"Remove Element of TreeSet","text":"<p>Below is the example showing the wrong way to remove element during traversal. We will get java.util.ConcurrentModificationException if we call <code>Set.remove()</code> inside the for loop.</p> <pre><code>private static void wrongWayToRemoveElement() {\n    Set&lt;String&gt; fruits = new TreeSet&lt;&gt;();\n    fruits.add(\"Banana\");\n    fruits.add(\"Apple\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Mango\");\n\n    // in for each loop\n    for (String fruit : fruits) {\n        System.out.println(\"Traverse TreeSet(for each): processing - \" + fruit);\n\n        if (\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    // in iterator loop\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Traverse TreeSet(iterator): processing - \" + fruit);\n\n        if(\"Orange\".equals(fruit)) {\n            fruits.remove(\"Orange\");  // java.util.ConcurrentModificationException is thrown\n        }\n    }\n\n    System.out.println(\"fruits set after iteration = \" + fruits);\n}\n</code></pre> <p>The correct way to remove element is to call <code>Iterator.remove()</code> method.</p> <pre><code>private static void correctWayToRemoveElement() {\n    Set&lt;String&gt; fruits = new TreeSet&lt;&gt;();\n    fruits.add(\"Banana\");\n    fruits.add(\"Apple\");\n    fruits.add(\"Orange\");\n    fruits.add(\"Mango\");\n\n    Iterator&lt;String&gt; iterator = fruits.iterator();\n\n    while (iterator.hasNext()){\n        String fruit = iterator.next();\n        System.out.println(\"Remove element: processing - \" + fruit);\n\n        if (\"Orange\".equals(fruit)) {\n            iterator.remove(); // iterator.remove not set.remove\n        }\n    }\n\n    System.out.println(\"fruits set after remove = \" + fruits);\n}\n</code></pre> <p>Output.</p> <pre><code>Remove element: processing - Apple\nRemove element: processing - Banana\nRemove element: processing - Mango\nRemove element: processing - Orange\nfruits set after remove = [Apple, Banana, Mango]\n</code></pre>"},{"location":"java-core/java-core-set/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Set on GitHub</li> </ul>"},{"location":"java-core/java-core-set/#references","title":"References","text":"<ul> <li>Java Doc - Controlling Access to Members of a Class</li> <li>Core Java Tutorial</li> <li>Java Data Types</li> <li>Primitive Wrapper Classes are Immutable in Java</li> <li>Collections in Java \u2013 Tutorial</li> </ul>"},{"location":"java-core/java-core-socket/","title":"Socket","text":"<p>Use socket to communicate through TCP and UDP between applications. Sockets provide the communication mechanism between two computers. A client program creates a socket on its end of the communication and attempts to connect that socket to a server.</p> <p>There are two common network protocols: TCP and UDP.</p>"},{"location":"java-core/java-core-socket/#common-protocal-used-in-socket","title":"Common protocal used in socket","text":""},{"location":"java-core/java-core-socket/#tcp","title":"TCP","text":"<p>TCP stands for Transmission Control Protocol, which allows for reliable communication between two applications. TCP is typically used over the Internet Protocol, which is referred to as TCP/IP.</p>"},{"location":"java-core/java-core-socket/#udp","title":"UDP","text":"<p>UDP stands for User Datagram Protocol, a connection-less protocol that allows for packets of data to be transmitted between applications.</p>"},{"location":"java-core/java-core-socket/#tcp-example","title":"TCP Example","text":"<p>We will create two programs with java sockets. One acts as client, another acts as server. The TCP client receives input from user, and sends it to TCP server. TCP server receives request(string) from client, converts it to upper case and sends back to the client. Finally, client displays the response(upper case string) to the screen.</p>"},{"location":"java-core/java-core-socket/#creating-tcp-server","title":"Creating TCP Server","text":"<p>Create a file named <code>TCPServer.java</code> with following content.</p> <pre><code>import java.io.*;\nimport java.net.*;\n\nclass TCPServer {\n    public static void main(String args[]) throws Exception {\n        int port = 8722;\n        Socket socket = null;\n        BufferedReader reader = null; // Local reader from the client\n        PrintStream outputStream = null; // Output stream to the client\n\n        String clientRequest = \"\";\n        String responseToClient = \"\";\n        ServerSocket ss = new ServerSocket(port);\n        System.out.println(\"TCP Server is starting up, listening at port \" + port + \".\");\n\n        while (true) {\n            // Get request from client\n            socket = ss.accept();\n            reader = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            clientRequest = reader.readLine();\n            System.out.println(\"[TCPServer] Get request [\" + clientRequest + \"] from Client.\");\n\n            // Send response to client\n            outputStream = new PrintStream(socket.getOutputStream());\n            responseToClient = clientRequest.toUpperCase();\n            outputStream.println(responseToClient);\n            System.out.println(\"[TCPServer] Send out response [\" + responseToClient + \"] to Client.\");\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-socket/#creating-tcp-client","title":"Creating TCP Client","text":"<p>Create a file named <code>TCPClient.java</code> with following content.</p> <pre><code>import java.io.*;\nimport java.net.*;\n\nclass TCPClient {\n    public static void main(String args[]) throws Exception {\n        String serverName = \"localhost\";\n        int port = 8722; // Same port number with the server\n        Socket socket = null;\n        PrintStream toServer = null;\n        BufferedReader fromServer = null;\n\n        System.out.println(\"TCP Client launched, using server: \" + serverName + \", Port: \" + port);\n\n        // Read from user input\n        BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));\n        String userInput = \"\";\n        do {\n            System.out.print(\"Enter any string now, (quit) to end: \");\n            System.out.flush();\n            userInput = inFromUser.readLine();\n            if (userInput.equalsIgnoreCase(\"quit\")) {\n                break;\n            }\n\n            // Open a new socket connection to the server with the specified port number\n            socket = new Socket(serverName, port);\n\n            // Send user input to server\n            toServer = new PrintStream(socket.getOutputStream());\n            toServer.println(userInput);\n            System.out.println(\"[TCPClient] Send out user input [\" + userInput + \"] to Server.\");\n\n            // Get response from server\n            fromServer = new BufferedReader(new InputStreamReader(socket.getInputStream()));\n            String responseFromServer = fromServer.readLine();\n            System.out.println(\"[TCPClient] Get response [\" + responseFromServer + \"] from Server.\");\n        } while (!userInput.equals(\"quit\")); // End the client if 'quit' is an input\n\n        // Close connection\n        if (socket != null) {\n            socket.close();\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-socket/#compiling","title":"Compiling","text":"<p>Open terminal, navigate to the folder where these two java files locate. Use <code>javac</code> to compile them.</p> <pre><code>javac TCPServer.java\njavac TCPClient.java\n</code></pre>"},{"location":"java-core/java-core-socket/#testing","title":"Testing","text":"<p>Launch TCP server with following command.</p> <pre><code>$ java TCPServer\nTCP Server is starting up, listening at port 8722.\n</code></pre> <p>Open another terminal, launch TCP client.</p> <pre><code>$ java TCPClient\nTCP Client launched, using server: localhost, Port: 8722\nEnter any string now, (quit) to end:\n</code></pre> <p>In the terminal for TCP Client(Right one of the following screenshot), input any string and Enter. You will see the response from TCP Server. </p>"},{"location":"java-core/java-core-socket/#udp-example","title":"UDP Example","text":"<p>Create UDP Server and UDP Client with same function as TCP Server and TCP Client.</p>"},{"location":"java-core/java-core-socket/#creating-udp-server","title":"Creating UDP Server","text":"<p>Create a file named <code>UDPServer.java</code> with following content.</p> <pre><code>public class UDPServer {\n    public static void main(String args[]) throws Exception {\n        int port = 8722; // Same port number with the server\n        Socket socket = null;\n        DatagramSocket serverSocket = new DatagramSocket(port);\n        byte[] receiveData = new byte[1024];\n        byte[] sendData = new byte[1024];\n        System.out.println(\"UDP Server is starting up, waiting for request...\");\n        while(true) {\n            receiveData = new byte[1024];\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            serverSocket.receive(receivePacket);\n            // get actual date with proper length\n            byte[] actualData = new byte[receivePacket.getLength()];\n            System.arraycopy(receivePacket.getData(), receivePacket.getOffset(),\n                    actualData, 0, receivePacket.getLength());\n            String clientInput = new String(actualData);\n            System.out.println(\"[UPDServer] Received input [\" + clientInput + \"] from Client.\");\n            // Find the ip address and port of sender\n            InetAddress IPAddress = receivePacket.getAddress();\n            port = receivePacket.getPort();\n\n            String responseToClient = clientInput.toUpperCase();\n            sendData = responseToClient.getBytes();\n            // Define upd package\n            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n            // Send\n            serverSocket.send(sendPacket);\n            System.out.println(\"[UPDServer] Send out response [\" + responseToClient + \"] to Client.\");\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-socket/#creating-udp-client","title":"Creating UDP Client","text":"<p>Create a file named <code>UDPClient.java</code> with following content.</p> <pre><code>public class UDPClient {\n    public static void main(String args[]) throws Exception {\n        String serverName = \"localhost\";\n        int port = 8722; // Same port number with the server\n        byte[] sendData = new byte[1024];\n        byte[] receiveData = new byte[1024];\n\n        System.out.println(\"UPD Client launched, using server: \" + serverName + \", Port: \" + port);\n\n        BufferedReader inFromUser = new BufferedReader(new InputStreamReader(System.in));\n        DatagramSocket clientSocket = new DatagramSocket();\n        InetAddress IPAddress = InetAddress.getByName(serverName);\n        String userInput = \"\";\n        do {\n            userInput = \"\";\n            System.out.print(\"Enter any string now, (quit) to end: \");\n            System.out.flush();\n            userInput = inFromUser.readLine();\n            if (userInput.equalsIgnoreCase(\"quit\")) {\n                break;\n            }\n            sendData = userInput.getBytes();\n\n            // Define upd package and send to server\n            DatagramPacket sendPacket = new DatagramPacket(sendData, sendData.length, IPAddress, port);\n            clientSocket.send(sendPacket);\n            System.out.println(\"[UDPClient] Send out user input [\" + userInput + \"] to Server.\");\n            //\n            DatagramPacket receivePacket = new DatagramPacket(receiveData, receiveData.length);\n            clientSocket.receive(receivePacket);\n            // get actual date with proper length\n            byte[] actualData = new byte[receivePacket.getLength()];\n            System.arraycopy(receivePacket.getData(), receivePacket.getOffset(),\n                    actualData, 0, receivePacket.getLength());\n            String responseFromServer = new String(actualData);\n            System.out.println(\"[UDPClient] Get response [\" + responseFromServer + \"] from Server.\");\n        } while (!userInput.equals(\"quit\")); // End the client if 'quit' is an input\n\n        // Close connection\n        if (clientSocket != null) {\n            clientSocket.close();\n        }\n    }\n}\n</code></pre>"},{"location":"java-core/java-core-socket/#compiling-udp","title":"Compiling UDP","text":"<p>Open terminal, navigate to the folder where these two java files locate. Use <code>javac</code> to compile them.</p> <pre><code>javac UDPServer.java\njavac UDPClient.java\n</code></pre>"},{"location":"java-core/java-core-socket/#testing-udp","title":"Testing UDP","text":"<p>Launch UDP server with following command.</p> <pre><code>$ java UDPServer\nUDP Server is starting up, waiting for request...\n</code></pre> <p>Open another terminal, launch UDP client.</p> <pre><code>$ java UDPClient\nUDP Client launched, using server: localhost, Port: 8722\nEnter any string now, (quit) to end:\n</code></pre> <p>In the terminal for UDP Client(Right one of the following screenshot), input any string and Enter. You will see the response from UDP Server. </p>"},{"location":"java-core/java-core-socket/#source-files","title":"Source Files","text":"<ul> <li>Source files of Java Socket on Github</li> </ul>"},{"location":"java-core/java-core-socket/#references","title":"References","text":"<ul> <li>Java - Networking</li> <li>A Simple Java TCP Server and TCP Client</li> <li>A Simple Java UDP Server and UDP Client</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/","title":"Stack, Queue and Deque","text":"<p>Queue, Stack, Queue and Heap.</p>"},{"location":"java-core/java-core-stack-queue-and-deque/#stack","title":"Stack","text":"<p>There are two ways to create 'stack' in Java.</p> <ul> <li><code>Stack</code> Class</li> <li><code>Deque</code> Interface and <code>LinkedList</code> Class</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#stack-class","title":"Stack Class","text":"<p>Java Stack extends <code>Vector</code> class with the following five operations only.</p> <ul> <li>boolean empty(): Tests if this stack is empty.</li> <li>E peek(): Looks at the object at the top of this stack without removing it from the stack.</li> <li>E pop() : Removes the object at the top of this stack and returns that object as the value of this function.</li> <li>E push(E item) : Pushes an item onto the top of this stack.</li> <li>int search(Object o) : Returns the 1-based position where an object is on this stack.</li> </ul> <p>Example:</p> <pre><code>public static void main(String a[]){\n    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();\n    System.out.println(\"stack : \"  + stack); // []\n    System.out.println(\"Empty stack : \"  + stack.isEmpty()); // true\n    // Exception in thread \"main\" java.util.EmptyStackException\n    // System.out.println(\"Empty stack : Pop Operation : \"  + stack.pop());\n    stack.push(11);\n    stack.push(12);\n    stack.push(13);\n    stack.push(14);\n    System.out.println(\"stack : \"  + stack); // [11,12,13,14]\n    System.out.println(\"Pop Operation : \"  + stack.pop()); // 14\n    System.out.println(\"After Pop Operation : \"  + stack); // [11,12,13]\n    System.out.println(\"search() Operation : \"  + stack.search(12)); // 2\n    System.out.println(\"stack : \"  + stack.isEmpty()); // false\n}\n</code></pre> <p>Output:</p> <pre><code>stack : []\nEmpty stack : true\nstack : [11, 12, 13, 14]\nPop Operation : 14\nAfter Pop Operation : [11, 12, 13]\nsearch() Operation : 2\nstack : false\n</code></pre>"},{"location":"java-core/java-core-stack-queue-and-deque/#deque-interface-and-linkedlist-class","title":"Deque Interface and LinkedList Class","text":"<p>Deque interface supports adding and removing elements from both ends of the queue. If we only use the push and pop methods, it behaves just like a stack.</p> <pre><code>public static void main(String a[]){\n    Deque&lt;Integer&gt; stack = new LinkedList&lt;&gt;();\n    System.out.println(\"stack : \"  + stack); // []\n    System.out.println(\"Empty stack : \"  + stack.isEmpty()); // true\n    // Exception in thread \"main\" java.util.NoSuchElementException\n    System.out.println(\"Empty stack : Pop Operation : \"  + stack.pop());\n    stack.push(11);\n    stack.push(12);\n    stack.push(13);\n    stack.push(14);\n    System.out.println(\"stack : \"  + stack); // [11,12,13,14]\n    System.out.println(\"Pop Operation : \"  + stack.pop()); // 14\n    System.out.println(\"After Pop Operation : \"  + stack); // [11,12,13]\n    System.out.println(\"stack : \"  + stack.isEmpty()); // false\n}\n</code></pre> <p>Output:</p> <pre><code>stack : []\nEmpty stack : true\nstack : [14, 13, 12, 11]\nPop Operation : 14\nAfter Pop Operation : [13, 12, 11]\nstack : false\n</code></pre>"},{"location":"java-core/java-core-stack-queue-and-deque/#queue","title":"Queue","text":""},{"location":"java-core/java-core-stack-queue-and-deque/#java-queue-categories","title":"Java Queue Categories","text":"<p><code>Bounded Queues</code> are queues which are bounded by <code>capacity</code> that means we need to provide the max size of the queue at the time of creation. For example ArrayBlockingQueue.</p> <ul> <li>Bounded Queues</li> <li>Unbounded Queues</li> </ul> <p>All Queues which implement <code>BlockingQueue</code> interface are BlockingQueues and rest are Non-Blocking Queues.</p> <ul> <li>Blocking Queues</li> <li>Non-Blocking Queues</li> </ul> OPERATION THROWS EXCEPTION SPECIAL VALUE BLOCKS TIMES OUT Insert add(e) offer(e) put(e) offer(e, time, unit) Remove remove() poll() take() poll(time, unit) Examine element() peek() N/A N/A"},{"location":"java-core/java-core-stack-queue-and-deque/#constructing-queue","title":"Constructing Queue","text":"<pre><code>private static void constructQueue() {\n    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n    queue.add(\"one\");\n    queue.add(\"two\");\n    queue.add(\"three\");\n    queue.add(\"four\");\n    System.out.println(queue);\n\n    queue.remove(\"three\");\n    System.out.println(queue);\n    System.out.println(\"Queue Size: \" + queue.size());\n    System.out.println(\"Queue Contains element 'two' or not? : \" + queue.contains(\"two\"));\n\n    // To empty the queue\n    queue.clear();\n\n    //Array to Queue\n    String[] nums = {\"one\",\"two\",\"three\",\"four\",\"five\"};\n    Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;();\n    Collections.addAll(queue2, nums);\n    System.out.println(queue2);\n\n    // Queue to Array\n    String strArray[] = queue2.toArray(new String[queue2.size()]);\n    System.out.println(Arrays.toString(strArray));\n}\n</code></pre> <p>Output.</p> <pre><code>[one, two, three, four]\n[one, two, four]\nQueue Size: 3\nQueue Contains element 'two' or not? : true\n[one, two, three, four, five]\n[one, two, three, four, five]\n</code></pre>"},{"location":"java-core/java-core-stack-queue-and-deque/#common-operations","title":"Common Operations","text":"<p>Java Queue supports all operations supported by Collection interface and some more operations. It supports almost all operations in two forms.</p> <ul> <li>One set of operations throws an exception if the operation fails.</li> <li>The other set of operations returns a special value if the operation fails.</li> </ul> <p>The following table explains all Queue common operations briefly.</p> OPERATION THROWS EXCEPTION SPECIAL VALUE(null) Insert add(e) offer(e) Remove remove() poll() Examine element() peek()"},{"location":"java-core/java-core-stack-queue-and-deque/#add-vs-offer","title":"add vs. offer","text":"<pre><code>// insert\nprivate static void insert() {\n    System.out.println(\"Queue - insert\");\n    // add method\n    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n    System.out.println(queue.add(\"one\"));   // true\n    System.out.println(queue.add(\"two\"));   // true\n    System.out.println(queue);              // [one, two]\n    System.out.println(queue.add(\"three\")); // true\n    System.out.println(queue);              // [one, two, three]\n\n    // offer method\n    Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;();\n    System.out.println(queue2.offer(\"one\"));   // true\n    System.out.println(queue2.offer(\"two\"));   // true\n    System.out.println(queue2);                // [one, two]\n    System.out.println(queue2.offer(\"three\")); // true\n    System.out.println(queue2);                // [one, two, three]\n}\n</code></pre> <p>Output.</p> <pre><code>Queue - insert\ntrue\ntrue\n[one, two]\ntrue\n[one, two, three]\ntrue\ntrue\n[one, two]\ntrue\n[one, two, three]\n</code></pre> <ul> <li>No difference for unbounded queue.</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#remove-vs-poll","title":"remove vs. poll","text":"<pre><code>// delete\nprivate static void delete() {\n    System.out.println(\"Queue - delete\");\n    // remove\n    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n    queue.offer(\"one\");\n    queue.offer(\"two\");\n    System.out.println(queue);           // [one, two]\n    System.out.println(queue.remove());  // one\n    System.out.println(queue.remove());  // two\n    //System.out.println(queue.remove()); // java.util.NoSuchElementException\n\n    // poll\n    Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;();\n    queue2.offer(\"one\");\n    queue2.offer(\"two\");\n    System.out.println(queue2);         // [one, two]\n    System.out.println(queue2.poll());  // one\n    System.out.println(queue2.poll());  // two\n    System.out.println(queue2.poll());  // return null\n}\n</code></pre> <p>Output.</p> <pre><code>Queue - delete\n[one, two]\none\ntwo\n[one, two]\none\ntwo\nnull\n</code></pre> <ul> <li>If no elements in the queue, remove() method causes NoSuchElementException. But, poll() method returns null without exception.</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#element-vs-peek","title":"element vs. peek","text":"<pre><code>// examine\nprivate static void examine() {\n    System.out.println(\"Queue - examine\");\n    // element\n    Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();\n    queue.add(\"one\");\n\n    System.out.println(queue.element());  // one\n    System.out.println(queue);            // [one]\n    queue.clear();\n    //System.out.println(queue.element()); // java.util.NoSuchElementException\n\n    // peek\n    Queue&lt;String&gt; queue2 = new LinkedList&lt;&gt;();\n    queue2.add(\"one\");\n\n    System.out.println(queue2.peek());  // one\n    System.out.println(queue2);         // [one]\n    queue2.clear();\n    System.out.println(queue2.peek());  // return null\n}\n</code></pre> <p>Output.</p> <pre><code>Queue - examine\none\n[one]\none\n[one]\nnull\n</code></pre> <ul> <li>If no elements in the queue, element() method causes NoSuchElementException. But, peek() method returns null without exception.</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#blockingqueue","title":"BlockingQueue","text":""},{"location":"java-core/java-core-stack-queue-and-deque/#add-vs-offer_1","title":"add vs offer","text":"<pre><code>public static void main(String[] args) {\n    System.out.println(\"Test BlockingQueue\");\n    // add\n    BlockingQueue&lt;String&gt; queue = new ArrayBlockingQueue&lt;&gt;(2);\n    System.out.println(queue.add(\"one\"));   // true\n    System.out.println(queue.add(\"two\"));   // true\n    System.out.println(queue);              // [one, two]\n    //System.out.println(queue.add(\"three\")); // java.lang.IllegalStateException: Queue full\n    System.out.println(queue);              // [one, two]\n\n    // offer\n    BlockingQueue&lt;String&gt; queue2 = new ArrayBlockingQueue&lt;&gt;(2);\n    System.out.println(queue2.offer(\"one\"));   // true\n    System.out.println(queue2.offer(\"two\"));   // true\n    System.out.println(queue2);                // [one, two]\n    System.out.println(queue2.offer(\"three\")); // false\n    System.out.println(queue2);                // [one, two]\n}\n</code></pre> <p>Output.</p> <pre><code>Test BlockingQueue\ntrue\ntrue\n[one, two]\n[one, two]\ntrue\ntrue\n[one, two]\nfalse\n[one, two]\n</code></pre> <ul> <li>You can specify the capacity when constructing BlockingQueue.</li> <li>If size of the BlockingQueue reaches to the capacity, no new element can be added.</li> <li>add() method causes IllegalStateException, whereas offer() method returns false.</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#deque","title":"Deque","text":"<p>The Java Deque interface, java.util.Deque, represents a <code>double ended queue</code>, meaning a queue where you can add and remove elements from both ends of the queue. The name Deque is an abbreviation of Double Ended Queue.</p>"},{"location":"java-core/java-core-stack-queue-and-deque/#common-operations-of-deque","title":"Common Operations of Deque","text":"<p>Constructing:</p> <pre><code>Deque&lt;String&gt; deque = new LinkedList&lt;&gt;();\nDeque&lt;String&gt; deque = new ArrayDeque&lt;&gt;();\n</code></pre> <p>Add Element to Deque</p> <ul> <li>add()</li> <li>addLast()</li> <li>addFirst()</li> </ul> <p>Peek at Element in Deque</p> <ul> <li>peekFirst()</li> <li>peekLast()</li> </ul> <p>Remove Element From Deque</p> <ul> <li>remove()</li> <li>removeFirst()</li> <li>removeLast()</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#example","title":"Example","text":"<pre><code>public static void main(String[] args) {\n    Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();\n   //Deque&lt;Integer&gt; deque = new ArrayDeque&lt;&gt;();\n\n    // add\n    deque.add(1); // add last\n    deque.add(2);\n    deque.add(3);\n    deque.add(4);\n    System.out.println(deque); // [1, 2, 3, 4]\n\n    deque.addLast(5);\n    System.out.println(deque); // [1, 2, 3, 4, 5]\n    deque.addFirst(6);\n    System.out.println(deque); // [6, 1, 2, 3, 4, 5]\n\n    // peek\n    System.out.println(deque.peekFirst()); // 6\n    System.out.println(deque.peekLast());  // 5\n\n    // remove\n    deque.remove(); // remove first\n    System.out.println(deque); // [1, 2, 3, 4, 5]\n    deque.removeFirst();\n    System.out.println(deque); // [2, 3, 4, 5]\n    deque.removeLast();\n    System.out.println(deque); // [2, 3, 4]\n}\n</code></pre> <p>Output.</p> <pre><code>[1, 2, 3, 4]\n[1, 2, 3, 4, 5]\n[6, 1, 2, 3, 4, 5]\n6\n5\n[1, 2, 3, 4, 5]\n[2, 3, 4, 5]\n[2, 3, 4]\n</code></pre>"},{"location":"java-core/java-core-stack-queue-and-deque/#heappriorityqueue","title":"Heap/PriorityQueue","text":""},{"location":"java-core/java-core-stack-queue-and-deque/#constructing-heap","title":"Constructing Heap","text":"<p>In Java, we can use java.util.PriorityQueue to create <code>min heap</code> or <code>max heap</code>.</p> <pre><code>// String\nPriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;();                            // min heap\nPriorityQueue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());   // max heap\n\n// Integer\nPriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;();                           // min heap\nPriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());  // max heap\nPriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;b-a);                 // max heap\n</code></pre>"},{"location":"java-core/java-core-stack-queue-and-deque/#common-operations-of-heap","title":"Common Operations of Heap","text":"<ul> <li>add(e): Insert an element into the priority queue.</li> <li>offer(e): Insert an element into the priority queue.</li> <li>remove(): Remove the top element from the queue, if it is present; otherwise, raise <code>NoSuchElementException</code>.</li> <li>poll(): Retrieve and remove the top element of the queue, or returns <code>null</code> if queue is empty.</li> <li>peek(): Retrieve the top element of the queue, or returns null if queue is empty.</li> <li>size(): Return the number of elements present in the queue.</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#example-of-heap","title":"Example of Heap","text":"<p>Min heap.</p> <pre><code>public static void testMinHeap(){\n    System.out.println(\"Testing min heap:\");\n    // create a min heap\n    Queue&lt;String&gt; pq = new PriorityQueue&lt;&gt;();\n    pq.add(\"a\");\n    pq.add(\"b\");\n    pq.add(\"c\");\n    System.out.println(\"size:\" + pq.size()); // 3\n    System.out.println(pq.peek());           // a\n    System.out.println(pq.remove());         // a\n    System.out.println(pq.peek());           // b\n\n    System.out.println(pq);                  // [b, c]\n\n    pq.offer(\"d\");\n    pq.offer(\"z\");\n    System.out.println(\"size:\" + pq.size());   // 4\n    System.out.println(pq);                    // [b, c, d, z]\n\n    System.out.println(pq.poll());   // b\n    System.out.println(pq.poll());   // c\n    System.out.println(pq.poll());   // d\n    System.out.println(pq.poll());   // g\n    //System.out.println(pq.remove()); // NoSuchElementException\n    System.out.println(pq.poll());   // null\n}\n</code></pre> <p>Output.</p> <pre><code>Testing min heap:\nsize:3\na\na\nb\n[b, c]\nsize:4\n[b, c, d, z]\nb\nc\nd\nz\nnull\n</code></pre> <p>Max heap.</p> <pre><code>public static void testMaxHeap(){\n    System.out.println(\"Testing max heap:\");\n    // create a max heap\n    Queue&lt;String&gt; pq = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());\n    pq.add(\"a\");\n    pq.add(\"b\");\n    pq.add(\"c\");\n    System.out.println(\"size:\" + pq.size()); // 3\n    System.out.println(pq.peek());           // c\n    System.out.println(pq.remove());         // c\n    System.out.println(pq.peek());           // b\n\n    System.out.println(pq);                  // [b, a]\n\n    pq.offer(\"d\");\n    pq.offer(\"z\");\n    System.out.println(\"size:\" + pq.size());   // 4\n    System.out.println(pq);                    // [z, d, b, a]\n\n    System.out.println(pq.poll());   // z\n    System.out.println(pq.poll());   // d\n    System.out.println(pq.poll());   // b\n    System.out.println(pq.poll());   // a\n    //System.out.println(pq.remove()); // NoSuchElementException\n    System.out.println(pq.poll());   // null\n}\n</code></pre> <p>Output.</p> <pre><code>Testing max heap:\nsize:3\nc\nc\nb\n[b, a]\nsize:4\n[z, d, b, a]\nz\nd\nb\na\nnull\n</code></pre>"},{"location":"java-core/java-core-stack-queue-and-deque/#order-of-elements","title":"Order of Elements","text":"<p>The order of elements in heap is not guaranteed.</p> <pre><code>public static void testOrder() {\n    System.out.println(\"Testing order of heap:\");\n    Queue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;(Comparator.reverseOrder());\n    //PriorityQueue&lt;Integer&gt; pq = new PriorityQueue&lt;&gt;((a,b)-&gt;b-a);\n    pq.offer(1);\n    pq.offer(2);\n    pq.offer(3);\n\n    System.out.println(pq);        // [3, 1, 2]\n\n    Iterator&lt;Integer&gt; iterator = pq.iterator();\n    while (iterator.hasNext()) {\n        System.out.println(iterator.next());\n    }\n\n    System.out.println(pq.poll()); // 3\n    System.out.println(pq.poll()); // 2\n    System.out.println(pq.poll()); // 1\n}\n</code></pre> <p>Output.</p> <pre><code>Testing order of heap:\n[3, 1, 2]\n3\n1\n2\n3\n2\n1\n</code></pre> <ul> <li><code>poll</code> method guarantees that the minimum(maximum) element will be fetched each time.</li> <li>Iterator can't guarantee the order.</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Queue and Stack on GitHub</li> </ul>"},{"location":"java-core/java-core-stack-queue-and-deque/#references","title":"References","text":"<ul> <li>Collections in Java \u2013 Tutorial</li> <li>Java Deque</li> </ul>"},{"location":"java-core/java-core-static-block/","title":"Static Block and Initialization Block","text":""},{"location":"java-core/java-core-static-block/#static-block","title":"Static Block","text":"<p>Java supports a special block, called <code>static block</code> (also called static clause) which can be used for static initializations of a class. This code inside static block is executed only once: the first time you make an object of that class or the first time you access a static member of that class (even if you never make an object of that class).</p> <p>Example.</p> <pre><code>public class StaticBlockExample {\n    static {\n        //static block\n        System.out.println(\"Hi, I'm a Static Block!\");\n    }\n\n    public StaticBlockExample() {\n        System.out.println(\"Hi, I'm Constructor 1!\");\n    }\n\n    public StaticBlockExample(String name) {\n        System.out.println(\"Hi, \" + name + \"! I'm Constructor 2!\");\n    }\n\n    public static void main(String[] args) {\n        StaticBlockExample object1 = new StaticBlockExample();\n        StaticBlockExample object2 = new StaticBlockExample(\"Johnny\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Hi, I'm a Static Block!\nHi, I'm Constructor 1!\nHi, Johnny! I'm Constructor 2!\n</code></pre> <ul> <li>The static block is executed before any constructor.</li> </ul>"},{"location":"java-core/java-core-static-block/#initialization-block","title":"Initialization Block","text":"<p>Instance Initialization Blocks or <code>IIB</code> are used to initialize instance variables. IIBs are executed before constructors. They run each time when object of the class is created.</p> <ul> <li>Initialization blocks are executed whenever the class is initialized and before constructors are invoked.</li> <li>They are typically placed above the constructors within braces.</li> <li>It is not at all necessary to include them in your classes.</li> </ul>"},{"location":"java-core/java-core-static-block/#single-instance-initialization-block","title":"Single Instance Initialization Block","text":"<pre><code>public class InitializationBlockExample {\n    {\n        System.out.println(\"This is Initialization Block!\");\n    }\n    public InitializationBlockExample() {\n        System.out.println(\"Hi, I'm Constructor!\");\n    }\n\n    public static void main(String[] args) {\n        InitializationBlockExample object1 = new InitializationBlockExample();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>This is Initialization Block!\nHi, I'm Constructor!\n</code></pre>"},{"location":"java-core/java-core-static-block/#multiple-instance-initialization-blocks","title":"Multiple Instance Initialization Blocks","text":"<p>We can also have multiple IIBs in a single class. If compiler finds multiple IIBs, then they all are executed from top to bottom.</p> <pre><code>public class InitializationBlockExample2 {\n    {\n        System.out.println(\"This is Initialization Block 1!\");\n    }\n    {\n        System.out.println(\"This is Initialization Block 2!\");\n    }\n    public InitializationBlockExample2() {\n        System.out.println(\"Hi, I'm Constructor 1!\");\n    }\n    public InitializationBlockExample2(String name) {\n        System.out.println(\"Hi, \" + name + \"! I'm Constructor 2!\");\n    }\n\n    public static void main(String[] args) {\n        InitializationBlockExample2 object1 = new InitializationBlockExample2();\n        InitializationBlockExample2 object3 = new InitializationBlockExample2(\"Johnny\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>This is Initialization Block 1!\nThis is Initialization Block 2!\nHi, I'm Constructor 1!\nThis is Initialization Block 1!\nThis is Initialization Block 2!\nHi, Johnny! I'm Constructor 2!\n</code></pre> <ul> <li>Initialization block is executed each time when class is instantiated.</li> </ul>"},{"location":"java-core/java-core-static-block/#instance-initialization-block-with-parent-class","title":"Instance Initialization Block with Parent Class","text":"<p>Instance initialization block code runs immediately after the call to super() in a constructor. The compiler executes parents class\u2019s IIB before executing current class\u2019s IIBs.</p> <pre><code>// Parent.java\npublic class Parent {\n    {\n        System.out.println(\"This is parent block!\");\n    }\n\n    Parent() {\n        System.out.println(\"Parent Constructor is Called.\");\n    }\n}\n\n// Child.java\npublic class Child extends Parent {\n    {\n        System.out.println(\"This is child block!\");\n    }\n\n    public Child() {\n        super();\n        System.out.println(\"Child Constructor is Called.\");\n    }\n}\n\n// InitializationBlockExample3.java\npublic class InitializationBlockExample3 {\n    // main function\n    public static void main(String[] args) {\n        Child child = new Child();\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>This is parent block!\nParent Constructor is Called.\nThis is child block!\nChild Constructor is Called.\n</code></pre> <ul> <li>Parent\u2019s IIB is executed before Child's IIB.</li> </ul>"},{"location":"java-core/java-core-static-block/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java Static Block on GitHub</li> </ul>"},{"location":"java-core/java-core-static-block/#references","title":"References","text":"<ul> <li>Java Static Block</li> <li>Instance Initialization Block (IIB) in Java</li> </ul>"},{"location":"java-java8/java-8-functional-composition/","title":"Functional Composition","text":"<p>Functional composition is a technique to combine multiple functions into a single function which uses the combined functions internally. You can compose individual functions (typically one or more Java Lambda Expressions) into a single function yourself, but Java also comes with built-in support for functional composition to make the job easier for you.</p>"},{"location":"java-java8/java-8-functional-composition/#java-functional-composition-example","title":"Java Functional Composition Example","text":"<p>To get started, let me show you an example of Java functional composition. Here is a single function composed from two other functions:</p> <pre><code>Predicate&lt;String&gt; startsWithA = (text) -&gt; text.startsWith(\"A\");\nPredicate&lt;String&gt; endsWithX   = (text) -&gt; text.endsWith(\"x\");\n\nPredicate&lt;String&gt; startsWithAAndEndsWithX =\n        (text) -&gt; startsWithA.test(text) &amp;&amp; endsWithX.test(text);\n\nString  input  = \"A hardworking person must relax\";\nboolean result = startsWithAAndEndsWithX.test(input);\nSystem.out.println(result);\n</code></pre> <p>This functional composition example first creates two Predicate implementations in the form of two lambda expressions. The first Predicate returns true if the String you pass to it as parameter starts with an uppercase a (A). The second Predicate returns true if the String passed to it ends with a lowercase x . Note, that the Predicate interface contains a single unimplemented method named test() which returns a boolean. It is this method the lambda expressions implement.</p> <p>After creating the two basic functions, a third Predicate is composed, which calls the test() methods of the two first functions. This third function returns true if both of the basic functions return true, and false otherwise.</p> <p>Finally, this example calls the composed function and prints out the result. Since the text both starts with an uppercase a (A) and ends with a lowercase x, the composed function will return true when called with the String \"A hardworking person must relax\".</p>"},{"location":"java-java8/java-8-functional-composition/#java-functional-composition-support","title":"Java Functional Composition Support","text":"<p>The example in the previous section showed you how to compose a new function from two other functions. Several of the functional interfaces in Java already has support for functional composition built into them. The functional composition support comes in the shape of default and static methods in the functional interfaces.</p>"},{"location":"java-java8/java-8-functional-composition/#predicate-composition","title":"Predicate Composition","text":"<p>The Predicate interface (java.util.function.Predicate) contains a few methods that help you compose new Predicate instances from other Predicate instances.</p>"},{"location":"java-java8/java-8-functional-composition/#and","title":"and()","text":"<p>The Predicate <code>and()</code> method is a default method. The and() method is used to combine two other Predicate functions in the same way I showed in the beginning of this Java functional composition tutorial. Here is an example of functional composition with the Predicate and() method:</p> <pre><code>Predicate&lt;String&gt; startsWithA = (text) -&gt; text.startsWith(\"A\");\nPredicate&lt;String&gt; endsWithX   = (text) -&gt; text.endsWith(\"x\");\n\nPredicate&lt;String&gt; composed = startsWithA.and(endsWithX);\n\nString input = \"A hardworking person must relax\";\nboolean result = composed.test(input);\nSystem.out.println(result);\n</code></pre> <p>This Predicate composition example composes a new Predicate from two other Predicate instances using the and() method of one of the basic Predicate instances.</p> <p>The composed Predicate will return true from it's test() method if both of the Predicate instances it was composed from also return true. In other words, if both Predicate one and Predicate two return true.</p>"},{"location":"java-java8/java-8-functional-composition/#or","title":"or()","text":"<p>The Predicate <code>or()</code> method is used to combine a Predicate instance with another, to compose a third Predicate instance. The composed Predicate will return true if either of the Predicate instances it is composed from return true, when their test() methods are called with same input parameter as the composed Predicate. Here is a Java Predicate or() functional composition example:</p> <pre><code>Predicate&lt;String&gt; startsWithA = (text) -&gt; text.startsWith(\"A\");\nPredicate&lt;String&gt; endsWithX   = (text) -&gt; text.endsWith(\"x\");\n\nPredicate&lt;String&gt; composed = startsWithA.or(endsWithX);\n\nString input = \"A hardworking person must relax sometimes\";\nboolean result = composed.test(input);\nSystem.out.println(result);\n</code></pre> <p>This Predicate or() functional composition example first creates two basic Predicate instances. Second, the example creates a third Predicate composed from the first two, by calling the or() method on the first Predicate and passing the second Predicate as parameter to the or() method.</p> <p>The output of running the above example will be true because the first of the two Predicate instances used in the composed Predicate will return true when called with the String \"A hardworking person must relax sometimes\".</p>"},{"location":"java-java8/java-8-functional-composition/#function-composition","title":"Function Composition","text":"<p>The Java Function interface (java.util.function.Function) also contains a few methods that can be used to compose new Function instances from existing ones.</p>"},{"location":"java-java8/java-8-functional-composition/#compose","title":"compose()","text":"<p>The Java Function compose() method composes a new Function instance from the Function instance it is called on, and the Function instance passed as parameter to the compose() method.</p> <p>The Function returned by compose() will first call the Function passed as parameter to compose(), and then it will call the Function which compose() was called on. This is easier to understand with an example, so here is a Java Function compose() example:</p> <pre><code>Function&lt;Integer, Integer&gt; multiply = (value) -&gt; value * 2;\nFunction&lt;Integer, Integer&gt; add      = (value) -&gt; value + 3;\n\nFunction&lt;Integer, Integer&gt; addThenMultiply = multiply.compose(add);\n\nInteger result1 = addThenMultiply.apply(3);\nSystem.out.println(result1);\n</code></pre> <p>When called with the value 3, the composed Function will first call the add Function and then the multiply Function. The resulting calculation will be (3 + 3) * 2 and the result will be 12.</p>"},{"location":"java-java8/java-8-functional-composition/#andthen","title":"andThen()","text":"<p>The Java Function <code>andThen()</code> method works opposite of the compose() method. A Function composed with andThen() will first call the Function that andThen() was called on, and then it will call the Function passed as parameter to the andThen() method. Here is a Java Function andThen() example:</p> <pre><code>Function&lt;Integer, Integer&gt; multiply = (value) -&gt; value * 2;\nFunction&lt;Integer, Integer&gt; add      = (value) -&gt; value + 3;\n\nFunction&lt;Integer, Integer&gt; multiplyThenAdd = multiply.andThen(add);\n\nInteger result2 = multiplyThenAdd.apply(3);\nSystem.out.println(result2);\n</code></pre> <p>This example first creates a multiply Function and an add Function. Then the andThen() method is called on the multiply Function to compose a new Function, passing the add Function as parameter to andThen().</p> <p>Calling the Function composed by andThen() with the value 3 will result in the following calculation 3 * 2 + 3 and the result will be 9.</p> <p>Note: As mentioned in the beginning, andThen() works opposite of compose(). Therefore, calling a.andThen(b) is actually the same as calling b.compose(a) .</p>"},{"location":"java-java8/java-8-functional-composition/#references","title":"References","text":"<ul> <li>Java Functional Composition</li> </ul>"},{"location":"java-java8/java-8-functional-interfaces/","title":"Functional Interface","text":"<p>A <code>functional interface</code> in Java is an interface that contains only a single abstract (unimplemented) method. A functional interface can contain default and static methods which do have an implementation, in addition to the single unimplemented method.</p> <p>Here is a Java functional interface example:</p> <pre><code>public interface MyFunctionalInterface {\n    public void execute();\n}\n</code></pre> <p>The above counts as a functional interface in Java because it only contains a single method, and that method has no implementation. Normally a Java interface does not contain implementations of the methods it declares, but it can contain implementations in default methods, or in static methods. Below is another example of a Java functional interface, with implementations of some of the methods:</p> <pre><code>public interface MyFunctionalInterface2{\n    public void execute();\n\n    public default void print(String text) {\n        System.out.println(text);\n    }\n\n    public static void print(String text, PrintWriter writer) throws IOException {\n        writer.write(text);\n    }\n}\n</code></pre> <p>The above interface still counts as a functional interface in Java, since it only contains a single non-implemented method.</p>"},{"location":"java-java8/java-8-functional-interfaces/#functional-interfaces-can-be-implemented-by-a-lambda-expression","title":"Functional Interfaces Can Be Implemented by a Lambda Expression","text":"<p>A Java functional interface can be implemented by a Java Lambda Expression. Here is an example that implements the functional interface MyFunctionalInterface defined in the beginning of this Java functional interface tutorial:</p> <p>MyFunctionalInterface lambda = () -&gt; {     System.out.println(\"Executing...\"); } A Java lambda expression implements a single method from a Java interface. In order to know what method the lambda expression implements, the interface can only contain a single unimplemented method. In other words, the interface must be a Java functional interface.</p>"},{"location":"java-java8/java-8-functional-interfaces/#built-in-functional-interfaces-in-java-8","title":"Built-in Functional Interfaces in Java 8","text":"<p>Java contains a set of functional interfaces designed for commonly occuring use cases, so you don't have to create your own functional interfaces for every little use case. Some of these built-in functional interfaces:</p> <ul> <li>Function</li> <li>Predicate</li> <li>UnaryOperator</li> <li>BinaryOperator</li> <li>Supplier</li> <li>Consumer</li> </ul>"},{"location":"java-java8/java-8-functional-interfaces/#function","title":"Function","text":"<p>The Java Function interface (java.util.function.Function) interface is one of the most central functional interfaces in Java. The Function interface represents a function (method) that takes a single parameter and returns a single value. Here is how the Function interface definition looks:</p> <pre><code>public interface Function&lt;T,R&gt; {\n\n    public &lt;R&gt; apply(T parameter);\n}\n</code></pre> <p>The Function interface actually contains a few extra methods in addition to the methods listed above, but since they all come with a default implementation, you do not have to implement these extra methods.</p> <p>The only method you have to implement to implement the Function interface is the <code>apply()</code> method. Here is a Function implementation example:</p> <pre><code>public class AddThree implements Function&lt;Long, Long&gt; {\n\n    @Override\n    public Long apply(Long aLong) {\n        return aLong + 3;\n    }\n}\n</code></pre> <p>This Function implementation implements the apply() method so it takes a Long as parameter, and returns a Long. Here is an example of using the above AddThree class:</p> <pre><code>Function&lt;Long, Long&gt; adder = new AddThree();\nLong result = adder.apply((long) 4);\nSystem.out.println(\"result = \" + result);\n</code></pre> <p>First this example creates a new AddThree instance and assigns it to a Function variable. Second, the example calls the apply() method on the AddThree instance. Third, the example prints out the result (which is 7).</p> <p>You can also implement the Function interface using a Java lambda expression. Here is how that looks:</p> <pre><code>Function&lt;Long, Long&gt; adderLambda = (value) -&gt; value + 3;\nLong resultLambda = adder.apply((long) 8);\nSystem.out.println(\"resultLambda = \" + resultLambda);\n</code></pre> <p>As you can see, the Function interface implementation is now inlined in the declaration of the adderLambda variable, rather than in a separate class. This is a bit shorter, plus we can see directly in the above code what it is doing.</p>"},{"location":"java-java8/java-8-functional-interfaces/#predicate","title":"Predicate","text":"<p>The Java Predicate interface, java.util.function.Predicate, represents a simple function that takes a single value as parameter, and returns true or false. Here is how the Predicate functional interface definition looks:</p> <pre><code>public interface Predicate {\n    boolean test(T t);\n}\n</code></pre> <p>The Predicate interface contains more methods than the test() method, but the rest of the methods are default or static methods which you don't have to implement.</p> <p>You can implement the Predicate interface using a class, like this:</p> <pre><code>public class CheckForNull implements Predicate {\n    @Override\n    public boolean test(Object o) {\n        return o != null;\n    }\n}\n</code></pre> <p>You can also implement the Java Predicate interface using a Lambda expression. Here is an example of implementing the Predicate interface using a Java lambda expression:</p> <pre><code>Predicate predicate = (value) -&gt; value != null;\n</code></pre> <p>This lambda implementation of the Predicate interface effectively does the same as the implementation above that uses a class.</p>"},{"location":"java-java8/java-8-functional-interfaces/#unaryoperator","title":"UnaryOperator","text":"<p>The Java UnaryOperator interface is a functional interface that represents an operation which takes a single parameter and returns a parameter of the same type. Here is an example of a Java UnaryOperator implementation:</p> <pre><code>UnaryOperator&lt;Person&gt; unaryOperator =\n        (person) -&gt; { person.name = \"New Name\"; return person; };\n</code></pre> <p>The UnaryOperator interface can be used to represent an operation that takes a specific object as parameter, modifies that object, and returns it again - possibly as part of a functional stream processing chain.</p>"},{"location":"java-java8/java-8-functional-interfaces/#binaryoperator","title":"BinaryOperator","text":"<p>The Java BinaryOperator interface is a functional interface that represents an operation which takes two parameters and returns a single value. Both parameters and the return type must be of the same type.</p> <p>The Java BinaryOperator interface is useful when implementing functions that sum, subtract, divide, multiply etc. two elements of the same type, and returns a third element of the same type.</p> <p>Here is an example implementation of the BinaryOperator interface:</p> <pre><code>BinaryOperator&lt;MyValue&gt; binaryOperator =\n        (value1, value2) -&gt; { value1.add(value2); return value1; };\n</code></pre>"},{"location":"java-java8/java-8-functional-interfaces/#supplier","title":"Supplier","text":"<p>The Java Supplier interface is a functional interface that represents an function that supplies a value of some sorts. The Supplier interface can also be thought of as a factory interface. Here is an example implementation of the Java Supplier interface:</p> <pre><code>Supplier&lt;Integer&gt; supplier = () -&gt; new Integer((int) (Math.random() * 1000D));\n</code></pre> <p>This Java Supplier implementation returns a new Integer instance with a random value between 0 and 1000.</p>"},{"location":"java-java8/java-8-functional-interfaces/#consumer","title":"Consumer","text":"<p>The Java Consumer interface is a functional interface that represents an function that consumes a value without returning any value. A Java Consumer implementation could be printing out a value, or writing it to a file, or over the network etc. Here is an example implementation of the Java Consumer interface:</p> <pre><code>Consumer&lt;Integer&gt; consumer = (value) -&gt; System.out.println(value);\n</code></pre> <p>This Java Consumer implementation prints the value passed as parameter to it out to System.out.</p>"},{"location":"java-java8/java-8-functional-interfaces/#references","title":"References","text":"<ul> <li>Java Functional Interfaces</li> </ul>"},{"location":"java-java8/java-8-functional-programming/","title":"Functional programming","text":""},{"location":"java-java8/java-8-functional-programming/#functional-programming-basics","title":"Functional Programming Basics","text":"<p>Functional programming contains the following key concepts:</p> <ul> <li>Functions as first class objects</li> <li>Pure functions</li> <li>Higher order functions</li> </ul> <p>Pure functional programming has a set of rules to follow too:</p> <ul> <li>No state</li> <li>No side effects</li> <li>Immutable variables</li> <li>Favour recursion over looping</li> </ul>"},{"location":"java-java8/java-8-functional-programming/#functions-as-first-class-objects","title":"Functions as First Class Objects","text":"<p>In the functional programming paradigm, functions are first class objects in the language. That means that you can create an \"instance\" of a function, as have a variable reference that function instance, just like a reference to a String, Map or any other object. Functions can also be passed as parameters to other functions.</p> <p>In Java, methods are not first class objects. The closest we get is Java Lambda Expressions.</p>"},{"location":"java-java8/java-8-functional-programming/#pure-functions","title":"Pure Functions","text":"<p>A function is a pure function if:</p> <ul> <li>The execution of the function has no side effects.</li> <li>The return value of the function depends only on the input parameters passed to the function.</li> </ul> <p>Here is an example of a pure function (method) in Java:</p> <pre><code>public class ObjectWithPureFunction{\n\n    public int sum(int a, int b) {\n        return a + b;\n    }\n}\n</code></pre> <p>Notice how the return value of the sum() function only depends on the input parameters. Notice also that the sum() has no side effects, meaning it does not modify any state (variables) outside the function anywhere.</p> <p>Contrarily, here is an example of a non-pure function:</p> <pre><code>public class ObjectWithNonPureFunction{\n    private int value = 0;\n\n    public int add(int nextValue) {\n        this.value += nextValue;\n        return this.value;\n    }\n}\n</code></pre> <p>Notice how the method add() uses a member variable to calculate its return value, and it also modifies the state of the value member variable, so it has a side effect.</p>"},{"location":"java-java8/java-8-functional-programming/#higher-order-functions","title":"Higher Order Functions","text":"<p>A function is a higher order function if at least one of the following conditions are met:</p> <ul> <li>The function takes one or more functions as parameters.</li> <li>The function returns another function as result.</li> </ul> <p>In Java, the closest we can get to a higher order function is a function (method) that takes one or more lambda expressions as parameters, and returns another lambda expression. Here is an example of a higher order function in Java:</p> <pre><code>public class HigherOrderFunctionClass {\n\n    public &lt;T&gt; IFactory&lt;T&gt; createFactory(IProducer&lt;T&gt; producer, IConfigurator&lt;T&gt; configurator) {\n        return () -&gt; {\n           T instance = producer.produce();\n           configurator.configure(instance);\n           return instance;\n        }\n    }\n}\n</code></pre> <p>Notice how the createFactory() method returns a lambda expression as result. This is the first condition of a higher order function.</p> <p>Notice also that the createFactory() method takes two instances as parameters which are both implementations of interfaces (IProducer and IConfigurator). Java lambda expressions have to implement a functional interface, remember?</p> <p>Imagine the interfaces looks like this:</p> <pre><code>public interface IFactory&lt;T&gt; {\n   T create();\n}\npublic interface IProducer&lt;T&gt; {\n   T produce();\n}\npublic interface IConfigurator&lt;T&gt; {\n   void configure(T t);\n}\n</code></pre> <p>As you can see, all of these interfaces are functional interfaces. Therefore they can be implemented by Java lambda expressions - and therefore the createFactory() method is a higher order function.</p>"},{"location":"java-java8/java-8-functional-programming/#no-state","title":"No State","text":"<p>As mentioned in the beginning of this tutorial, a rule of the functional programming paradigm is to have no state. By \"no state\" is typically meant no state external to the function. A function may have local variables containing temporary state internally, but the function cannot reference any member variables of the class or object the function belongs to.</p> <p>Here is an example of a function that uses no external state:</p> <pre><code>public class Calculator {\n    public int sum(int a, int b) {\n       return a + b;\n    }\n}\n</code></pre> <p>Contrarily, here is an example of a function that uses external state:</p> <pre><code>public class Calculator {\n    private int initVal = 5;\n    public int sum(int a) {\n       return initVal + a;\n    }\n}\n</code></pre> <p>This function clearly violates the no state rule.</p>"},{"location":"java-java8/java-8-functional-programming/#no-side-effects","title":"No Side Effects","text":"<p>Another rule in the functional programming paradigm is that of no side effects. This means, that a function cannot change any state outside of the function. Changing state outside of a function is referred to as a side effect.</p> <p>State outside of a function refers both to member variables in the class or object the function, and member variables inside parameters to the functions, or state in external systems like file systems or databases.</p>"},{"location":"java-java8/java-8-functional-programming/#immutable-variables","title":"Immutable Variables","text":"<p>A third rule in the functional programming paradigm is that of immutable variables. Immutable variables makes it easier to avoid side effects.</p>"},{"location":"java-java8/java-8-functional-programming/#favour-recursion-over-looping","title":"Favour Recursion Over Looping","text":"<p>A fourth rule in the functional programming paradigm is to favour recursion over looping. Recursion uses function calls to achieve looping, so the code becomes more functional.</p> <p>Another alternative to loops is the Java Streams API. This API is functionally inspired.</p>"},{"location":"java-java8/java-8-functional-programming/#functional-interfaces","title":"Functional Interfaces","text":"<p>A functional interface in Java is an interface that only has one abstract method. By an abstract method is meant only one method which is not implemented. An interface can have multiple methods, e.g. default methods and static methods, both with implementations, but as long as the interface only has one method that is not implemented, the interface is considered a functional interface.</p> <p>Here is an example of a functional interface:</p> <pre><code>public interface MyInterface {\n    public void run();\n}\n</code></pre> <p>Here is another example of a functional interface with a default method and a static method too:</p> <pre><code>public interface MyInterface2 {\n    public void run();\n\n    public default void doIt() {\n        System.out.println(\"doing it\");\n    }\n\n    public static void doItStatically() {\n        System.out.println(\"doing it statically\");\n    }\n}\n</code></pre> <p>Notice the two methods with implementations. This is still a functional interface, because only run() is not implemented (abstract). However, if there were more methods without implementation, the interface would no longer be a functional interface, and could thus not be implemented by a Java lambda expression.</p>"},{"location":"java-java8/java-8-functional-programming/#references","title":"References","text":"<ul> <li>Java 101: Functional programming for Java developers, Part 1</li> <li>Java Functional Programming</li> </ul>"},{"location":"java-java8/java-8-higher-order-functions/","title":"Higher Order Functions","text":"<p>A higher order function is a function that either takes a function (method) as parameter, or returns a function after its execution.</p>"},{"location":"java-java8/java-8-higher-order-functions/#sorting-collections","title":"Sorting Collections","text":"<p>The first example of a higher order function is the Collections.sort() method which takes a Comparator as parameter. Here is an example:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;&gt;();\nlist.add(\"One\");\nlist.add(\"Abc\");\nlist.add(\"BCD\");\n\nCollections.sort(list, (String a, String b) -&gt; {\n    return a.compareTo(b);\n});\n\nSystem.out.println(list);\n</code></pre>"},{"location":"java-java8/java-8-higher-order-functions/#sorting-in-reverse-order","title":"Sorting in Reverse Order","text":"<p>Here is another example of a higher order function. This time it is a function that returns another function as result. Here is the Java higher order function example:</p> <pre><code>Comparator&lt;String&gt; comparator = (String a, String b) -&gt; {\n    return a.compareTo(b);\n};\n\nComparator&lt;String&gt; comparatorReversed = comparator.reversed();\n\nCollections.sort(list, comparatorReversed);\n\nSystem.out.println(list);\n</code></pre> <p>This example first creates a Java lambda expression that implements the Comparator interface.</p> <p>Second, the example calls the reversed() method on the Comparator lambda. The reversed() method returns a new Comparator lambda, which reverse the result returned by the first Comparator implementation.</p> <p>Because the reversed() method returns a lambda (function), the reversed() method is considered a higher order function.</p> <p>Third, the example sorts the List of Strings using the Collections.sort() method.</p>"},{"location":"java-java8/java-8-higher-order-functions/#references","title":"References","text":"<ul> <li>Java Higher Order Functions</li> </ul>"},{"location":"java-java8/java-8-lazy-execution-with-lambda/","title":"Lazy Execution with Lambda","text":""},{"location":"java-java8/java-8-lazy-execution-with-lambda/#examples","title":"Examples","text":"<p>modern java page 222.</p> <pre><code>if (logger.isLoggable(Log.FINER)) {\n    logger.finer(\"Problem: \" + generateDiagnostic());\n}\n\nlogger.log(Level.FINER, \"Problem: \" + generateDiagnostic());\n\npublic void log(Level level, Supplier&lt;String&gt; msgSupplier)\nlogger.log(Level.FINER, () -&gt; \"Problem: \" + generateDiagnostic());\n</code></pre> <p>another example</p> <pre><code>public class NonLazyCodeExample {\n    public static void main(String args[]) {\n        final int number = 4;\n        final boolean computeResult = compute(number);\n        final boolean processResult = process(number);\n        if (computeResult &amp;&amp; processResult) {\n            System.out.println(\"TRUE\");\n        } else {\n            System.out.println(\"FALSE\");\n        }\n    }\n    public static boolean compute(final int number) {\n        System.out.println(\"computing number : \" + number);\n        return number &gt; 5 ? true : false;\n    }\n    public static boolean process(final int number) {\n        System.out.println(\"processing number : \" + number);\n        return number % 3 == 0 ? true : false;\n    }\n}\n</code></pre> <p>logging function in lambda.</p> <pre><code>List&lt;Integer&gt; result = numbers.stream()\n         .peek(x -&gt; System.out.println(\"from stream: \" + x))\n         .map(x -&gt; x + 17)\n         .peek(x -&gt; System.out.println(\"after map: \" + x))\n         .filter(x -&gt; x % 2 == 0)\n         .peek(x -&gt; System.out.println(\"after filter: \" + x))\n         .limit(3)\n         .peek(x -&gt; System.out.println(\"after limit: \" + x))\n         .collect(toList());\n</code></pre> <p>This code produces useful output at each step of the pipeline:</p> <pre><code>from stream: 2\nafter map: 19\nfrom stream: 3\nafter map: 20\nafter filter: 20\nafter limit: 20\nfrom stream: 4\nafter map: 21\nfrom stream: 5\nafter map: 22\nafter filter: 22\nafter limit: 22\n</code></pre>"},{"location":"java-java8/java-8-lazy-execution-with-lambda/#references","title":"References","text":"<ul> <li>A Little Lazy Lambda Tutorial</li> </ul>"},{"location":"java-java8/java-8-new-features/","title":"New Features","text":"<p>JAVA 8 is a major feature release of JAVA programming language development. Its initial version was released on 18 March 2014. With the Java 8 release, Java provided supports for functional programming, new JavaScript engine, new APIs for date time manipulation, new streaming API, etc.</p> <p>New Features:</p> <ul> <li><code>Lambda expression</code> \u2212 Adds functional processing capability to Java.</li> <li><code>Method references</code> \u2212 Referencing functions by their names instead of invoking them directly. Using functions as parameter.</li> <li><code>Default method</code> \u2212 Interface to have default method implementation.</li> <li><code>New tools</code> \u2212 New compiler tools and utilities are added like \u2018jdeps\u2019 to figure out dependencies.</li> <li><code>Stream API</code> \u2212 New stream API to facilitate pipeline processing.</li> <li><code>Date Time API</code> \u2212 Improved date time API.</li> <li><code>Optional</code> \u2212 Emphasis on best practices to handle null values properly.</li> <li><code>Nashorn JavaScript Engine</code> \u2212 A Java-based engine to execute JavaScript code.</li> </ul>"},{"location":"java-java8/java-8-new-features/#lambda-expressions","title":"Lambda Expressions","text":"<p>Lambda expressions are introduced in Java 8 and are touted to be the biggest feature of Java 8. Lambda expression facilitates functional programming, and simplifies the development a lot.</p>"},{"location":"java-java8/java-8-new-features/#syntax","title":"Syntax","text":"<p>A lambda expression is characterized by the following syntax.</p> <pre><code>parameter -&gt; expression body\n</code></pre> <ul> <li><code>Optional type declaration</code> \u2212 No need to declare the type of a parameter. The compiler can inference the same from the value of the parameter.</li> <li><code>Optional parenthesis around parameter</code> \u2212 No need to declare a single parameter in parenthesis. For multiple parameters, parentheses are required.</li> <li><code>Optional curly braces</code> \u2212 No need to use curly braces in expression body if the body contains a single statement.</li> <li><code>Optional return keyword</code> \u2212 The compiler automatically returns the value if the body has a single expression to return the value. Curly braces are required to indicate that expression returns a value.</li> </ul>"},{"location":"java-java8/java-8-new-features/#example","title":"Example","text":"<pre><code>// interface with a single method only\npublic interface MathOperation {\n    int operate(int a, int b);\n}\n\n// interface with a single method only\npublic interface GreetingService {\n    void sayMessage(String message);\n}\n\npublic class Calculator {\n    public int operate(int a, int b, MathOperation mathOperation) {\n        return mathOperation.operate(a, b);\n    }\n}\n\npublic static void main(String args[]) {\n    // with type declaration\n    MathOperation addition = (int a, int b) -&gt; a + b;\n\n    // with out type declaration\n    MathOperation subtraction = (a, b) -&gt; a - b;\n\n    // with return statement along with curly braces\n    MathOperation multiplication = (int a, int b) -&gt; { return a * b; };\n\n    // without return statement and without curly braces\n    MathOperation division = (int a, int b) -&gt; a / b;\n\n    Calculator calculator = new Calculator();\n    System.out.println(\"10 + 5 = \" + calculator.operate(10, 5, addition));\n    System.out.println(\"10 - 5 = \" + calculator.operate(10, 5, subtraction));\n    System.out.println(\"10 x 5 = \" + calculator.operate(10, 5, multiplication));\n    System.out.println(\"10 / 5 = \" + calculator.operate(10, 5, division));\n\n    // without parenthesis\n    GreetingService greetService1 = message -&gt;\n            System.out.println(\"Hello \" + message);\n\n    // with parenthesis\n    GreetingService greetService2 = (message) -&gt;\n            System.out.println(\"Hello \" + message);\n\n    greetService1.sayMessage(\"Java8\");\n    greetService2.sayMessage(\"Lambda\");\n}\n</code></pre> <p>Output.</p> <pre><code>10 + 5 = 15\n10 - 5 = 5\n10 x 5 = 50\n10 / 5 = 2\nHello Java8\nHello Lambda\n</code></pre>"},{"location":"java-java8/java-8-new-features/#method-references","title":"Method References","text":"<p>Method references help to point to methods by their names. A method reference is described using <code>::</code> symbol. A method reference can be used to point the following types of methods:</p> <ul> <li>Static methods</li> <li>Instance methods</li> <li>Constructors using new operator (TreeSet::new)</li> </ul> <p>Example</p> <pre><code>public class MethodReferencesExample {\n    public static void main(String args[]) {\n\n        List&lt;Integer&gt; nums = Arrays.asList(1,2,3,4,5,6);\n        nums.forEach(System.out::println);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>1\n2\n3\n4\n5\n6\n</code></pre>"},{"location":"java-java8/java-8-new-features/#functional-interfaces","title":"Functional Interfaces","text":"<p>Functional interfaces have a <code>single</code> functionality to exhibit. For example, a Comparable interface with a single method \u2018compareTo\u2019 is used for comparison purpose. Java 8 has defined a lot of functional interfaces to be used extensively in lambda expressions. Following is the list of functional interfaces defined in <code>java.util.Function</code> package.</p> <p><code>Predicate &lt;T&gt;</code> interface is a functional interface with a method test(Object) to return a Boolean value. This interface signifies that an object is tested to be true or false.</p> <p>Example</p> <pre><code>public class FunctionalInterfaceExample {\n    public static void main(String args[]) {\n        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n        // Predicate&lt;Integer&gt; predicate = n -&gt; true\n        // n is passed as parameter to test method of Predicate interface\n        // test method will always return true no matter what value n has.\n\n        System.out.print(\"Print all numbers: \");\n\n        //pass n as parameter\n        evaluate(list, n-&gt;true);\n\n        // Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0\n        // n is passed as parameter to test method of Predicate interface\n        // test method will return true if n%2 comes to be zero\n\n        System.out.print(\"Print even numbers: \");\n        //evaluate(list, n-&gt; n%2 == 0 );\n        evaluate(list, new evenPredicate());\n\n        // Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3\n        // n is passed as parameter to test method of Predicate interface\n        // test method will return true if n is greater than 3.\n\n        System.out.print(\"Print numbers greater than 3: \");\n        evaluate(list, n-&gt; n &gt; 3 );\n    }\n\n    public static void evaluate(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) {\n        for(Integer num: list) {\n            if (predicate.test(num)) {\n                System.out.print(num + \",\");\n            }\n        }\n        System.out.println();\n    }\n\n    private static class evenPredicate implements Predicate&lt;Integer&gt; {\n        @Override\n        public boolean test(Integer num) {\n            return num % 2 == 0;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Print all numbers: 1,2,3,4,5,6,7,8,9,\nPrint even numbers: 2,4,6,8,\nPrint numbers greater than 3: 4,5,6,7,8,9,\n</code></pre>"},{"location":"java-java8/java-8-new-features/#default-methods","title":"Default Methods","text":"<p>Java provides a facility to create default methods inside the interface. Methods which are defined inside the interface and tagged with default are known as default methods. These methods are non-abstract methods.</p> <pre><code>public class DefaultMethodExample {\n    public static void main(String args[]) {\n        Vehicle vehicle = new Car();\n        vehicle.print();\n    }\n}\n\ninterface Vehicle {\n    // default method\n    default void print() {\n        System.out.println(\"I am a vehicle!\");\n    }\n\n    // static method\n    static void blowHorn() {\n        System.out.println(\"Blowing horn!!!\");\n    }\n}\n\ninterface FourWheeler {\n    default void print() {\n        System.out.println(\"I am a four wheeler!\");\n    }\n}\n\nclass Car implements Vehicle, FourWheeler {\n    public void print() {\n        Vehicle.super.print();\n        FourWheeler.super.print();\n        Vehicle.blowHorn();\n        System.out.println(\"I am a car!\");\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>I am a vehicle!\nI am a four wheeler!\nBlowing horn!!!\nI am a car!\n</code></pre>"},{"location":"java-java8/java-8-new-features/#streams","title":"Streams","text":""},{"location":"java-java8/java-8-new-features/#what-is-stream","title":"What is Stream?","text":"<p>Stream represents a sequence of objects from a source, which supports aggregate operations. Following are the characteristics of a Stream:</p> <ul> <li><code>Sequence of elements</code> \u2212 A stream provides a set of elements of specific type in a sequential manner. A stream gets/computes elements on demand. It never stores the elements.</li> <li><code>Source</code> \u2212 Stream takes Collections, Arrays, or I/O resources as input source.</li> <li><code>Aggregate operations</code> \u2212 Stream supports aggregate operations like filter, map, limit, reduce, find, match, and so on.</li> <li><code>Pipelining</code> \u2212 Most of the stream operations return stream itself so that their result can be pipelined. These operations are called intermediate operations and their function is to take input, process them, and return output to the target. <code>collect()</code> method is a terminal operation which is normally present at the end of the pipelining operation to mark the end of the stream.</li> <li><code>Automatic iterations</code> \u2212 Stream operations do the iterations internally over the source elements provided, in contrast to Collections where explicit iteration is required.</li> </ul>"},{"location":"java-java8/java-8-new-features/#generating-streams","title":"Generating Streams","text":"<p>With Java 8, Collection interface has two methods to generate a Stream.</p> <ul> <li><code>stream()</code> \u2212 Returns a <code>sequential stream</code> considering collection as its source.</li> <li><code>parallelStream()</code> \u2212 Returns a <code>parallel stream</code> considering collection as its source.</li> </ul> <pre><code>List&lt;String&gt; names = Arrays.asList(\"Johnny\", \"\", \"Peter\", \"Sean\", \"\", \"George\");\nList&lt;String&gt; filtered = names.stream().filter(name -&gt; !name.isEmpty()).collect(Collectors.toList());\nList&lt;String&gt; filtered2 = names.parallelStream().filter(name -&gt; !name.isEmpty()).collect(Collectors.toList());\n\n// names = [Johnny, , Peter, Sean, , George]\n// filtered = [Johnny, Peter, Sean, George]\n// filtered2 = [Johnny, Peter, Sean, George]\n</code></pre>"},{"location":"java-java8/java-8-new-features/#stream-methods","title":"Stream Methods","text":"<ul> <li><code>forEach</code> - iterate each element of the stream</li> <li><code>map</code> - map each element to its corresponding result</li> <li><code>filter</code> - eliminate elements based on a criteria</li> <li><code>limit</code> - reduce the size of the stream</li> <li><code>sorted</code> - sort the elements in stream</li> </ul> <p>Example</p> <pre><code>private static void streamMethods() {\n    List&lt;Integer&gt; nums = Arrays.asList(3, 7, 1, 8, 2, 4, 9, 5, 6);\n\n    // forEach\n    System.out.println(\"forEach\");\n    nums.stream().forEach(System.out::println);\n\n    List&lt;Integer&gt; result;\n\n    // map\n    System.out.print(\"map:    \");\n    result = nums.stream().map(i -&gt; i * i).collect(Collectors.toList());\n    System.out.println(result);\n\n    // filter\n    System.out.print(\"filter: \");\n    result = nums.stream().filter(i -&gt; i &gt; 4).collect(Collectors.toList());\n    System.out.println(result);\n\n    // limit\n    System.out.print(\"limit:  \");\n    result = nums.stream().limit(3).collect(Collectors.toList());\n    System.out.println(result);\n\n    // sorted\n    System.out.print(\"sorted: \");\n    result = nums.stream().sorted().collect(Collectors.toList());\n    System.out.println(result);\n}\n</code></pre> <p>Output.</p> <pre><code>forEach\n3\n7\n1\n8\n2\n4\n9\n5\n6\nmap:    [9, 49, 1, 64, 4, 16, 81, 25, 36]\nfilter: [7, 8, 9, 5, 6]\nlimit:  [3, 7, 1]\nsorted: [1, 2, 3, 4, 5, 6, 7, 8, 9]\n</code></pre>"},{"location":"java-java8/java-8-new-features/#pipeline","title":"Pipeline","text":"<p>Pipe the methods.</p> <pre><code>private static void pipeline() {\n    // pipelining\n    List&lt;Integer&gt; nums = Arrays.asList(3, 7, 1, 8, 2, 9, 5, 6);\n    System.out.print(\"pipelining: \");\n    List&lt;Integer&gt; result = nums.stream().sorted().filter(i -&gt; i &gt; 4).limit(3).map(i-&gt;i*i).collect(Collectors.toList());\n    System.out.println(result);\n\n    // sorted:  [1,2,3,4,5,6,7,8,9]\n    // filter:  [5,6,7,8,9]\n    // limit:   [5,6,7]\n    // map:     [25,36,49]\n    // forEach: [25,36,49]\n}\n</code></pre> <p>Output.</p> <pre><code>pipelining: [25, 36, 49]\n</code></pre>"},{"location":"java-java8/java-8-new-features/#collectors","title":"Collectors","text":"<p>Collectors are used to combine the result of processing on the elements of a stream. Collectors can be used to return a list or a string.</p> <pre><code>private static void collectors() {\n    List&lt;String&gt; names = Arrays.asList(\"Johnny\", \"\", \"Peter\", \"Sean\", \"\", \"George\");\n\n    // convert stream to list\n    List&lt;String&gt; filtered = names.stream().filter(name -&gt; !name.isEmpty()).collect(Collectors.toList());\n    System.out.println(\"Filtered List: \" + filtered);\n\n    // convert list to string with common as delimiter\n    String merged = names.stream().filter(name -&gt; !name.isEmpty()).collect(Collectors.joining(\", \"));\n    System.out.println(\"Merged String: \" + merged);\n}\n</code></pre> <p>Output.</p> <pre><code>Filtered List: [Johnny, Peter, Sean, George]\nMerged String: Johnny, Peter, Sean, George\n</code></pre>"},{"location":"java-java8/java-8-new-features/#statistics","title":"Statistics","text":"<p>With Java 8, statistics collectors are introduced to calculate all statistics when stream processing is being done.</p> <pre><code>private static void statistics() {\n    List&lt;Integer&gt; nums = Arrays.asList(3, 7, 1, 8, 2, 9, 5, 6);\n\n    IntSummaryStatistics stats = nums.stream().mapToInt((x) -&gt; x).summaryStatistics();\n\n    System.out.println(\"Maximum number in List : \" + stats.getMax());\n    System.out.println(\"Minimum number in List : \" + stats.getMin());\n    System.out.println(\"Sum of all numbers : \" + stats.getSum());\n    System.out.println(\"Average of all numbers : \" + stats.getAverage());\n}\n</code></pre> <p>Output.</p> <pre><code>Maximum number in List : 9\nMinimum number in List : 1\nSum of all numbers : 41\nAverage of all numbers : 5.125\n</code></pre>"},{"location":"java-java8/java-8-new-features/#optional-class","title":"Optional Class","text":"<p><code>Optional</code> is a container object used to contain not-null objects. Optional object is used to represent null with absent value. This class has various utility methods to facilitate code to handle values as \u2018available\u2019 or \u2018not available\u2019 instead of checking null values. It is introduced in Java 8 and is similar to what Optional is in Guava.</p> <pre><code>public class OptionalClassExample {\n    public static void main(String args[]) {\n        Integer value1 = null;\n        Integer value2 = new Integer(10);\n\n        //Optional.ofNullable - allows passed parameter to be null.\n        Optional&lt;Integer&gt; a = Optional.ofNullable(value1);\n\n        //Optional.of - throws NullPointerException if passed parameter is null\n        Optional&lt;Integer&gt; b = Optional.of(value2);\n        OptionalSum os = new OptionalSum();\n        System.out.println(os.sum(a,b));\n    }\n}\n\nclass OptionalSum {\n    public Integer sum(Optional&lt;Integer&gt; a, Optional&lt;Integer&gt; b) {\n        //Optional.isPresent - checks the value is present or not\n        System.out.println(\"First parameter is present: \" + a.isPresent());\n        System.out.println(\"Second parameter is present: \" + b.isPresent());\n\n        //Optional.orElse - returns the value if present otherwise returns\n        //the default value passed.\n        Integer value1 = a.orElse(new Integer(0));\n\n        //Optional.get - gets the value, value should be present\n        Integer value2 = b.get();\n        return value1 + value2;\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>First parameter is present: false\nSecond parameter is present: true\n10\n</code></pre>"},{"location":"java-java8/java-8-new-features/#nashorn-javascript","title":"Nashorn JavaScript","text":"<p>With Java 8, <code>Nashorn</code>, a much improved javascript engine is introduced, to replace the existing <code>Rhino</code>. Nashorn provides 2 to 10 times better performance, as it directly compiles the code in memory and passes the bytecode to JVM.</p>"},{"location":"java-java8/java-8-new-features/#jjs","title":"jjs","text":"<p>For Nashorn engine, JAVA 8 introduces a new command line tool, <code>jjs</code>, to execute javascript codes at console.</p> <p>Create a javascript file name 'sample.js' as follows.</p> <pre><code>// sample.js\nprint('Hello World from javascript!');\n</code></pre> <p>Use jjs to execute this js file.</p> <pre><code>jjs sample.js\n</code></pre> <p>Output.</p> <pre><code>Hello World from javascript!\n</code></pre>"},{"location":"java-java8/java-8-new-features/#calling-javascript-from-java","title":"Calling JavaScript from Java","text":"<p>Using ScriptEngineManager, JavaScript code can be called and interpreted in Java.</p> <pre><code>public class NashornExample {\n    // Call javascript from java with ScriptEngineManager\n    public static void main(String args[]) {\n        ScriptEngineManager scriptEngineManager = new ScriptEngineManager();\n        ScriptEngine nashorn = scriptEngineManager.getEngineByName(\"nashorn\");\n\n        String name = \"Johnny\";\n        Integer result = null;\n\n        try {\n            // call eval without return value\n            nashorn.eval(\"print('\" + name + \"')\");\n            // call eval with return value\n            result = (Integer) nashorn.eval(\"10 + 2\");\n\n        } catch(ScriptException e) {\n            System.out.println(\"Error executing script: \"+ e.getMessage());\n        }\n        System.out.println(result.toString());\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Johnny\n12\n</code></pre>"},{"location":"java-java8/java-8-new-features/#calling-java-from-javascript","title":"Calling Java from JavaScript","text":"<p>Create javascript file named 'calljava.js' as follows.</p> <pre><code>// calljava.js\nvar BigDecimal = Java.type('java.math.BigDecimal');\n\nfunction calculate(amount, percentage) {\n\n   var result = new BigDecimal(amount).multiply(new BigDecimal( )).divide(\n      new BigDecimal(\"100\"), 2, BigDecimal.ROUND_HALF_EVEN);\n\n   return result.toPlainString();\n}\nvar result = calculate(568000000000000000023,13.9);\nprint(result);\n</code></pre> <p>Run it with jjs.</p> <pre><code>&gt; jjs calljava.js\n78952000000000002017.94\n</code></pre>"},{"location":"java-java8/java-8-new-features/#new-datetime-api","title":"New Date/Time API","text":"<p>With Java 8, a new Date-Time API is introduced to cover the following drawbacks of old date-time API.</p> <ul> <li><code>Not thread safe</code> \u2212 java.util.Date is not thread safe, thus developers have to deal with concurrency issue while using date. The new date-time API is immutable and does not have setter methods.</li> <li><code>Poor design</code> \u2212 Default Date starts from 1900, month starts from 1, and day starts from 0, so no uniformity. The old API had less direct methods for date operations. The new API provides numerous utility methods for such operations.</li> <li><code>Difficult time zone handling</code> \u2212 Developers had to write a lot of code to deal with timezone issues. The new API has been developed keeping domain-specific design in mind.</li> </ul> <p>Java 8 introduces a new date-time API under the package java.time. Following are some of the important classes introduced in java.time package.</p> <ul> <li><code>Local</code> \u2212 Simplified date-time API with no complexity of timezone handling.</li> <li><code>Zoned</code> \u2212 Specialized date-time API to deal with various timezones.</li> </ul>"},{"location":"java-java8/java-8-new-features/#local-date-time-api","title":"Local Date-Time API","text":"<p>Following three classes simplify the development where timezones are not required.</p> <ul> <li>LocalDate</li> <li>LocalTime</li> <li>LocalDateTime</li> </ul> <pre><code>// Local Date-Time API\nprivate static void testLocalDateTime() {\n    // Get the current date and time\n    LocalDateTime currentDT = LocalDateTime.now();\n    System.out.println(\"Current DateTime: \" + currentDT);\n\n    LocalDate date1 = currentDT.toLocalDate();\n    System.out.println(\"Current Date: \" + date1);\n\n    Month month = currentDT.getMonth();\n    int day = currentDT.getDayOfMonth();\n    int seconds = currentDT.getSecond();\n\n    System.out.println(\"Month: \" + month +\", day: \" + day +\", seconds: \" + seconds);\n\n    // Update year and month\n    LocalDateTime date2 = currentDT.withDayOfMonth(10).withYear(2012);\n    System.out.println(\"New DateTime: \" + date2);\n\n    // Local Date\n    LocalDate date = LocalDate.of(2014, Month.DECEMBER, 12);\n    System.out.println(\"New Local Date: \" + date);\n\n    // 22 hour 15 minutes\n    LocalTime time = LocalTime.of(22, 15);\n    System.out.println(\"New Local Time: \" + time);\n\n    // Parse a string\n    LocalTime timeParse = LocalTime.parse(\"20:15:30\");\n    System.out.println(\"Time from String: \" + timeParse);\n}\n</code></pre> <p>Output.</p> <pre><code>Current DateTime: 2019-04-14T10:15:37.325\nCurrent Date: 2019-04-14\nMonth: APRIL, day: 14, seconds: 37\nNew DateTime: 2012-04-10T10:15:37.325\nNew Local Date: 2014-12-12\nNew Local Time: 22:15\nTime from String: 20:15:30\n</code></pre>"},{"location":"java-java8/java-8-new-features/#zoned-date-time-api","title":"Zoned Date-Time API","text":"<p>Zoned date-time API is to be used when <code>time zone</code> is to be considered.</p> <pre><code>// Zoned Date-Time API\npublic static void testZonedDateTime() {\n    // Get the current date and time\n    ZonedDateTime zdt = ZonedDateTime.parse(\"2007-12-03T10:15:30+05:30[Asia/Shanghai]\");\n    System.out.println(\"Zone DateTime: \" + zdt);\n    System.out.println(\"Zone Id: \" + zdt.getZone());\n\n    ZoneId id = ZoneId.of(\"Europe/Paris\");\n    System.out.println(\"ZoneId: \" + id);\n\n    ZoneId currentZone = ZoneId.systemDefault();\n    System.out.println(\"CurrentZone: \" + currentZone);\n}\n</code></pre> <p>Output.</p> <pre><code>Zone DateTime: 2007-12-03T10:15:30+08:00[Asia/Shanghai]\nZone Id: Asia/Shanghai\nZoneId: Europe/Paris\nCurrentZone: America/Los_Angeles\n</code></pre>"},{"location":"java-java8/java-8-new-features/#chrono-units-enum","title":"Chrono Units Enum","text":"<p>java.time.temporal.ChronoUnit enum is added in Java 8 to replace the integer values used in old API to represent day, month, etc. Let us see them in action.</p> <pre><code>// Chrono Units Enum\npublic static void testChromoUnits() {\n    // Get the current date\n    LocalDate today = LocalDate.now();\n    System.out.println(\"Current date: \" + today);\n\n    // Add 1 week to the current date\n    LocalDate nextWeek = today.plus(1, ChronoUnit.WEEKS);\n    System.out.println(\"Next week: \" + nextWeek);\n\n    // Add 1 month to the current date\n    LocalDate nextMonth = today.plus(1, ChronoUnit.MONTHS);\n    System.out.println(\"Next month: \" + nextMonth);\n\n    // Add 1 year to the current date\n    LocalDate nextYear = today.plus(1, ChronoUnit.YEARS);\n    System.out.println(\"Next year: \" + nextYear);\n\n    // Add 10 years to the current date\n    LocalDate nextDecade = today.plus(1, ChronoUnit.DECADES);\n    System.out.println(\"Date after ten year: \" + nextDecade);\n}\n</code></pre> <p>Output.</p> <pre><code>Current date: 2019-04-14\nNext week: 2019-04-21\nNext month: 2019-05-14\nNext year: 2020-04-14\nDate after ten year: 2029-04-14\n</code></pre>"},{"location":"java-java8/java-8-new-features/#period-and-duration","title":"Period and Duration","text":"<p>With Java 8, two specialized classes are introduced to deal with the time differences.</p> <ul> <li><code>Period</code> \u2212 It deals with date based amount of time.</li> <li><code>Duration</code> \u2212 It deals with time based amount of time.</li> </ul> <pre><code>// Period\npublic static void testPeriod() {\n    //Get the current date\n    LocalDate date1 = LocalDate.now();\n    System.out.println(\"Current date: \" + date1);\n\n    //add 1 month to the current date\n    LocalDate date2 = date1.plus(1, ChronoUnit.MONTHS);\n    System.out.println(\"Next month: \" + date2);\n\n    Period period = Period.between(date2, date1);\n    System.out.println(\"Period: \" + period);\n}\n\n// Duration\npublic static void testDuration() {\n    LocalTime time1 = LocalTime.now();\n    Duration twoHours = Duration.ofHours(2);\n\n    LocalTime time2 = time1.plus(twoHours);\n    Duration duration = Duration.between(time1, time2);\n\n    System.out.println(\"Duration: \" + duration);\n}\n</code></pre> <p>Output.</p> <pre><code>Current date: 2019-04-14\nNext month: 2019-05-14\nPeriod: P-1M\nDuration: PT2H\n</code></pre>"},{"location":"java-java8/java-8-new-features/#temporal-adjusters","title":"Temporal Adjusters","text":"<p>TemporalAdjuster is used to perform the date mathematics. For example, get the \"Second Saturday of the Month\" or \"Next Tuesday\".</p> <pre><code>// Temporal Adjusters\npublic static void testAdjusters() {\n    //Get the current date\n    LocalDate localDate = LocalDate.now();\n    System.out.println(\"Current date: \" + localDate);\n\n    //get the next tuesday\n    LocalDate nextTuesday = localDate.with(TemporalAdjusters.next(DayOfWeek.TUESDAY));\n    System.out.println(\"Next Tuesday on : \" + nextTuesday);\n\n    //get the second saturday of next month\n    LocalDate firstInYear = LocalDate.of(localDate.getYear(), localDate.getMonth(), 1);\n    LocalDate secondSaturday = firstInYear.with(TemporalAdjusters.nextOrSame(\n            DayOfWeek.SATURDAY)).with(TemporalAdjusters.next(DayOfWeek.SATURDAY));\n    System.out.println(\"Second Saturday on : \" + secondSaturday);\n}\n</code></pre> <p>Output.</p> <pre><code>Current date: 2019-04-14\nNext Tuesday on : 2019-04-16\nSecond Saturday on : 2019-04-13\n</code></pre>"},{"location":"java-java8/java-8-new-features/#backward-compatibility","title":"Backward Compatibility","text":"<p>A <code>toInstant()</code> method is added to the original Date and Calendar objects, which can be used to convert them to the new Date-Time API. Use an <code>ofInstant(Insant,ZoneId)</code> method to get a LocalDateTime or ZonedDateTime object.</p> <pre><code>// Backward Compatibility with ofInstant\npublic static void testBackwardCompatability() {\n    //Get the current date\n    Date currentDate = new Date();\n    System.out.println(\"Current date: \" + currentDate);\n\n    //Get the instant of current date in terms of milliseconds\n    Instant now = currentDate.toInstant();\n    ZoneId currentZone = ZoneId.systemDefault();\n\n    LocalDateTime localDateTime = LocalDateTime.ofInstant(now, currentZone);\n    System.out.println(\"Local date: \" + localDateTime);\n\n    ZonedDateTime zonedDateTime = ZonedDateTime.ofInstant(now, currentZone);\n    System.out.println(\"Zoned date: \" + zonedDateTime);\n}\n</code></pre> <p>Output.</p> <pre><code>Current date: Sun Apr 14 10:30:19 PDT 2019\nLocal date: 2019-04-14T10:30:19.572\nZoned date: 2019-04-14T10:30:19.572-07:00[America/Los_Angeles]\n</code></pre>"},{"location":"java-java8/java-8-new-features/#base64","title":"Base64","text":"<p>Java 8 now has inbuilt encoder and decoder for Base64 encoding. In Java 8, we can use three types of Base64 encoding.</p> <ul> <li><code>Simple</code> \u2212 Output is mapped to a set of characters lying in <code>A-Za-z0-9+/</code>. The encoder does not add any line feed in output, and the decoder rejects any character other than A-Za-z0-9+/.</li> <li><code>URL</code> \u2212 Output is mapped to set of characters lying in <code>A-Za-z0-9+_</code>. Output is URL and filename safe.</li> <li><code>MIME</code> \u2212 Output is mapped to MIME friendly format. Output is represented in lines of no more than 76 characters each, and uses a carriage return '\\r' followed by a linefeed '\\n' as the line separator. No line separator is present to the end of the encoded output.</li> </ul> <p>Example</p> <pre><code>public static void main(String args[]) {\n    try {\n        // Original\n        String original = \"jojozhuang.github.io?java8\";\n        System.out.println(\"Original String: \" + original);\n\n        // Encode using basic encoder\n        String strEncoded = Base64.getEncoder().encodeToString(\n                original.getBytes(\"utf-8\"));\n        System.out.println(\"Base64 Encoded String (Basic) :\" + strEncoded);\n\n        // Decode\n        byte[] base64decodedBytes = Base64.getDecoder().decode(strEncoded);\n        System.out.println(\"Decoded String: \" + new String(base64decodedBytes, \"utf-8\"));\n        strEncoded = Base64.getUrlEncoder().encodeToString(\n                original.getBytes(\"utf-8\"));\n        System.out.println(\"Base64 Encoded String (URL) :\" + strEncoded);\n\n        // MIME Example\n        String uuid = UUID.randomUUID().toString();\n        System.out.println(\"Original UUID: \" + uuid);\n        byte[] mimeBytes = uuid.getBytes(\"utf-8\");\n        String mimeEncodedString = Base64.getMimeEncoder().encodeToString(mimeBytes);\n        System.out.println(\"Base64 Encoded String (MIME) :\" + mimeEncodedString);\n\n        base64decodedBytes = Base64.getDecoder().decode(mimeEncodedString);\n        System.out.println(\"Decoded UUID: \" + new String(base64decodedBytes, \"utf-8\"));\n\n    } catch(UnsupportedEncodingException e) {\n        System.out.println(\"Error :\" + e.getMessage());\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Original String: jojozhuang.github.io?java8\nBase64 Encoded String (Basic) :am9qb3podWFuZy5naXRodWIuaW8/amF2YTg=\nDecoded String: jojozhuang.github.io?java8\nBase64 Encoded String (URL) :am9qb3podWFuZy5naXRodWIuaW8_amF2YTg=\nOriginal UUID: 565ce125-6615-441e-8719-f7cd721e0077\nBase64 Encoded String (MIME) :NTY1Y2UxMjUtNjYxNS00NDFlLTg3MTktZjdjZDcyMWUwMDc3\nDecoded UUID: 565ce125-6615-441e-8719-f7cd721e0077\n</code></pre>"},{"location":"java-java8/java-8-new-features/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java 8 New Features on GitHub</li> </ul>"},{"location":"java-java8/java-8-new-features/#references","title":"References","text":"<ul> <li>Java 8 - Overview</li> <li>Java Method References</li> </ul>"},{"location":"java-java8/java-8-predicate/","title":"Predicate","text":""},{"location":"java-java8/java-8-predicate/#predicate-interface","title":"Predicate Interface","text":"<p>The Java <code>Predicate</code> interface, java.util.function.Predicate, represents a simple function that takes a single value as parameter, and returns true or false. Here is how the Predicate functional interface definition looks:</p> <pre><code>public interface Predicate {\n    boolean test(T t);\n}\n</code></pre> <p>The Predicate interface contains more methods than the <code>test()</code> method, but the rest of the methods are default or static methods which you don't have to implement.</p> <p>You can implement the Predicate interface using a class, like this:</p> <pre><code>public class CheckForNull implements Predicate {\n    @Override\n    public boolean test(Object o) {\n        return o != null;\n    }\n}\n</code></pre> <p>You can also implement the Java Predicate interface using a Lambda expression. Here is an example of implementing the Predicate interface using a Java lambda expression:</p> <pre><code>Predicate predicate = (value) -&gt; value != null;\n</code></pre> <p>This lambda implementation of the Predicate interface effectively does the same as the implementation above that uses a class.</p>"},{"location":"java-java8/java-8-predicate/#predicate-example","title":"Predicate Example","text":"<p>One usage of Predicate is to filter elements in list.</p> <pre><code>public class PredicateExample {\n    public static void main(String args[]) {\n        List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6, 7, 8, 9);\n\n        // Predicate&lt;Integer&gt; predicate = n -&gt; true\n        // n is passed as parameter to test method of Predicate interface\n        // test method will always return true no matter what value n has.\n\n        System.out.print(\"Print all numbers: \");\n\n        //pass n as parameter\n        evaluate(list, n-&gt;true);\n\n        // Predicate&lt;Integer&gt; predicate1 = n -&gt; n%2 == 0\n        // n is passed as parameter to test method of Predicate interface\n        // test method will return true if n%2 comes to be zero\n\n        System.out.print(\"Print even numbers: \");\n        //evaluate(list, n-&gt; n%2 == 0 );\n        evaluate(list, new evenPredicate());\n\n        // Predicate&lt;Integer&gt; predicate2 = n -&gt; n &gt; 3\n        // n is passed as parameter to test method of Predicate interface\n        // test method will return true if n is greater than 3.\n\n        System.out.print(\"Print numbers greater than 3: \");\n        evaluate(list, n-&gt; n &gt; 3 );\n    }\n\n    public static void evaluate(List&lt;Integer&gt; list, Predicate&lt;Integer&gt; predicate) {\n        for(Integer num: list) {\n            if (predicate.test(num)) {\n                System.out.print(num + \",\");\n            }\n        }\n        System.out.println();\n    }\n\n    private static class evenPredicate implements Predicate&lt;Integer&gt; {\n        @Override\n        public boolean test(Integer num) {\n            return num % 2 == 0;\n        }\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>Print all numbers: 1,2,3,4,5,6,7,8,9,\nPrint even numbers: 2,4,6,8,\nPrint numbers greater than 3: 4,5,6,7,8,9,\n</code></pre>"},{"location":"java-java8/java-8-predicate/#predicate-iterator","title":"Predicate + Iterator","text":"<p>Implement an iterator with predicate interface.</p>"},{"location":"java-java8/java-8-predicate/#custom-predicate","title":"Custom Predicate","text":"<p>Create a custom predicate, which returns true only if the given value is larger than 5.</p> <pre><code>import java.util.function.Predicate;\n\npublic class BiggerThanFivePredicate implements Predicate&lt;Integer&gt; {\n    @Override\n    public boolean test(Integer val) {\n\n        Integer five = 5;\n\n        return val &gt; five;\n    }\n}\n</code></pre>"},{"location":"java-java8/java-8-predicate/#predicate-iterator_1","title":"Predicate Iterator","text":"<p>Create a class, implement Iterator interface. Override the <code>hasNext()</code> and <code>next()</code> method. Use the custom predicate to filter out unmatched data.</p> <pre><code>import java.util.Iterator;\n\npublic class PredicateIterator implements Iterator&lt;Integer&gt; {\n\n    private Iterator&lt;Integer&gt; itr;\n    private BiggerThanFivePredicate btf;\n    private Integer next;\n    public PredicateIterator(Iterator&lt;Integer&gt; itr, BiggerThanFivePredicate btf) {\n        this.itr = itr;\n        this.btf = btf;\n    }\n\n    @Override\n    public boolean hasNext(){\n        if (next != null) {\n            return true;\n        }\n\n        while (itr.hasNext()) {\n            Integer num = itr.next();\n            if (btf.test(num)) {\n                next = num;\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    @Override\n    public Integer next() {\n        if (hasNext()) {\n            int temp = next;\n            next = null;\n            return temp;\n        }\n\n        return null;\n    }\n}\n</code></pre> <p>Test PredicateIterator.</p> <pre><code>public static void main(String args[]) {\n    List&lt;Integer&gt; list = new ArrayList&lt;&gt;(Arrays.asList(new Integer[]{3,5,6,8,2,4,7,1}));\n    BiggerThanFivePredicate btf = new BiggerThanFivePredicate();\n    PredicateIterator iterator = new PredicateIterator(list.iterator(), btf);\n\n    while (iterator.hasNext()) {\n        Integer num = iterator.next();\n        System.out.println(num);\n    }\n}\n</code></pre> <p>Output.</p> <pre><code>6\n8\n7\n</code></pre>"},{"location":"java-java8/java-8-predicate/#source-files","title":"Source Files","text":"<ul> <li>Source files for Java 8 Predicate on GitHub</li> </ul>"},{"location":"java-java8/java-8-predicate/#references","title":"References","text":"<ul> <li>Java Predicate</li> <li>Java Predicate \u2013 Java 8 Predicate</li> <li>Java 8 - Functional Interfaces</li> </ul>"},{"location":"java-java8/java-8-stream-api/","title":"Stream API","text":"<p>The Java Stream API provides a functional approach to processing collections of objects. The Java Stream API was added in Java 8 along with several other functional programming features.</p> <p>The Java Stream API is not related to the Java InputStream and Java OutputStream of Java IO. The InputStream and OutputStream are related to streams of bytes. The Java Stream API is for processing streams of objects - not bytes.</p> <p>A Java Stream is a component that is capable of internal iteration of its elements, meaning it can iterate its elements itself. In contrast, when you are using the Java Collections iteration features (e.g a Java Iterator or the Java for-each loop used with a Java Iterable) you have to implement the iteration of the elements yourself.</p>"},{"location":"java-java8/java-8-stream-api/#stream-processing","title":"Stream Processing","text":"<p>You can attach listeners to a Stream. These listeners are called when the Stream iterates the elements internally. The listeners are called once for each element in the stream. That way each listener gets to process each element in the stream. This is referred to as stream processing.</p> <p>The listeners of a stream form a chain. The first listener in the chain can process the element in the stream, and then return a new element for the next listener in the chain to process. A listener can either return the same element or a new, depending on what the purpose of that listener (processor) is.</p>"},{"location":"java-java8/java-8-stream-api/#obtain-a-stream","title":"Obtain a Stream","text":"<p>There are many ways to obtain a Java Stream. One of the most common ways to obtain a Stream is from a Java Collection. Here is an example of obtaining a Stream from a Java List:</p> <pre><code>List&lt;String&gt; items = new ArrayList&lt;String&gt;();\n\nitems.add(\"one\");\nitems.add(\"two\");\nitems.add(\"three\");\n\nStream&lt;String&gt; stream = items.stream();    \n</code></pre> <p>This example first creates a Java List, then adds three Java Strings to it. Finally, the example calls the stream() method to obtain a Stream instance.</p>"},{"location":"java-java8/java-8-stream-api/#terminal-and-non-terminal-operations","title":"Terminal and Non-Terminal Operations","text":"<p>The Stream interface has a selection of <code>terminal</code> and <code>non-terminal</code> operations. A non-terminal stream operation is an operation that adds a listener to the stream without doing anything else. A terminal stream operation is an operation that starts the internal iteration of the elements, calls all the listeners, and returns a result.</p> <p>Here is a Java Stream example which contains both a non-terminal and a terminal operation:</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\nimport java.util.stream.Stream;\n\npublic class StreamExamples {\n\n    public static void main(String[] args) {\n        List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\n        stringList.add(\"ONE\");\n        stringList.add(\"TWO\");\n        stringList.add(\"THREE\");\n\n        Stream&lt;String&gt; stream = stringList.stream();\n\n        long count = stream\n            .map((value) -&gt; { return value.toLowerCase(); })\n            .count();\n\n        System.out.println(\"count = \" + count);\n\n    }\n}\n</code></pre> <p>The call to the <code>map()</code> method of the Stream interface is a non-terminal operation. It merely sets a lambda expression on the stream which converts each element to lowercase. The map() method will be covered in more detail later on.</p> <p>The call to the <code>count()</code> method is a terminal operation. This call starts the iteration internally, which will result in each element being converted to lowercase and then counted.</p> <p>The conversion of the elements to lowercase does not actually affect the count of elements. The conversion part is just there as an example of a non-terminal operation.</p>"},{"location":"java-java8/java-8-stream-api/#non-terminal-operations","title":"Non-Terminal Operations","text":"<p>The non-terminal stream operations of the Java Stream API are operations that transform or filter the elements in the stream. When you add a non-terminal operation to a stream, you get a new stream back as result. The new stream represents the stream of elements resulting from the original stream with the non-terminal operation applied. Here is an example of a non-terminal operation added to a stream - which results in a new stream:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"ONE\");\nstringList.add(\"TWO\");\nstringList.add(\"THREE\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nStream&lt;String&gt; stringStream =\n    stream.map((value) -&gt; { return value.toLowerCase(); });\n</code></pre> <p>Notice the call to stream.map(). This call actually returns a new Stream instance representing the original stream of strings with the map operation applied.</p> <p>You can only add a single operation to a given Stream instance. If you need to chain multiple operations after each other, you will need to apply the second operation to the Stream operation resulting from the first operation. Here is how that looks:</p> <pre><code>Stream&lt;String&gt; stringStream1 =\n        stream.map((value) -&gt; { return value.toLowerCase(); });\n\nStream&lt;\u00bdString&gt; stringStream2 =\n        stringStream1.map((value) -&gt; { return value.toUpperCase(); });\n</code></pre> <p>Notice how the second call to Stream map() is called on the Stream returned by the first map() call.</p> <p>It is quite common to chain the calls to non-terminal operations on a Java Stream. Here is an example of chaining the non-terminal operation calls on Java streams:</p> <pre><code>Stream&lt;String&gt; stream1 = stream\n  .map((value) -&gt; { return value.toLowerCase(); })\n  .map((value) -&gt; { return value.toUpperCase(); })\n  .map((value) -&gt; { return value.substring(0,3); });\n</code></pre> <p>Many non-terminal Stream operations can take a Java Lambda Expression as parameter. This lambda expression implements a Java functional interface that fits the given non-terminal operation. For instance, the Function or Predicate interface. The parameter of the non-terminal operation method parameter is typically a functional interface - which is why it can also be implemented by a Java lambda expression.</p>"},{"location":"java-java8/java-8-stream-api/#filter","title":"filter()","text":"<p>The Java Stream <code>filter()</code> can be used to filter out elements from a Java Stream. The filter method takes a <code>Predicate</code> which is called for each element in the stream. If the element is to be included in the resulting Stream, the Predicate should return true. If the element should not be included, the Predicate should return false.</p> <p>Here is an example of calling the Java Stream filter() method:</p> <pre><code>Stream&lt;String&gt; longStringsStream = stream.filter((value) -&gt; {\n    return value.length() &gt;= 3;\n});\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#map","title":"map()","text":"<p>The Java Stream <code>map()</code> method converts (maps) an element to another object. For instance, if you had a list of strings it could convert each string to lowercase, uppercase, or to a substring of the original string, or something completely else. Here is a Java Stream map() example:</p> <pre><code>List&lt;String&gt; list = new ArrayList&lt;String&gt;();\nStream&lt;String&gt; stream = list.stream();\n\nStream&lt;String&gt; streamMapped = stream.map((value) -&gt; value.toUpperCase());\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#flatmap","title":"flatMap()","text":"<p>The Java Stream <code>flatMap()</code> methods maps a single element into multiple elements. The idea is that you \"flatten\" each element from a complex structure consisting of multiple internal elements, to a \"flat\" stream consisting only of these internal elements.</p> <p>For instance, imagine you have an object with nested objects (child objects). Then you can map that object into a \"flat\" stream consisting of itself plus its nested objects - or only the nested objects. You could also map a stream of Lists of elements to the elements themselves. Or map a stream of strings to a stream of words in these strings - or to the individual Character instances in these strings.</p> <p>Here is an example that flatmaps a List of strings to the words in each string. This example should give you an idea about how flatMap() can be used to map a single element into multiple elements.</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nstream.flatMap((value) -&gt; {\n    String[] split = value.split(\" \");\n    return (Stream&lt;String&gt;) Arrays.asList(split).stream();\n})\n.forEach((value) -&gt; System.out.println(value));\n</code></pre> <p>This Java Stream flatMap() example first creates a List with 3 strings containing book titles. Then a Stream for the List is obtained, and flatMap() called.</p> <p>The flatMap() operation called on the Stream has to return another Stream representing the flat mapped elements. In the example above, each original string is split into words, turned into a List, and the stream obtained and returned from that List.</p> <p>Note that this example finishes with a call to forEach() which is a terminal operation. This call is only there to trigger the internal iteration, and thus flat map operation. If no terminal operation was called on the Stream chain, nothing would have happened. No flat mapping would actually have taken place.</p>"},{"location":"java-java8/java-8-stream-api/#distinct","title":"distinct()","text":"<p>The Java Stream <code>distinct()</code> method is a non-terminal operation that returns a new Stream which will only contain the distinct elements from the original stream. Any duplicates will be eliminated. Here is an example of the Java Stream distinct() method:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"one\");\nstringList.add(\"two\");\nstringList.add(\"three\");\nstringList.add(\"one\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nList&lt;String&gt; distinctStrings = stream\n        .distinct()\n        .collect(Collectors.toList());\n\nSystem.out.println(distinctStrings);\n</code></pre> <p>In this example the element one appears 2 times in the original stream. Only the first occurrence of this element will be included in the Stream returned by distinct(). Thus, the resulting List (from calling collect()) will only contain one, two and three. The output printed from this example will be:</p> <pre><code>[one, two, three]\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#limit","title":"limit()","text":"<p>The Java Stream <code>limit()</code> method can limit the number of elements in a stream to a number given to the limit() method as parameter. The limit() method returns a new Stream which will at most contain the given number of elements. Here is a Java Stream limit() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"one\");\nstringList.add(\"two\");\nstringList.add(\"three\");\nstringList.add(\"one\");\n\nStream&lt;String&gt; stream = stringList.stream();\nstream\n    .limit(2)\n    .forEach( element -&gt; { System.out.println(element); });\n</code></pre> <p>This example first creates a Stream, then calls limit() on it, and then calls forEach() with a lambda that prints out the elements in the stream. Only the two first elements will be printed because of the limit(2) call.</p>"},{"location":"java-java8/java-8-stream-api/#peek","title":"peek()","text":"<p>The Java Stream <code>peek()</code> method is a non-terminal operation that takes a <code>Consumer</code> (java.util.function.Consumer) as parameter. The Consumer will get called for each element in the stream. The peek() method returns a new Stream which contains all the elements in the original stream.</p> <p>The purpose of the peek() method is, as the method says, to peek at the elements in the stream, not to transform them. Keep in mind that the peek method does not start the internal iteration of the elements in the stream. You need to call a terminal operation for that. Here is a Java Stream peek() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"abc\");\nstringList.add(\"def\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nStream&lt;String&gt; streamPeeked = stream.peek((value) -&gt; {\n    System.out.println(\"value\");\n});\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#terminal-operations","title":"Terminal Operations","text":"<p>The terminal operations of the Java Stream interface typically return a <code>single value</code>. Once the terminal operation is invoked on a Stream, the iteration of the Stream and any of the chained streams will get started. Once the iteration is done, the result of the terminal operation is returned.</p> <p>A terminal operation typically does not return a new Stream instance. Thus, once you call a terminal operation on a stream, the chaining of Stream instances from non-terminal operation ends. Here is an example of calling a terminal operation on a Java Stream:</p> <pre><code>long count = stream\n  .map((value) -&gt; { return value.toLowerCase(); })\n  .map((value) -&gt; { return value.toUpperCase(); })\n  .map((value) -&gt; { return value.substring(0,3); })\n  .count();\n</code></pre> <p>It is the call to count() at the end of the example that is the terminal operation. Since count() returns a long, the Stream chain of non-terminal operations (the map() calls) is ended.</p>"},{"location":"java-java8/java-8-stream-api/#anymatch","title":"anyMatch()","text":"<p>The Java Stream <code>anyMatch()</code> method is a terminal operation that takes a single <code>Predicate</code> as parameter, starts the internal iteration of the Stream, and applies the Predicate parameter to each element. If the Predicate returns true for any of the elements, the anyMatch() method returns true. If no elements match the Predicate, anyMatch() will return false. Here is a Java Stream anyMatch() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nboolean anyMatch = stream.anyMatch((value) -&gt; { return value.startsWith(\"One\"); });\nSystem.out.println(anyMatch);\n</code></pre> <p>In the example above, the anyMatch() method call will return true, because the first string element in the stream starts with \"One\".</p>"},{"location":"java-java8/java-8-stream-api/#allmatch","title":"allMatch()","text":"<p>The Java Stream <code>allMatch()</code> method is a terminal operation that takes a single <code>Predicate</code> as parameter, starts the internal iteration of elements in the Stream, and applies the Predicate parameter to each element. If the Predicate returns true for all elements in the Stream, the allMatch() will return true. If not all elements match the Predicate, the allMatch() method returns false. Here is a Java Stream allMatch() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nboolean allMatch = stream.allMatch((value) -&gt; { return value.startsWith(\"One\"); });\nSystem.out.println(allMatch);\n</code></pre> <p>In the example above, the allMatch() method will return false, because only one of the strings in the Stream starts with \"One\".</p>"},{"location":"java-java8/java-8-stream-api/#nonematch","title":"noneMatch()","text":"<p>The Java Stream <code>noneMatch()</code> method is a terminal operation that will iterate the elements in the stream and return true or false, depending on whether no elements in the stream matches the <code>Predicate</code> passed to noneMatch() as parameter. The noneMatch() method will return true if no elements are matched by the Predicate, and false if one or more elements are matched. Here is a Java Stream noneMatch() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"abc\");\nstringList.add(\"def\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nboolean noneMatch = stream.noneMatch((element) -&gt; {\n    return \"xyz\".equals(element);\n});\n\nSystem.out.println(\"noneMatch = \" + noneMatch);\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#collect","title":"collect()","text":"<p>The Java Stream <code>collect()</code> method is a terminal operation that starts the internal iteration of elements, and collects the elements in the stream in a collection or object of some kind. Here is a simple Java Stream collect() method example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nList&lt;String&gt; stringsAsUppercaseList = stream\n.map(value -&gt; value.toUpperCase())\n.collect(Collectors.toList());\n\nSystem.out.println(stringsAsUppercaseList);\n</code></pre> <p>The collect() method takes a <code>Collector</code> (java.util.stream.Collector) as parameter. Implementing a Collector requires some study of the Collector interface. Luckily, the Java class java.util.stream.Collectors contains a set of pre-implemented Collector implementations you can use, for the most common operations. In the example above, it was the Collector implementation returned by Collectors.toList() that was used. This Collector simply collects all elements in the stream in a standard Java List</p>"},{"location":"java-java8/java-8-stream-api/#count","title":"count()","text":"<p>The Java Stream <code>count()</code> method is a terminal operation which starts the internal iteration of the elements in the Stream, and counts the elements. Here is a Java Stream count() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nlong count = stream.flatMap((value) -&gt; {\n    String[] split = value.split(\" \");\n    return (Stream&lt;String&gt;) Arrays.asList(split).stream();\n}).count();\nSystem.out.println(\"count = \" + count);\n</code></pre> <p>This example first creates a List of strings, then obtain the Stream for that List, adds a flatMap() operation for it, and then finishes with a call to count(). The count() method will start the iteration of the elements in the Stream which will result in the string elements being split up into words in the flatMap() operation, and then counted. The final result that will be printed out is 14.</p>"},{"location":"java-java8/java-8-stream-api/#findany","title":"findAny()","text":"<p>The Java Stream <code>findAny()</code> method can find a single element from the Stream. The element found can be from anywhere in the Stream. There is no guarantee about from where in the stream the element is taken. Here is a Java Stream findAny() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"one\");\nstringList.add(\"two\");\nstringList.add(\"three\");\nstringList.add(\"one\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nOptional&lt;String&gt; anyElement = stream.findAny();\n\nSystem.out.println(anyElement.get());\n</code></pre> <p>Notice how the findAny() method returns an <code>Optional</code>. The Stream could be empty - so no element could be returned. You can check if an element was found via the Optional isPresent() method.</p>"},{"location":"java-java8/java-8-stream-api/#findfirst","title":"findFirst()","text":"<p>The Java Stream <code>findFirst()</code> method finds the first element in the Stream, if any elements are present in the Stream. The findFirst() method returns an <code>Optional</code> from which you can obtain the element, if present. Here is a Java Stream findFirst() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"one\");\nstringList.add(\"two\");\nstringList.add(\"three\");\nstringList.add(\"one\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nOptional&lt;String&gt; result = stream.findFirst();\n\nSystem.out.println(result.get());\n</code></pre> <p>You can check if the Optional returned contains an element via its isPresent() method.</p>"},{"location":"java-java8/java-8-stream-api/#foreach","title":"forEach()","text":"<p>The Java Stream <code>forEach()</code> method is a terminal operation which starts the internal iteration of the elements in the Stream, and applies a <code>Consumer</code> (java.util.function.Consumer) to each element in the Stream. The forEach() method returns void. Here is a Java Stream forEach() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"one\");\nstringList.add(\"two\");\nstringList.add(\"three\");\nstringList.add(\"one\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nstream.forEach( element -&gt; { System.out.println(element); });\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#min","title":"min()","text":"<p>The Java Stream <code>min()</code> method is a terminal operation that returns the smallest element in the Stream. Which element is the smallest is determined by the <code>Comparator</code> implementation you pass to the min() method. Here is a Java Stream min() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"abc\");\nstringList.add(\"def\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nOptional&lt;String&gt; min = stream.min((val1, val2) -&gt; {\n    return val1.compareTo(val2);\n});\n\nString minString = min.get();\n\nSystem.out.println(minString);\n</code></pre> <p>Notice how the min() method returns an <code>Optional</code> which may or may not contain a result. If the Stream is empty, the Optional get() method will throw a NoSuchElementException.</p>"},{"location":"java-java8/java-8-stream-api/#max","title":"max()","text":"<p>The Java Stream <code>max()</code> method is a terminal operation that returns the largest element in the Stream. Which element is the largest is determined by the <code>Comparator</code> implementation you pass to the max() method. Here is a Java Stream max() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"abc\");\nstringList.add(\"def\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nOptional&lt;String&gt; max = stream.max((val1, val2) -&gt; {\n    return val1.compareTo(val2);\n});\n\nString maxString = max.get();\n\nSystem.out.println(maxString);\n</code></pre> <p>Notice how the max() method returns an <code>Optional</code> which may or may not contain a result. If the Stream is empty, the Optional get() method will throw a NoSuchElementException.</p>"},{"location":"java-java8/java-8-stream-api/#reduce","title":"reduce()","text":"<p>The Java Stream reduce() method is a terminal operation that can reduce all elements in the stream to a single element. Here is a Java Stream reduce() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nOptional&lt;String&gt; reduced = stream.reduce((value, combinedValue) -&gt; {\n    return combinedValue + \" + \" + value;\n});\n\nSystem.out.println(reduced.get());\n</code></pre> <p>Notice the <code>Optional</code> returned by the reduce() method. This Optional contains the value (if any) returned by the lambda expression passed to the reduce() method. You obtain the value by calling the Optional get() method.</p>"},{"location":"java-java8/java-8-stream-api/#toarray","title":"toArray()","text":"<p>The Java Stream <code>toArray()</code> method is a terminal operation that starts the internal iteration of the elements in the stream, and returns an array of Object containing all the elements. Here is a Java Stream toArray() example:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream = stringList.stream();\n\nObject[] objects = stream.toArray();\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#concatenate-streams","title":"Concatenate Streams","text":"<p>The Java Stream interface contains a static method called <code>concat()</code> which can concatenate two streams into one. The result is a new Stream which contains all of the elements from the first stream, followed by all of the elements from the second stream. Here is an example of using the Java Stream concat() method:</p> <pre><code>List&lt;String&gt; stringList = new ArrayList&lt;String&gt;();\n\nstringList.add(\"One flew over the cuckoo's nest\");\nstringList.add(\"To kill a muckingbird\");\nstringList.add(\"Gone with the wind\");\n\nStream&lt;String&gt; stream1 = stringList.stream();\n\nList&lt;String&gt; stringList2 = new ArrayList&lt;&gt;();\nstringList2.add(\"Lord of the Rings\");\nstringList2.add(\"Planet of the Rats\");\nstringList2.add(\"Phantom Menace\");\n\nStream&lt;String&gt; stream2 = stringList2.stream();\n\nStream&lt;String&gt; concatStream = Stream.concat(stream1, stream2);\n\nList&lt;String&gt; stringsAsUppercaseList = concatStream\n        .collect(Collectors.toList());\n\nSystem.out.println(stringsAsUppercaseList);\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#create-stream-from-array","title":"Create Stream From Array","text":"<p>The Java Stream interface contains a static method called <code>of()</code> which can be used to create a Stream from one or more objects. Here is an example of using the Java Stream of() method:</p> <pre><code>Stream&lt;String&gt; streamOf = Stream.of(\"one\", \"two\", \"three\");\n</code></pre>"},{"location":"java-java8/java-8-stream-api/#references","title":"References","text":"<ul> <li>Java Stream API</li> </ul>"},{"location":"java-java8/java-8-tricks/","title":"Java 8 - Tricks","text":""},{"location":"java-java8/java-8-tricks/#sorting","title":"Sorting","text":"<p>Verbose code for sorting.</p> <pre><code>Collections.sort(inventory, new Comparator&lt;Apple&gt;() {\n    public int compare(Apple a1, Apple a2){\n        return a1.getWeight().compareTo(a2.getWeight());\n    }\n});\n</code></pre> <p>With Lamda expression.</p> <pre><code>inventory.sort(comparing(Apple::getWeight));\n</code></pre>"},{"location":"java-java8/java-8-tricks/#core-featureconcepts","title":"Core Feature/Concepts","text":"<ul> <li>stream processing</li> <li>behavior parameterization, functional programming</li> <li>default methods in interface</li> <li>method reference: <code>::</code> syntax</li> <li>anonymous functions, lambda expression</li> <li>functional interface: an interface that specifies exactly one abstract method.</li> </ul> <p>A lambda expression is composed of parameters, an arrow, and a body.</p> <pre><code>1 ()-&gt;{}\n2 () -&gt; \"Raoul\"\n3 () -&gt; { return \"Mario\"; }\n4 (Integer i) -&gt; return \"Alan\" + i;\n5 (String s) -&gt; { \"Iron Man\"; }\n</code></pre> <p>4 and 5 are invalid lambdas; the rest are valid. Details:</p> <ul> <li>1 This lambda has no parameters and returns void. It\u2019s similar to a method with an empty body:publicvoidrun(){}. Fun fact: this is usually called the burger lambda. Take a look at it from the side, and you will see it has a burger shape with two buns.</li> <li>2 This lambda has no parameters and returns a String as an expression.</li> <li>3 This lambda has no parameters and returns a String (using an explicit return statement, within a block).</li> <li>4 return is a control-flow statement. To make this lambda valid, curly braces are required as follows:(Integeri)-&gt;{return\"Alan\"+i;}.</li> <li>5 \u201cIron Man\u201d is an expression, not a statement. To make this lambda valid, you can remove the curly braces and semicolon as follows:(Strings)-&gt;\"Iron Man\". Or if you prefer, you can use an explicit return statement as follows: (String s) -&gt; { return \"Iron Man\"; }.</li> </ul> Use case Examples of lambdas A boolean expression (List list) -&gt; list.isEmpty() Creating objects () -&gt; new Apple(10) Consuming from an object (Apple a) -&gt; Select/extract from an object (String s) -&gt; s.length() Combine two values (int a, int b) -&gt; a * b Compare two objects (Apple a1, Apple a2) -&gt; a1.getWeight().compareTo(a2.getWeight()) <p>Functional Interface.</p> <p>Which of these interfaces are functional interfaces?</p> <pre><code>public interface Adder {\n    int add(int a, int b);\n}\npublic interface SmartAdder extends Adder {\n    int add(double a, double b);\n}\npublic interface Nothing {\n}\n</code></pre> <p>Answer:</p> <ul> <li>Only <code>Adder</code> is a functional interface.</li> <li><code>SmartAdder</code> isn\u2019t a functional interface because it specifies two abstract methods called add (one is inherited from Adder).</li> <li><code>Nothing</code> isn\u2019t a functional interface because it declares no abstract method at all.</li> </ul> <p>Collection</p> <ul> <li>removeIf</li> <li>replaceAll</li> <li>Map.forEach</li> <li>Entry.comparingByValue</li> <li>Entry.comparingByKey</li> </ul> <p>Null check. Optional Class</p> <pre><code>public String getCarInsuranceName(Person person) {\n    if (person != null) {\n        Car car = person.getCar();\n        if (car != null) {\n            Insurance insurance = car.getInsurance();\n            if (insurance != null) {\n              return insurance.getName();\n            }\n        }\n    }\n    return \"Unknown\";\n}\n</code></pre> <p><code>java.util.Optional&lt;T&gt;</code></p> <p>Manipulating a stream of optionals</p> <pre><code>public Set&lt;String&gt; getCarInsuranceNames(List&lt;Person&gt; persons) {\n   return persons.stream()\n\n   Collect the result Strings into a Set to obtain only the distinct values.\n   .map(Person::getCar)\n   .map(optCar -&gt; optCar.flatMap(Car::getInsurance))\n   .map(optIns -&gt; optIns.map(Insurance::getName))\n   .flatMap(Optional::stream)\n   .collect(toSet());\n</code></pre>"},{"location":"java-java8/java-8-tricks/#references","title":"References","text":"<ul> <li>Java 8 Optional In Depth</li> </ul>"},{"location":"programming/getting-started-with-linux/","title":"Getting Started With Linux.md","text":""},{"location":"programming/getting-started-with-macos/","title":"Getting Started With macOS","text":""},{"location":"tutorial/getting-started-with-angular-cli/","title":"getting-started-with-angular-cli","text":""},{"location":"tutorial/getting-started-with-react/","title":"getting-started-with-react","text":""}]}